{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u6b22\u8fce\u6765\u5230 iWiki weiyong1024\u7684\u77e5\u8bc6\u5c0f\u7ad9 \u535a\u4e3b\u81ea\u8ba4\u624d\u758f\u5b66\u6d45\uff0c\u8bda\u9080\u5404\u4f4d\u770b\u5b98\u6279\u8bc4\u6307\u6b63\uff0c\u8868\u8fbe\u9519\u8bef\u3001\u7406\u89e3\u4e0d\u5f53\u4e4b\u5904\u8bf7\u8bf8\u541b\u4e0d\u541d\u8d50\u6559\uff01","title":"\u7b80\u4ecb"},{"location":"#iwiki","text":"weiyong1024\u7684\u77e5\u8bc6\u5c0f\u7ad9 \u535a\u4e3b\u81ea\u8ba4\u624d\u758f\u5b66\u6d45\uff0c\u8bda\u9080\u5404\u4f4d\u770b\u5b98\u6279\u8bc4\u6307\u6b63\uff0c\u8868\u8fbe\u9519\u8bef\u3001\u7406\u89e3\u4e0d\u5f53\u4e4b\u5904\u8bf7\u8bf8\u541b\u4e0d\u541d\u8d50\u6559\uff01","title":"\u6b22\u8fce\u6765\u5230 iWiki"},{"location":"about/","text":"\u5173\u4e8e\u4f5c\u8005 \u5317\u822a\u7535\u5b50\u7cfb\u672c\u7855\uff0c\u5e08\u4ece\u6768\u6668\u9633\u6559\u6388\u505a5G\u7269\u7406\u5c42\u65e0\u7ebf\u94fe\u8def\u4fe1\u9053\u4f18\u5316\u7814\u7a76\u3002\u4e0a\u5b66\u671f\u95f4\u5148\u5728 \u65f7\u89c6\u79d1\u6280/Face++ \u505a\u4e86\u4e94\u4e2a\u6708\u70bc\u4e39\u5e08\u5b9e\u4e60\u751f\uff0c\u540e\u4e8e \u7231\u5f7c\u8fce/Airbnb\u4e2d\u56fd \u505a\u4e86\u4e09\u4e2a\u6708Ruby on Rails\u5f00\u53d1\u3002\u6bd5\u4e1a\u540e\u5728 \u5c0f\u9a6c\u667a\u884c/Pony.ai \u57fa\u7840\u67b6\u6784\u7ec4\u5de5\u4f5c\u4e00\u5e74\u96f6\u4e00\u6708\u3002\u76ee\u524d\u79bb\u804c\u5904\u4e8e \u81ea\u7531\u72b6\u6001 \uff0c\u671f\u5f85\u4e0b\u4e00\u6bb5\u804c\u4e1a\u751f\u6daf\u5728\u4e91\u8ba1\u7b97\u6216\u77ed\u89c6\u9891\u9886\u57df\u3002 \u90ae\u7bb1 weiyong1024@gmail.com No excuses. Just learn. \u535a\u5ba2\u63a8\u8350 \u9762\u5411\u4fe1\u4ef0\u7f16\u7a0b","title":"\u5173\u4e8e\u4f5c\u8005"},{"location":"about/#_1","text":"\u5317\u822a\u7535\u5b50\u7cfb\u672c\u7855\uff0c\u5e08\u4ece\u6768\u6668\u9633\u6559\u6388\u505a5G\u7269\u7406\u5c42\u65e0\u7ebf\u94fe\u8def\u4fe1\u9053\u4f18\u5316\u7814\u7a76\u3002\u4e0a\u5b66\u671f\u95f4\u5148\u5728 \u65f7\u89c6\u79d1\u6280/Face++ \u505a\u4e86\u4e94\u4e2a\u6708\u70bc\u4e39\u5e08\u5b9e\u4e60\u751f\uff0c\u540e\u4e8e \u7231\u5f7c\u8fce/Airbnb\u4e2d\u56fd \u505a\u4e86\u4e09\u4e2a\u6708Ruby on Rails\u5f00\u53d1\u3002\u6bd5\u4e1a\u540e\u5728 \u5c0f\u9a6c\u667a\u884c/Pony.ai \u57fa\u7840\u67b6\u6784\u7ec4\u5de5\u4f5c\u4e00\u5e74\u96f6\u4e00\u6708\u3002\u76ee\u524d\u79bb\u804c\u5904\u4e8e \u81ea\u7531\u72b6\u6001 \uff0c\u671f\u5f85\u4e0b\u4e00\u6bb5\u804c\u4e1a\u751f\u6daf\u5728\u4e91\u8ba1\u7b97\u6216\u77ed\u89c6\u9891\u9886\u57df\u3002","title":"\u5173\u4e8e\u4f5c\u8005"},{"location":"about/#_2","text":"weiyong1024@gmail.com","title":"\u90ae\u7bb1"},{"location":"about/#no-excuses-just-learn","text":"","title":"No excuses. Just learn."},{"location":"about/#_3","text":"\u9762\u5411\u4fe1\u4ef0\u7f16\u7a0b","title":"\u535a\u5ba2\u63a8\u8350"},{"location":"competitive_programming/basic/binary_search/","text":"\u4e8c\u5206\u641c\u7d22 \u95ee\u9898 \u5bfb\u627e\u9608\u503c\uff1a\u82e5\u6240\u6c42\u95ee\u9898\u5177\u6709\u5927\u4e8e\u7b49\u4e8e\u67d0\u4e00\u9608\u503c\u201c\u53ef\u884c\u201d\u3001\u5c0f\u4e8e\u8be5\u9608\u503c\u201c\u4e0d\u53ef\u884c\u201d\u7684\u4e8c\u6bb5\u6027\uff0c\u6216\u8005\u5c5e\u4e8e\u5bfb\u627e\u6ee1\u8db3\u6761\u4ef6\u7684\u6700\u5c0f\u6570\u91cf\u95ee\u9898\uff0c\u53ef\u5229\u7528\u5bfb\u627e\u9608\u503c\u7684\u4e8c\u5206\u641c\u7d22\u6c42\u89e3 \u4ee3\u7801 check() \u51fd\u6570\u7528\u4e8e\u5224\u5b9a\u5f53\u524d\u503c\u662f\u5426\u53ef\u884c \u8fde\u7eed\u578b\u533a\u95f4\u7684\u4e8c\u5206\u641c\u7d22 \u5728 x \\in [0, 10^9] x \\in [0, 10^9] \u8303\u56f4\u5185\u5bfb\u627e\u6ee1\u8db3\u6761\u4ef6 check(x)=true check(x)=true \u7684\u6307\u5b9a\u7cbe\u5ea6\u7684\u6700\u5c0f x x double bi_search () { double l = 0 , r = 1e9 ; for ( int i = 0 ; i < 300 ; i ++ ) { double m = ( l + r ) / 2l ; if ( check ( m )) r = m ; else l = m ; } return l ; } \u8fed\u4ee3\u6b65\u6570\u53ef\u7531 \u521d\u59cb\u533a\u95f4\u957f\u5ea6 \u548c \u7cbe\u5ea6\u8981\u6c42 \u786e\u5b9a\u3002 \u79bb\u6563\u578b\u533a\u95f4\u7684\u4e8c\u5206\u641c\u7d22 \u5728 x \\in [0, n - 1], x \\in \\mathbb{Z} x \\in [0, n - 1], x \\in \\mathbb{Z} \u8303\u56f4\u5185\u5bfb\u627e\u6ee1\u8db3\u6761\u4ef6 check(x)=true check(x)=true \u7684\u6700\u5c0f x x \uff0c\u5982\u4e0d\u5b58\u5728\u8fd4\u56de -1 -1 \u3002 int bi_search () { int ans = - 1 ; int l = 0 , r = n - 1 ; while ( l <= r ) { int m = ( l + r ) >> 1 ; if ( check ( m )) ans = m , r = m - 1 ; else l = m + 1 ; } return ans ; } [l, r] [l, r] \u7ef4\u62a4\u7684\u662f\u5269\u4f59\u641c\u7d22\u57df\u3002 \u5e94\u7528 \u5728\u6709\u5e8f\u6570\u7ec4\u4e2d\u5224\u65ad\u76ee\u6807\u503c\u7684\u5b58\u5728\u6027 \u4ee5\u6570\u7ec4\u4e0b\u6807\u4e3a\u641c\u7d22\u57df\uff0c\u5b9e\u73b0\u51fd\u6570\u8fd4\u56de bool \u578b\u53d8\u91cf\uff0c\u5224\u65ad\u76ee\u6807\u503c target target \u662f\u5426\u5728\u5e8f\u5217 a a \u4e2d\u51fa\u73b0\u3002 bool bi_search ( vector < int > a , int target ) { int l = 0 , r = a . size () - 1 ; while ( l <= r ) { int m = ( l + r ) >> 1 ; if ( a [ m ] == target ) return true ; if ( a [ m ] < target ) l = m + 1 ; else r = m - 1 ; } return false ; } [l, r] [l, r] \u7ef4\u62a4\u7684\u662f\u5269\u4f59\u641c\u7d22\u57df\u3002","title":"\u4e8c\u5206\u641c\u7d22"},{"location":"competitive_programming/basic/binary_search/#_1","text":"","title":"\u4e8c\u5206\u641c\u7d22"},{"location":"competitive_programming/basic/binary_search/#_2","text":"\u5bfb\u627e\u9608\u503c\uff1a\u82e5\u6240\u6c42\u95ee\u9898\u5177\u6709\u5927\u4e8e\u7b49\u4e8e\u67d0\u4e00\u9608\u503c\u201c\u53ef\u884c\u201d\u3001\u5c0f\u4e8e\u8be5\u9608\u503c\u201c\u4e0d\u53ef\u884c\u201d\u7684\u4e8c\u6bb5\u6027\uff0c\u6216\u8005\u5c5e\u4e8e\u5bfb\u627e\u6ee1\u8db3\u6761\u4ef6\u7684\u6700\u5c0f\u6570\u91cf\u95ee\u9898\uff0c\u53ef\u5229\u7528\u5bfb\u627e\u9608\u503c\u7684\u4e8c\u5206\u641c\u7d22\u6c42\u89e3","title":"\u95ee\u9898"},{"location":"competitive_programming/basic/binary_search/#_3","text":"check() \u51fd\u6570\u7528\u4e8e\u5224\u5b9a\u5f53\u524d\u503c\u662f\u5426\u53ef\u884c","title":"\u4ee3\u7801"},{"location":"competitive_programming/basic/binary_search/#_4","text":"\u5728 x \\in [0, 10^9] x \\in [0, 10^9] \u8303\u56f4\u5185\u5bfb\u627e\u6ee1\u8db3\u6761\u4ef6 check(x)=true check(x)=true \u7684\u6307\u5b9a\u7cbe\u5ea6\u7684\u6700\u5c0f x x double bi_search () { double l = 0 , r = 1e9 ; for ( int i = 0 ; i < 300 ; i ++ ) { double m = ( l + r ) / 2l ; if ( check ( m )) r = m ; else l = m ; } return l ; } \u8fed\u4ee3\u6b65\u6570\u53ef\u7531 \u521d\u59cb\u533a\u95f4\u957f\u5ea6 \u548c \u7cbe\u5ea6\u8981\u6c42 \u786e\u5b9a\u3002","title":"\u8fde\u7eed\u578b\u533a\u95f4\u7684\u4e8c\u5206\u641c\u7d22"},{"location":"competitive_programming/basic/binary_search/#_5","text":"\u5728 x \\in [0, n - 1], x \\in \\mathbb{Z} x \\in [0, n - 1], x \\in \\mathbb{Z} \u8303\u56f4\u5185\u5bfb\u627e\u6ee1\u8db3\u6761\u4ef6 check(x)=true check(x)=true \u7684\u6700\u5c0f x x \uff0c\u5982\u4e0d\u5b58\u5728\u8fd4\u56de -1 -1 \u3002 int bi_search () { int ans = - 1 ; int l = 0 , r = n - 1 ; while ( l <= r ) { int m = ( l + r ) >> 1 ; if ( check ( m )) ans = m , r = m - 1 ; else l = m + 1 ; } return ans ; } [l, r] [l, r] \u7ef4\u62a4\u7684\u662f\u5269\u4f59\u641c\u7d22\u57df\u3002","title":"\u79bb\u6563\u578b\u533a\u95f4\u7684\u4e8c\u5206\u641c\u7d22"},{"location":"competitive_programming/basic/binary_search/#_6","text":"","title":"\u5e94\u7528"},{"location":"competitive_programming/basic/binary_search/#_7","text":"\u4ee5\u6570\u7ec4\u4e0b\u6807\u4e3a\u641c\u7d22\u57df\uff0c\u5b9e\u73b0\u51fd\u6570\u8fd4\u56de bool \u578b\u53d8\u91cf\uff0c\u5224\u65ad\u76ee\u6807\u503c target target \u662f\u5426\u5728\u5e8f\u5217 a a \u4e2d\u51fa\u73b0\u3002 bool bi_search ( vector < int > a , int target ) { int l = 0 , r = a . size () - 1 ; while ( l <= r ) { int m = ( l + r ) >> 1 ; if ( a [ m ] == target ) return true ; if ( a [ m ] < target ) l = m + 1 ; else r = m - 1 ; } return false ; } [l, r] [l, r] \u7ef4\u62a4\u7684\u662f\u5269\u4f59\u641c\u7d22\u57df\u3002","title":"\u5728\u6709\u5e8f\u6570\u7ec4\u4e2d\u5224\u65ad\u76ee\u6807\u503c\u7684\u5b58\u5728\u6027"},{"location":"competitive_programming/basic/merge_sort/","text":"\u5f52\u5e76\u6392\u5e8f \u4ee3\u7801 void merge ( int * a , int l , int m , int r ) { // Merge two sub-arraies a[l...m] & a[m + 1...r] into a[l...r]. int n1 = m - l + 1 ; int n2 = r - m ; int L [ n1 ], R [ n2 ]; for ( int i = 0 ; i < n1 ; i ++ ) L [ i ] = a [ l + i ]; for ( int j = 0 ; j < n2 ; j ++ ) R [ j ] = a [ m + 1 + j ]; int i = 0 , j = 0 , k = l ; // Initial index of left array, right array, merged array. while ( i < n1 && j < n2 ) if ( L [ i ] <= R [ j ]) a [ k ++ ] = L [ i ++ ]; else a [ k ++ ] = R [ j ++ ]; while ( i < n1 ) a [ k ++ ] = L [ i ++ ]; while ( j < n2 ) a [ k ++ ] = R [ j ++ ]; } void merge_sort ( int * a , int l , int r ) { // Sort array a[l...r]. if ( l >= r ) return ; int m = ( l + r ) >> 1 ; merge_sort ( a , l , m ); merge_sort ( a , m + 1 , r ); merge ( a , l , m , r ); } \u7b97\u6cd5 \u5206\u6cbb\u6cd5\uff0c\u540e\u5e8f\u9012\u5f52\u3002 \u5c06\u6570\u7ec4\u6298\u534a\u5206\u6210\u5de6\u3001\u53f3\u4e24\u90e8\u5206\uff0c\u5206\u522b\u6392\u5e8f\uff0c\u518d\u5bf9\u6709\u5e8f\u7684\u5de6\u3001\u53f3\u4e24\u90e8\u5206\u6267\u884c\u5408\u5e76\u64cd\u4f5c\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 O(n\\log{n}) O(n\\log{n}) \u3002","title":"\u5f52\u5e76\u6392\u5e8f"},{"location":"competitive_programming/basic/merge_sort/#_1","text":"","title":"\u5f52\u5e76\u6392\u5e8f"},{"location":"competitive_programming/basic/merge_sort/#_2","text":"void merge ( int * a , int l , int m , int r ) { // Merge two sub-arraies a[l...m] & a[m + 1...r] into a[l...r]. int n1 = m - l + 1 ; int n2 = r - m ; int L [ n1 ], R [ n2 ]; for ( int i = 0 ; i < n1 ; i ++ ) L [ i ] = a [ l + i ]; for ( int j = 0 ; j < n2 ; j ++ ) R [ j ] = a [ m + 1 + j ]; int i = 0 , j = 0 , k = l ; // Initial index of left array, right array, merged array. while ( i < n1 && j < n2 ) if ( L [ i ] <= R [ j ]) a [ k ++ ] = L [ i ++ ]; else a [ k ++ ] = R [ j ++ ]; while ( i < n1 ) a [ k ++ ] = L [ i ++ ]; while ( j < n2 ) a [ k ++ ] = R [ j ++ ]; } void merge_sort ( int * a , int l , int r ) { // Sort array a[l...r]. if ( l >= r ) return ; int m = ( l + r ) >> 1 ; merge_sort ( a , l , m ); merge_sort ( a , m + 1 , r ); merge ( a , l , m , r ); }","title":"\u4ee3\u7801"},{"location":"competitive_programming/basic/merge_sort/#_3","text":"\u5206\u6cbb\u6cd5\uff0c\u540e\u5e8f\u9012\u5f52\u3002 \u5c06\u6570\u7ec4\u6298\u534a\u5206\u6210\u5de6\u3001\u53f3\u4e24\u90e8\u5206\uff0c\u5206\u522b\u6392\u5e8f\uff0c\u518d\u5bf9\u6709\u5e8f\u7684\u5de6\u3001\u53f3\u4e24\u90e8\u5206\u6267\u884c\u5408\u5e76\u64cd\u4f5c\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 O(n\\log{n}) O(n\\log{n}) \u3002","title":"\u7b97\u6cd5"},{"location":"competitive_programming/basic/quick_sort/","text":"\u5feb\u901f\u6392\u5e8f \u4ee3\u7801 void quick ( int * a , int l , int r ) { // Sort a[l...r]. if ( l >= r ) return ; int i = l + 1 , j = r ; while ( 1 ) { // while ( ! ( a [ l ] < a [ i ] || i == r )) i ++ ; while ( ! ( a [ l ] >= a [ j ] || j == l )) j -- ; if ( i < j ) { int tmp = a [ i ]; a [ i ] = a [ j ], a [ j ] = tmp ; } else break ; } int tmp = a [ l ]; a [ l ] = a [ j ], a [ j ] = tmp ; quick ( a , l , j - 1 ); quick ( a , j + 1 , r ); } \u7b97\u6cd5 \u5206\u6cbb\u6cd5\uff0c\u5148\u5e8f\u9012\u5f52\u3002 \u5c06\u5e8f\u5217\u4e2d\u7684\u5143\u7d20\u6309\u9996\u5143\u5927\u5c0f\u5206\u8fb9\uff0c\u518d\u5bf9\u4e24\u8fb9\u5206\u522b\u9012\u5f52\u5904\u7406\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 O(n\\log{n}) O(n\\log{n}) \u3002 \u5b9e\u73b0 \u4e0a\u8ff0\u201c\u5206\u8fb9\u201d\u64cd\u4f5c \u51fa\u81ea\u5510\u53d1\u6839\u8001\u5e08\u7684\u300a\u6570\u636e\u7ed3\u6784\u300b\u6559\u6750\uff0c\u7528\u4e24\u4e2a\u6307\u9488\u4ece\u5e8f\u5217\u4e24\u7aef\u5047\u5e01\u5c06\u6574\u4e2a\u5e8f\u5217\u6309\u76f8\u5bf9\u7b2c\u4e00\u4e2a\u5143\u7d20\u7684\u5927\u5c0f\u5206\u7c7b\u3002","title":"\u5feb\u901f\u6392\u5e8f"},{"location":"competitive_programming/basic/quick_sort/#_1","text":"","title":"\u5feb\u901f\u6392\u5e8f"},{"location":"competitive_programming/basic/quick_sort/#_2","text":"void quick ( int * a , int l , int r ) { // Sort a[l...r]. if ( l >= r ) return ; int i = l + 1 , j = r ; while ( 1 ) { // while ( ! ( a [ l ] < a [ i ] || i == r )) i ++ ; while ( ! ( a [ l ] >= a [ j ] || j == l )) j -- ; if ( i < j ) { int tmp = a [ i ]; a [ i ] = a [ j ], a [ j ] = tmp ; } else break ; } int tmp = a [ l ]; a [ l ] = a [ j ], a [ j ] = tmp ; quick ( a , l , j - 1 ); quick ( a , j + 1 , r ); }","title":"\u4ee3\u7801"},{"location":"competitive_programming/basic/quick_sort/#_3","text":"\u5206\u6cbb\u6cd5\uff0c\u5148\u5e8f\u9012\u5f52\u3002 \u5c06\u5e8f\u5217\u4e2d\u7684\u5143\u7d20\u6309\u9996\u5143\u5927\u5c0f\u5206\u8fb9\uff0c\u518d\u5bf9\u4e24\u8fb9\u5206\u522b\u9012\u5f52\u5904\u7406\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 O(n\\log{n}) O(n\\log{n}) \u3002","title":"\u7b97\u6cd5"},{"location":"competitive_programming/basic/quick_sort/#_4","text":"\u4e0a\u8ff0\u201c\u5206\u8fb9\u201d\u64cd\u4f5c \u51fa\u81ea\u5510\u53d1\u6839\u8001\u5e08\u7684\u300a\u6570\u636e\u7ed3\u6784\u300b\u6559\u6750\uff0c\u7528\u4e24\u4e2a\u6307\u9488\u4ece\u5e8f\u5217\u4e24\u7aef\u5047\u5e01\u5c06\u6574\u4e2a\u5e8f\u5217\u6309\u76f8\u5bf9\u7b2c\u4e00\u4e2a\u5143\u7d20\u7684\u5927\u5c0f\u5206\u7c7b\u3002","title":"\u5b9e\u73b0"},{"location":"competitive_programming/basic/ternary_search/","text":"\u4e09\u5206\u641c\u7d22 \u95ee\u9898 \u5df2\u77e5\u51fd\u6570 f(x) f(x) \u5728\u533a\u95f4 [l, r] [l, r] \u4e0a\u5355\u5cf0\u4e14\u8fde\u7eed\uff0c\u6c42 f(x) f(x) \u5728 [l, r] [l, r] \u4e0a\u7684\u6781\u503c\u3002 \u7b97\u6cd5 \u4f7f\u7528\u6807\u51c6\u4e09\u5206\u641c\u7d22\u7b97\u6cd5\uff0c\u6bcf\u6b21\u8fed\u4ee3\u5c06\u5f53\u524d\u533a\u95f4\u7684\u957f\u5ea6\u7f29\u5c0f \\frac{1}{3} \\frac{1}{3} \u3002 \u7406\u8bba\u4e0a\u6700\u7ec8\u6536\u655b\u5230\u6781\u503c\u70b9\u6216\u6781\u503c\u533a\u95f4\u7684\u5de6\u7aef\uff0c\u4f46\u5b9e\u9645\u4e2d\u7531\u4e8e\u590d\u70b9\u8bef\u5dee\u5bfc\u81f4\u7684\u5224\u7b49\u9519\u8bef\uff0c\u5f53 f(x) f(x) \u5728\u533a\u95f4 [l_m, r_m] [l_m, r_m] \u4e0a\u53d6\u6781\u503c\u65f6\uff0c\u6700\u7ec8\u5b9a\u4f4d\u5f80\u5f80\u5728\u7ebf\u6bb5\u5185\u7684\u968f\u673a\u70b9\uff0c\u4f46\u8fd4\u56de\u7684\u51fd\u6570\u503c\u4ecd\u53ef\u89c6\u4e3a f(x) f(x) \u5728 [l, r] [l, r] \u4e0a\u7684\u6781\u503c\u3002 \u4ee3\u7801 \u5728 [-1000, 1000] [-1000, 1000] \u8303\u56f4\u5185\u641c\u7d22\u5355\u5cf0\u8fde\u7eed\u51fd\u6570 f(x) f(x) \u6781\u5c0f\u503c double ternary_search () { double l = - 1000 , r = 1000 ; for ( int i = 0 ; i < 300 ; i ++ ) { double m1 = ( 2 * l + r ) / 3 ; double m2 = ( l + 2 * r ) / 3 ; if ( f ( m1 ) >= f ( m2 )) l = m1 ; else r = m2 ; } return f ( l ); } \u6ce8\uff1a \u8fed\u4ee3 100 100 \u6b21\u540e\u533a\u95f4\u957f\u5ea6\u4e3a\u5148\u524d\u7684 2.4597 \\times 10^{-18} 2.4597 \\times 10^{-18} \uff0c\u8fed\u4ee3 1000 1000 \u6b21\u4e4b\u540e\u533a\u95f4\u957f\u5ea6\u4e3a\u7f29\u51cf\u5230\u539f\u6765\u7684 1.4881 \\times 10^{-53} 1.4881 \\times 10^{-53} \uff0c\u6545\u4e00\u822c\u6570\u767e\u6b21\u7684\u8fed\u4ee3\u80fd\u591f\u6ee1\u8db3\u7b97\u6cd5\u7ade\u8d5b\u4e2d\u7684\u7cbe\u5ea6\u8981\u6c42\u3002 \u53d8\u4f53 - \u5e73\u9762\u4e09\u5206\u641c\u7d22 \u5f53\u9700\u8981\u6c42\u89e3\u7684\u5355\u5cf0\u8fde\u7eed\u4e8c\u5143\u51fd\u6570 f_{x, y}(x, y) f_{x, y}(x, y) \u5728\u77e9\u5f62\u533a\u57df x \\in [l_x, r_x], y \\in [l_y, r_y] x \\in [l_x, r_x], y \\in [l_y, r_y] \u4e0a\u7684\u6781\u503c\u65f6\uff0c\u53ef\u4f7f\u7528\u5e73\u9762\u4e09\u5206\u641c\u7d22\u7b97\u6cd5\u3002\u5177\u4f53\u5730\uff0c\u5206\u4e24\u5c42\u8c03\u7528\u4e00\u7ef4\u4e09\u5206\u641c\u7d22\u7b97\u6cd5\u3002 \u4ece\u51e0\u4f55\u610f\u4e49\u6765\u770b\uff0c\u5e73\u9762\u4e09\u5206\u641c\u7d22\u9996\u5148\u5229\u7528\u4e00\u7ef4\u4e09\u5206\u641c\u7d22\u6c42\u89e3\u7ed9\u5b9a x x \u65f6\u51fd\u6570\u5728 y y \u65b9\u5411\u4e0a\u7684\u6781\u503c f_x(x) = \\max_{y \\in [l_y, r_y]}f(x, y) f_x(x) = \\max_{y \\in [l_y, r_y]}f(x, y) \uff0c\u7136\u540e\u5229\u7528\u4e09\u5206\u641c\u7d22\u6c42\u89e3 f_x(x) f_x(x) \u5728 x x \u65b9\u5411\u4e0a\u7684\u6781\u503c\u3002 \u4ee3\u7801 \u5728 [-1000, 1000] \\times [-1000, 1000] [-1000, 1000] \\times [-1000, 1000] \u4e0a\u641c\u7d22\u5355\u5cf0\u51fd\u6570 f(x) f(x) \u7684\u6781\u5c0f\u503c double t_search_y ( double x ) { double l = - 1000 , r = 1000 ; for ( int i = 0 ; i < 300 ; i ++ ) { double m1 = ( 2 * l + r ) / 3 ; double m2 = ( l + 2 * r ) / 3 ; if ( f ( x , m1 ) >= f ( x , m2 )) l = m1 ; else r = m2 ; } return f ( x , l ); } double t_search_x () { double l = - 1000 , r = 1000 ; for ( int i = 0 ; i < 300 ; i ++ ) { double m1 = ( 2 * l + r ) / 3 ; double m2 = ( l + 2 * r ) / 3 ; if ( t_search_y ( m1 ) >= t_search_y ( m2 )) l = m1 ; else r = m2 ; } return t_search_y ( l ); } \u6a21\u677f\u5c01\u88c5 \u4e00\u7ef4\u4e09\u5206\u641c\u7d22 class TernarySearch { public : TernarySearch ( function < double ( double ) > _f ) : f ( _f ) { l = - 1000 , r = 1000 ; } double MaxValue () { for ( int i = 0 ; i < iter_num ; i ++ ) { double m1 = ( 2 * l + r ) / 3 ; double m2 = ( l + 2 * r ) / 3 ; if ( f ( m1 ) >= f ( m2 )) l = m1 ; else r = m2 ; } return f ( l ); } private : int iter_num = 300 ; double l , r ; function < double ( double ) > f ; }; \u5e73\u9762\u4e09\u5206\u641c\u7d22 class TernarySearch2D { public : TernarySearch2D ( function < double ( double , double ) > _f ) : f ( _f ) { lx = - 1000 , rx = 1000 , ly = - 1000 , ry = - 1000 ; } double MaxValue () { double l = lx , r = rx ; for ( int i = 0 ; i < iter_num ; i ++ ) { double m1 = ( 2 * l + r ) / 3 ; double m2 = ( l + 2 * r ) / 3 ; if ( MaxValueY ( m1 ) >= MaxValueY ( m2 )) l = m1 ; else r = m2 ; } return MaxValueY ( l ); } private : double MaxValueY ( double x ) { double l = ly , r = ry ; for ( int i = 0 ; i < iter_num ; i ++ ) { double m1 = ( 2 * l + r ) / 3 ; double m2 = ( l + 2 * r ) / 3 ; if ( f ( x , m1 ) >= f ( x , m2 )) l = m1 ; else r = m2 ; } return f ( x , l ); } int iter_num = 300 ; double lx , rx , ly , ry ; function < double ( double , double ) > f ; };","title":"\u4e09\u5206\u641c\u7d22"},{"location":"competitive_programming/basic/ternary_search/#_1","text":"","title":"\u4e09\u5206\u641c\u7d22"},{"location":"competitive_programming/basic/ternary_search/#_2","text":"\u5df2\u77e5\u51fd\u6570 f(x) f(x) \u5728\u533a\u95f4 [l, r] [l, r] \u4e0a\u5355\u5cf0\u4e14\u8fde\u7eed\uff0c\u6c42 f(x) f(x) \u5728 [l, r] [l, r] \u4e0a\u7684\u6781\u503c\u3002","title":"\u95ee\u9898"},{"location":"competitive_programming/basic/ternary_search/#_3","text":"\u4f7f\u7528\u6807\u51c6\u4e09\u5206\u641c\u7d22\u7b97\u6cd5\uff0c\u6bcf\u6b21\u8fed\u4ee3\u5c06\u5f53\u524d\u533a\u95f4\u7684\u957f\u5ea6\u7f29\u5c0f \\frac{1}{3} \\frac{1}{3} \u3002 \u7406\u8bba\u4e0a\u6700\u7ec8\u6536\u655b\u5230\u6781\u503c\u70b9\u6216\u6781\u503c\u533a\u95f4\u7684\u5de6\u7aef\uff0c\u4f46\u5b9e\u9645\u4e2d\u7531\u4e8e\u590d\u70b9\u8bef\u5dee\u5bfc\u81f4\u7684\u5224\u7b49\u9519\u8bef\uff0c\u5f53 f(x) f(x) \u5728\u533a\u95f4 [l_m, r_m] [l_m, r_m] \u4e0a\u53d6\u6781\u503c\u65f6\uff0c\u6700\u7ec8\u5b9a\u4f4d\u5f80\u5f80\u5728\u7ebf\u6bb5\u5185\u7684\u968f\u673a\u70b9\uff0c\u4f46\u8fd4\u56de\u7684\u51fd\u6570\u503c\u4ecd\u53ef\u89c6\u4e3a f(x) f(x) \u5728 [l, r] [l, r] \u4e0a\u7684\u6781\u503c\u3002","title":"\u7b97\u6cd5"},{"location":"competitive_programming/basic/ternary_search/#_4","text":"\u5728 [-1000, 1000] [-1000, 1000] \u8303\u56f4\u5185\u641c\u7d22\u5355\u5cf0\u8fde\u7eed\u51fd\u6570 f(x) f(x) \u6781\u5c0f\u503c double ternary_search () { double l = - 1000 , r = 1000 ; for ( int i = 0 ; i < 300 ; i ++ ) { double m1 = ( 2 * l + r ) / 3 ; double m2 = ( l + 2 * r ) / 3 ; if ( f ( m1 ) >= f ( m2 )) l = m1 ; else r = m2 ; } return f ( l ); } \u6ce8\uff1a \u8fed\u4ee3 100 100 \u6b21\u540e\u533a\u95f4\u957f\u5ea6\u4e3a\u5148\u524d\u7684 2.4597 \\times 10^{-18} 2.4597 \\times 10^{-18} \uff0c\u8fed\u4ee3 1000 1000 \u6b21\u4e4b\u540e\u533a\u95f4\u957f\u5ea6\u4e3a\u7f29\u51cf\u5230\u539f\u6765\u7684 1.4881 \\times 10^{-53} 1.4881 \\times 10^{-53} \uff0c\u6545\u4e00\u822c\u6570\u767e\u6b21\u7684\u8fed\u4ee3\u80fd\u591f\u6ee1\u8db3\u7b97\u6cd5\u7ade\u8d5b\u4e2d\u7684\u7cbe\u5ea6\u8981\u6c42\u3002","title":"\u4ee3\u7801"},{"location":"competitive_programming/basic/ternary_search/#-","text":"\u5f53\u9700\u8981\u6c42\u89e3\u7684\u5355\u5cf0\u8fde\u7eed\u4e8c\u5143\u51fd\u6570 f_{x, y}(x, y) f_{x, y}(x, y) \u5728\u77e9\u5f62\u533a\u57df x \\in [l_x, r_x], y \\in [l_y, r_y] x \\in [l_x, r_x], y \\in [l_y, r_y] \u4e0a\u7684\u6781\u503c\u65f6\uff0c\u53ef\u4f7f\u7528\u5e73\u9762\u4e09\u5206\u641c\u7d22\u7b97\u6cd5\u3002\u5177\u4f53\u5730\uff0c\u5206\u4e24\u5c42\u8c03\u7528\u4e00\u7ef4\u4e09\u5206\u641c\u7d22\u7b97\u6cd5\u3002 \u4ece\u51e0\u4f55\u610f\u4e49\u6765\u770b\uff0c\u5e73\u9762\u4e09\u5206\u641c\u7d22\u9996\u5148\u5229\u7528\u4e00\u7ef4\u4e09\u5206\u641c\u7d22\u6c42\u89e3\u7ed9\u5b9a x x \u65f6\u51fd\u6570\u5728 y y \u65b9\u5411\u4e0a\u7684\u6781\u503c f_x(x) = \\max_{y \\in [l_y, r_y]}f(x, y) f_x(x) = \\max_{y \\in [l_y, r_y]}f(x, y) \uff0c\u7136\u540e\u5229\u7528\u4e09\u5206\u641c\u7d22\u6c42\u89e3 f_x(x) f_x(x) \u5728 x x \u65b9\u5411\u4e0a\u7684\u6781\u503c\u3002","title":"\u53d8\u4f53 - \u5e73\u9762\u4e09\u5206\u641c\u7d22"},{"location":"competitive_programming/basic/ternary_search/#_5","text":"\u5728 [-1000, 1000] \\times [-1000, 1000] [-1000, 1000] \\times [-1000, 1000] \u4e0a\u641c\u7d22\u5355\u5cf0\u51fd\u6570 f(x) f(x) \u7684\u6781\u5c0f\u503c double t_search_y ( double x ) { double l = - 1000 , r = 1000 ; for ( int i = 0 ; i < 300 ; i ++ ) { double m1 = ( 2 * l + r ) / 3 ; double m2 = ( l + 2 * r ) / 3 ; if ( f ( x , m1 ) >= f ( x , m2 )) l = m1 ; else r = m2 ; } return f ( x , l ); } double t_search_x () { double l = - 1000 , r = 1000 ; for ( int i = 0 ; i < 300 ; i ++ ) { double m1 = ( 2 * l + r ) / 3 ; double m2 = ( l + 2 * r ) / 3 ; if ( t_search_y ( m1 ) >= t_search_y ( m2 )) l = m1 ; else r = m2 ; } return t_search_y ( l ); }","title":"\u4ee3\u7801"},{"location":"competitive_programming/basic/ternary_search/#_6","text":"","title":"\u6a21\u677f\u5c01\u88c5"},{"location":"competitive_programming/basic/ternary_search/#_7","text":"class TernarySearch { public : TernarySearch ( function < double ( double ) > _f ) : f ( _f ) { l = - 1000 , r = 1000 ; } double MaxValue () { for ( int i = 0 ; i < iter_num ; i ++ ) { double m1 = ( 2 * l + r ) / 3 ; double m2 = ( l + 2 * r ) / 3 ; if ( f ( m1 ) >= f ( m2 )) l = m1 ; else r = m2 ; } return f ( l ); } private : int iter_num = 300 ; double l , r ; function < double ( double ) > f ; };","title":"\u4e00\u7ef4\u4e09\u5206\u641c\u7d22"},{"location":"competitive_programming/basic/ternary_search/#_8","text":"class TernarySearch2D { public : TernarySearch2D ( function < double ( double , double ) > _f ) : f ( _f ) { lx = - 1000 , rx = 1000 , ly = - 1000 , ry = - 1000 ; } double MaxValue () { double l = lx , r = rx ; for ( int i = 0 ; i < iter_num ; i ++ ) { double m1 = ( 2 * l + r ) / 3 ; double m2 = ( l + 2 * r ) / 3 ; if ( MaxValueY ( m1 ) >= MaxValueY ( m2 )) l = m1 ; else r = m2 ; } return MaxValueY ( l ); } private : double MaxValueY ( double x ) { double l = ly , r = ry ; for ( int i = 0 ; i < iter_num ; i ++ ) { double m1 = ( 2 * l + r ) / 3 ; double m2 = ( l + 2 * r ) / 3 ; if ( f ( x , m1 ) >= f ( x , m2 )) l = m1 ; else r = m2 ; } return f ( x , l ); } int iter_num = 300 ; double lx , rx , ly , ry ; function < double ( double , double ) > f ; };","title":"\u5e73\u9762\u4e09\u5206\u641c\u7d22"},{"location":"competitive_programming/data_structure/fenwick/","text":"Fenwick/\u6811\u72b6\u6570\u7ec4 Fenwick\u6811\uff0c\u4e5f\u53ebbinary index tree\uff0c\u6216\u6811\u72b6\u6570\u7ec4\uff0c\u652f\u6301\u5728 O(\\log n) O(\\log n) \u65f6\u95f4\u5185\u66f4\u65b0\u5143\u7d20\u503c\u548c\u8ba1\u7b97\u524d\u7f00\u548c\u64cd\u4f5c \u95ee\u9898 \u7ed9\u5b9a\u957f\u5ea6\u4e3a n n \u7684\u5e8f\u5217 v v \uff0c\u8981\u6c42\u5728 O(\\log n) O(\\log n) \u7684\u65f6\u95f4\u5185\u5b8c\u6210\u5982\u4e0b\u64cd\u4f5c\uff1a \u66f4\u65b0\u5355\u4e2a\u5143\u7d20 v[i] v[i] \u7684\u503c \u67e5\u8be2\u4f4d\u4e8e\u533a\u95f4 [l, r) [l, r) \u7684\u5143\u7d20\u548c \u4ee3\u7801 template < typename T > class BIT { public : BIT () {} BIT ( int _sz ) : sz ( _sz ) { bit = vector < T > ( sz + 1 , 0 ); } BIT ( vector < T > arr ) : sz (( int ) arr . size ()) { bit = vector < T > ( sz + 1 , 0 ); for ( int i = 0 ; i < sz ; i ++ ) this -> Add ( i , arr [ i ]); } void Add ( int x , T val ) { for ( x ++ ; x <= sz ; x += x & - x ) bit [ x ] += val ; } T Query ( int x ) { // Sum [0, x] T ans = 0 ; for ( x ++ ; x ; x -= x & - x ) ans += bit [ x ]; return ans ; } T Query ( int l , int r ) { // Sum [l, r) return Query ( r - 1 ) - Query ( l - 1 ); } private : int sz ; vector < T > bit ; }; \u7b97\u6cd5 \u6811\u4e2d\u8282\u70b9\u7f16\u53f7 i i \u4ee3\u8868\u524di\u4e2a\u5143\u7d20\u3002\u6bcf\u4e2a\u8282\u70b9\u5b58\u50a8\u7684\u662f\u76f8\u6bd4\u7236\u8282\u70b9\u591a\u51fa\u6765\u7684\u90a3\u4e00\u90e8\u5206\u5143\u7d20\u548c\u3002\u987e\u5bf9\u4e8e\u4efb\u610f\u8282\u70b9\uff0c\u5176\u56de\u6eaf\u5230\u6839\u8282\u70b9\u7684\u8def\u5f84\u4e0a\u7684\u5143\u7d20\u4e4b\u548c\u5c31\u662f\u539f\u6570\u7ec4\u7684\u524d\u7f00\u548c\u3002 \u6ce8\uff1a\u82e5 x x \u4e3a\u6b63\uff0c\u5219 x \\& -x x \\& -x \u4e3a x x \u4f4e\u4f4d 1 1 \u6240\u4ee3\u8868\u7684\u6570\u3002 \u8ba8\u8bba \u4e0e\u7ebf\u6bb5\u6811\u7684\u533a\u522b \u5bf9\u4e8e\u6811\u72b6\u6570\u7ec4\u548c\u7ebf\u6bb5\u6811\u7684\u533a\u522b\uff0c\u4ece\u6811\u72b6\u6570\u7ec4\u7d22\u5f15\u66f4\u65b0\u7684\u65b9\u5f0f\u53ef\u89c1\u7aef\u502a\uff1a BIT\u7684\u7d22\u5f15\u66f4\u65b0\u65b9\u5f0f\u4e3a\u51cf\u53bb\u6216\u52a0\u4e0a\u6700\u4f4e\u4f4d 1 1 \uff0c\u7ebf\u6bb5\u6811\u7684\u7d22\u5f15\u66f4\u65b0\u65b9\u5f0f\u4e3a\u5de6\u79fb\u6216\u53f3\u79fb 1 1 \u4f4d\u3002\u8fd9\u5bfc\u81f4\u6811\u72b6\u6570\u7ec4\u7684\u7236\u5b50\u8282\u70b9\u6240\u8868\u5f81\u7684\u533a\u95f4\u6ca1\u6709\u4ea4\u96c6\uff0c\u4e00\u679d\u4e2d\u7684\u6240\u6709\u8282\u70b9\u4e00\u8d77\u6784\u6210\u4e00\u4e2a\u7d22\u5f15\u6240\u51b3\u5b9a\u524d\u7f00\u7684\u5185\u5bb9\uff1b\u800c\u7ebf\u6bb5\u6811\u7684\u7236\u5b50\u8282\u70b9\u4e4b\u95f4\u662f\u6709\u91cd\u5408\u7684\uff0c\u751a\u81f3\u7236\u8282\u70b9 p p \u5b58\u50a8\u7684\u503c\u5c31\u662f\u7531\u4e24\u4e2a\u513f\u5b50\u8282\u70b9\uff08 p << 1 p << 1 \u548c p << 1 | 1 p << 1 | 1 \uff09\u76f4\u63a5\u51b3\u5b9a\u7684\u3002\u8fd9\u4e5f\u89e3\u91ca\u4e86\u4e3a\u4ec0\u4e48\u6811\u72b6\u6570\u7ec4\u4e0d\u652f\u6301\u7ef4\u62a4\u533a\u95f4\u6700\u503c\uff0c\u800c\u7ebf\u6bb5\u6811\u5374\u652f\u6301\uff0c\u56e0\u4e3a\u7ebf\u6bb5\u6811\u4e3a\u6b64\u989d\u5916\u4ed8\u51fa\u4e86 O(n) O(n) \u7684\u7a7a\u95f4\u590d\u6742\u5ea6\u3002 \u6ce8\uff1a\u6811\u72b6\u6570\u7ec4\u7684\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3a O(n) O(n) \uff0c\u7ebf\u6bb5\u6811\u7684\u7a7a\u95f4\u590d\u6742\u5ea6 O(2n) O(2n) \u3002","title":"\u6811\u72b6\u6570\u7ec4"},{"location":"competitive_programming/data_structure/fenwick/#fenwick","text":"Fenwick\u6811\uff0c\u4e5f\u53ebbinary index tree\uff0c\u6216\u6811\u72b6\u6570\u7ec4\uff0c\u652f\u6301\u5728 O(\\log n) O(\\log n) \u65f6\u95f4\u5185\u66f4\u65b0\u5143\u7d20\u503c\u548c\u8ba1\u7b97\u524d\u7f00\u548c\u64cd\u4f5c","title":"Fenwick/\u6811\u72b6\u6570\u7ec4"},{"location":"competitive_programming/data_structure/fenwick/#_1","text":"\u7ed9\u5b9a\u957f\u5ea6\u4e3a n n \u7684\u5e8f\u5217 v v \uff0c\u8981\u6c42\u5728 O(\\log n) O(\\log n) \u7684\u65f6\u95f4\u5185\u5b8c\u6210\u5982\u4e0b\u64cd\u4f5c\uff1a \u66f4\u65b0\u5355\u4e2a\u5143\u7d20 v[i] v[i] \u7684\u503c \u67e5\u8be2\u4f4d\u4e8e\u533a\u95f4 [l, r) [l, r) \u7684\u5143\u7d20\u548c","title":"\u95ee\u9898"},{"location":"competitive_programming/data_structure/fenwick/#_2","text":"template < typename T > class BIT { public : BIT () {} BIT ( int _sz ) : sz ( _sz ) { bit = vector < T > ( sz + 1 , 0 ); } BIT ( vector < T > arr ) : sz (( int ) arr . size ()) { bit = vector < T > ( sz + 1 , 0 ); for ( int i = 0 ; i < sz ; i ++ ) this -> Add ( i , arr [ i ]); } void Add ( int x , T val ) { for ( x ++ ; x <= sz ; x += x & - x ) bit [ x ] += val ; } T Query ( int x ) { // Sum [0, x] T ans = 0 ; for ( x ++ ; x ; x -= x & - x ) ans += bit [ x ]; return ans ; } T Query ( int l , int r ) { // Sum [l, r) return Query ( r - 1 ) - Query ( l - 1 ); } private : int sz ; vector < T > bit ; };","title":"\u4ee3\u7801"},{"location":"competitive_programming/data_structure/fenwick/#_3","text":"\u6811\u4e2d\u8282\u70b9\u7f16\u53f7 i i \u4ee3\u8868\u524di\u4e2a\u5143\u7d20\u3002\u6bcf\u4e2a\u8282\u70b9\u5b58\u50a8\u7684\u662f\u76f8\u6bd4\u7236\u8282\u70b9\u591a\u51fa\u6765\u7684\u90a3\u4e00\u90e8\u5206\u5143\u7d20\u548c\u3002\u987e\u5bf9\u4e8e\u4efb\u610f\u8282\u70b9\uff0c\u5176\u56de\u6eaf\u5230\u6839\u8282\u70b9\u7684\u8def\u5f84\u4e0a\u7684\u5143\u7d20\u4e4b\u548c\u5c31\u662f\u539f\u6570\u7ec4\u7684\u524d\u7f00\u548c\u3002 \u6ce8\uff1a\u82e5 x x \u4e3a\u6b63\uff0c\u5219 x \\& -x x \\& -x \u4e3a x x \u4f4e\u4f4d 1 1 \u6240\u4ee3\u8868\u7684\u6570\u3002","title":"\u7b97\u6cd5"},{"location":"competitive_programming/data_structure/fenwick/#_4","text":"\u4e0e\u7ebf\u6bb5\u6811\u7684\u533a\u522b \u5bf9\u4e8e\u6811\u72b6\u6570\u7ec4\u548c\u7ebf\u6bb5\u6811\u7684\u533a\u522b\uff0c\u4ece\u6811\u72b6\u6570\u7ec4\u7d22\u5f15\u66f4\u65b0\u7684\u65b9\u5f0f\u53ef\u89c1\u7aef\u502a\uff1a BIT\u7684\u7d22\u5f15\u66f4\u65b0\u65b9\u5f0f\u4e3a\u51cf\u53bb\u6216\u52a0\u4e0a\u6700\u4f4e\u4f4d 1 1 \uff0c\u7ebf\u6bb5\u6811\u7684\u7d22\u5f15\u66f4\u65b0\u65b9\u5f0f\u4e3a\u5de6\u79fb\u6216\u53f3\u79fb 1 1 \u4f4d\u3002\u8fd9\u5bfc\u81f4\u6811\u72b6\u6570\u7ec4\u7684\u7236\u5b50\u8282\u70b9\u6240\u8868\u5f81\u7684\u533a\u95f4\u6ca1\u6709\u4ea4\u96c6\uff0c\u4e00\u679d\u4e2d\u7684\u6240\u6709\u8282\u70b9\u4e00\u8d77\u6784\u6210\u4e00\u4e2a\u7d22\u5f15\u6240\u51b3\u5b9a\u524d\u7f00\u7684\u5185\u5bb9\uff1b\u800c\u7ebf\u6bb5\u6811\u7684\u7236\u5b50\u8282\u70b9\u4e4b\u95f4\u662f\u6709\u91cd\u5408\u7684\uff0c\u751a\u81f3\u7236\u8282\u70b9 p p \u5b58\u50a8\u7684\u503c\u5c31\u662f\u7531\u4e24\u4e2a\u513f\u5b50\u8282\u70b9\uff08 p << 1 p << 1 \u548c p << 1 | 1 p << 1 | 1 \uff09\u76f4\u63a5\u51b3\u5b9a\u7684\u3002\u8fd9\u4e5f\u89e3\u91ca\u4e86\u4e3a\u4ec0\u4e48\u6811\u72b6\u6570\u7ec4\u4e0d\u652f\u6301\u7ef4\u62a4\u533a\u95f4\u6700\u503c\uff0c\u800c\u7ebf\u6bb5\u6811\u5374\u652f\u6301\uff0c\u56e0\u4e3a\u7ebf\u6bb5\u6811\u4e3a\u6b64\u989d\u5916\u4ed8\u51fa\u4e86 O(n) O(n) \u7684\u7a7a\u95f4\u590d\u6742\u5ea6\u3002 \u6ce8\uff1a\u6811\u72b6\u6570\u7ec4\u7684\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3a O(n) O(n) \uff0c\u7ebf\u6bb5\u6811\u7684\u7a7a\u95f4\u590d\u6742\u5ea6 O(2n) O(2n) \u3002","title":"\u8ba8\u8bba"},{"location":"competitive_programming/data_structure/lru_cache/","text":"LRU\u7f13\u5b58 \u95ee\u9898 \u8bbe\u8ba1\u4e00\u79cd\u952e\u3001\u503c\u5bf9\u7684\u5bb9\u5668\u6570\u636e\u7ed3\u6784\uff0c\u652f\u6301 get get \u548c set set \u64cd\u4f5c\uff1a get(key) get(key) - \u5982\u679c\u7f13\u5b58\u4e2d\u5b58\u5728 key key \uff0c\u5219\u8fd4\u56de\u5176\u5bf9\u5e94\u503c\uff0c\u5426\u5219\u8fd4\u56de -1 -1 set(key, value) set(key, value) - \u5982\u679c key key \u5df2\u5b58\u5728\u5219\u66f4\u65b0\u5176\u5bf9\u5e94\u7684\u503c\uff0c\u5426\u5219\u52a0\u5165\u65b0\u7684\u952e\u503c\u5bf9 (key, value) (key, value) \uff0c\u5982\u679c\u5bb9\u5668\u5df2\u8fbe\u5230\u6700\u5927\u5bb9\u91cf\u5219\u8e22\u51fa\u4e0a\u6b21\u8bbf\u95ee\u8ddd\u79bb\u6700\u8fdc\u7684\u952e\u503c\u5bf9 \u5206\u6790 \u7531\u4e8e\u9700\u8981\u523b\u753b\u8bbf\u95ee\u987a\u5e8f\uff0c\u5e76\u4e14\u9700\u8981\u5feb\u901f\u5c06\u5bb9\u5668\u4e2d\u67d0\u4e2a\u5143\u7d20\u79fb\u5230\u5934\u90e8\uff0c\u6545\u53ef\u4ee5\u4f7f\u7528\u952e\u3001\u503c\u5bf9\u7684\u53cc\u5411\u94fe\u8868 std::list \u6765\u5b9e\u73b0\u3002 \u8fdb\u4e00\u6b65\uff0c\u53ef\u4ee5\u4f7f\u7528\u4e00\u4e2a std::unordered_map \u6765\u7ef4\u62a4 key key \u5230\u94fe\u8868\u8282\u70b9\uff08\u952e\u503c\u5bf9\uff09\u7684\u8fed\u4ee3\u5668\u7684\u54c8\u5e0c\u3002 \u4ee3\u7801 class LRUcache { public : LRUcache ( int capacity ) { this -> capacity = capacity ; } int Get ( int key ) { if ( cache_map . find ( key ) == cache_map . end ()) return - 1 ; cache_list . splice ( cache_list . begin (), cache_list , cache_map [ key ]); cache_map [ key ] = cache_list . begin (); return cache_map [ key ] -> v ; } void Set ( int key , int value ) { if ( cache_map . find ( key ) == cache_map . end ()) { if ( cache_list . size () == capacity ) { cache_map . erase ( cache_list . back (). k ); cache_list . pop_back (); } cache_list . push_front ( CacheNode ( key , value )); cache_map [ key ] = cache_list . begin (); } else { cache_map [ key ] -> v = value ; cache_list . splice ( cache_list . begin (), cache_list , cache_map [ key ]); cache_map [ key ] = cache_list . begin (); } } private : struct CacheNode { int k , v ; CacheNode () {} CacheNode ( int _k , int _v ) : k ( _k ), v ( _v ) {} }; int capacity ; list < CacheNode > cache_list ; unordered_map < int , list < CacheNode >:: iterator > cache_map ; }; CacheNode CacheNode - \u952e\u503c\u5bf9\uff08\u94fe\u8868\u8282\u70b9\uff09 cache\\_list cache\\_list - \u5185\u90e8\u94fe\u8868 cache\\_map cache\\_map - \u4ece key key \u5230\u952e\u503c\u5bf9\u5730\u5740\u7684\u54c8\u5e0c","title":"LRU\u7f13\u5b58"},{"location":"competitive_programming/data_structure/lru_cache/#lru","text":"","title":"LRU\u7f13\u5b58"},{"location":"competitive_programming/data_structure/lru_cache/#_1","text":"\u8bbe\u8ba1\u4e00\u79cd\u952e\u3001\u503c\u5bf9\u7684\u5bb9\u5668\u6570\u636e\u7ed3\u6784\uff0c\u652f\u6301 get get \u548c set set \u64cd\u4f5c\uff1a get(key) get(key) - \u5982\u679c\u7f13\u5b58\u4e2d\u5b58\u5728 key key \uff0c\u5219\u8fd4\u56de\u5176\u5bf9\u5e94\u503c\uff0c\u5426\u5219\u8fd4\u56de -1 -1 set(key, value) set(key, value) - \u5982\u679c key key \u5df2\u5b58\u5728\u5219\u66f4\u65b0\u5176\u5bf9\u5e94\u7684\u503c\uff0c\u5426\u5219\u52a0\u5165\u65b0\u7684\u952e\u503c\u5bf9 (key, value) (key, value) \uff0c\u5982\u679c\u5bb9\u5668\u5df2\u8fbe\u5230\u6700\u5927\u5bb9\u91cf\u5219\u8e22\u51fa\u4e0a\u6b21\u8bbf\u95ee\u8ddd\u79bb\u6700\u8fdc\u7684\u952e\u503c\u5bf9","title":"\u95ee\u9898"},{"location":"competitive_programming/data_structure/lru_cache/#_2","text":"\u7531\u4e8e\u9700\u8981\u523b\u753b\u8bbf\u95ee\u987a\u5e8f\uff0c\u5e76\u4e14\u9700\u8981\u5feb\u901f\u5c06\u5bb9\u5668\u4e2d\u67d0\u4e2a\u5143\u7d20\u79fb\u5230\u5934\u90e8\uff0c\u6545\u53ef\u4ee5\u4f7f\u7528\u952e\u3001\u503c\u5bf9\u7684\u53cc\u5411\u94fe\u8868 std::list \u6765\u5b9e\u73b0\u3002 \u8fdb\u4e00\u6b65\uff0c\u53ef\u4ee5\u4f7f\u7528\u4e00\u4e2a std::unordered_map \u6765\u7ef4\u62a4 key key \u5230\u94fe\u8868\u8282\u70b9\uff08\u952e\u503c\u5bf9\uff09\u7684\u8fed\u4ee3\u5668\u7684\u54c8\u5e0c\u3002","title":"\u5206\u6790"},{"location":"competitive_programming/data_structure/lru_cache/#_3","text":"class LRUcache { public : LRUcache ( int capacity ) { this -> capacity = capacity ; } int Get ( int key ) { if ( cache_map . find ( key ) == cache_map . end ()) return - 1 ; cache_list . splice ( cache_list . begin (), cache_list , cache_map [ key ]); cache_map [ key ] = cache_list . begin (); return cache_map [ key ] -> v ; } void Set ( int key , int value ) { if ( cache_map . find ( key ) == cache_map . end ()) { if ( cache_list . size () == capacity ) { cache_map . erase ( cache_list . back (). k ); cache_list . pop_back (); } cache_list . push_front ( CacheNode ( key , value )); cache_map [ key ] = cache_list . begin (); } else { cache_map [ key ] -> v = value ; cache_list . splice ( cache_list . begin (), cache_list , cache_map [ key ]); cache_map [ key ] = cache_list . begin (); } } private : struct CacheNode { int k , v ; CacheNode () {} CacheNode ( int _k , int _v ) : k ( _k ), v ( _v ) {} }; int capacity ; list < CacheNode > cache_list ; unordered_map < int , list < CacheNode >:: iterator > cache_map ; }; CacheNode CacheNode - \u952e\u503c\u5bf9\uff08\u94fe\u8868\u8282\u70b9\uff09 cache\\_list cache\\_list - \u5185\u90e8\u94fe\u8868 cache\\_map cache\\_map - \u4ece key key \u5230\u952e\u503c\u5bf9\u5730\u5740\u7684\u54c8\u5e0c","title":"\u4ee3\u7801"},{"location":"competitive_programming/data_structure/segment_tree/","text":"\u7ebf\u6bb5\u6811 \u76f8\u8f83Fenwick\u6811\uff0c\u7ebf\u6bb5\u6811\u9664\u4e86\u652f\u6301\u5728 O(\\log n) O(\\log n) \u65f6\u95f4\u5185\u66f4\u65b0\u5236\u5b9a\u5143\u7d20\u548c\u8ba1\u7b97\u533a\u95f4\u548c\u4ee5\u5916\uff0c\u8fd8\u652f\u6301\u5728 O(\\log n) O(\\log n) \u65f6\u95f4\u5185\u8ba1\u7b97\u533a\u95f4\u6700\u503c\uff0c\u4f46\u4e3a\u6b64\u591a\u4ed8\u51fa\u4e86 O(n) O(n) \u7684\u7a7a\u95f4\u5f00\u9500\u3002 \u95ee\u9898 \u7ed9\u5b9a\u957f\u5ea6\u4e3a n n \u7684\u5e8f\u5217 v v \uff0c\u8981\u6c42\u5728 O(\\log n) O(\\log n) \u7684\u65f6\u95f4\u5185\u5b8c\u6210\u5982\u4e0b\u64cd\u4f5c\uff1a \u66f4\u65b0\u5355\u4e2a\u5143\u7d20 v[i] v[i] \u7684\u503c \u67e5\u8be2\u4f4d\u4e8e\u533a\u95f4 [l, r) [l, r) \u7684\u5143\u7d20\u548c \u4ee3\u7801 \u7528\u4e8e\u7ef4\u62a4\u533a\u95f4\u6c42\u548c\u7684\u7ebf\u6bb5\u6811\uff1a template < typename T > class SGT { public : SGT () {} SGT ( int _sz ) : sz ( _sz ) { sgt = vector < T > ( sz << 1 , 0 ); } SGT ( vector < T > arr ) : sz (( int ) arr . size ()) { sgt = vector < T > ( sz << 1 , 0 ); for ( int i = 0 ; i < sz ; i ++ ) this -> Add ( i , arr [ i ]); } T Query ( int l , int r ) { T ans = 0 ; for ( l += sz , r += sz ; l < r ; l >>= 1 , r >>= 1 ) { if ( l & 1 ) ans += sgt [ l ++ ]; if ( r & 1 ) ans += sgt [ -- r ]; } return ans ; } void Add ( int x , T val ) { for ( sgt [ x += sz ] += val ; x > 1 ; x >>= 1 ) sgt [ x >> 1 ] = sgt [ x ] + sgt [ x ^ 1 ]; } private : int sz ; vector < T > sgt ; }; \u64cd\u4f5c\u8bf4\u660e\uff1a using ll = long long ; // \u5efa\u7acb\u4e00\u4e2a\u957f\u5ea6\u4e3a10\u7684\u6bb5\u6811 SGT < ll > s ( 10 ); for ( int i = 0 ; i < 10 ; i ++ ) { s . Add ( i , i ); } // \u67e5\u8be2 [3, 7) \u7684\u548c int sum = s . Query ( 3 , 7 ); cout << sum << endl ; \u8f93\u51fa\uff1a 18 \u7b97\u6cd5 \u7ebf\u6bb5\u6811\u662f\u4e00\u9897\u6709\u5947\u6570\u4e2a\u8282\u70b9\u7684\u7684\u5b8c\u5168\u4e8c\u53c9\u6811: \u7531\u4e8e\u7ebf\u6bb5\u6811\u7684\u540e\u534a\u6bb5\uff08\u53f6\u8282\u70b9\uff09\u5b58\u50a8\u4e86\u539f\u6570\u7ec4\u7684\u5185\u5bb9\uff0c\u6545\u7ebf\u6bb5\u6811\u7684\u64cd\u4f5c\u65e0\u8bba\u5efa\u7acb\u3001\u6c42\u548c\u6216\u8005\u66f4\u65b0\u503c\u90fd\u662f\u5148\u5b9a\u4f4d\u5230\u53f6\u8282\u70b9\u7136\u540e\u81ea\u5e95\u5411\u4e0a\u8fdb\u884c\u3002 \u5177\u4f53\u5730\uff0c\u533a\u95f4\u548c\u64cd\u4f5c\u662f\u5148\u5c06\u8868\u5f81\u5de6\u53f3\u7aef\u70b9\u6307\u9488\u5b9a\u4f4d\u5728\u53f6\u8282\u70b9\u76f8\u5e94\u4f4d\u7f6e\uff0c\u7136\u540e\u4e00\u6b65\u6b65\u4e0a\u79fb\u7d27\u7f29\uff0c\u8fc7\u7a0b\u6bcf\u5f53\u7aef\u70b9\u51fa\u73b0\u5947\u6570\u5219\u9700\u8981\u201c\u63a5\u6f0f\u201d\u2014\u2014\u5176\u4e2d\u5de6\u7aef\u662f\u95ed\u533a\u95f4\u6240\u4ee5\u5148\u52a0\u518d\u7f29\uff0c\u53f3\u7aef\u662f\u5f00\u533a\u95f4\u6240\u4ee5\u5148\u7f29\u518d\u52a0\u3002 \u8ba8\u8bba \u5173\u4e8e\u4e3a\u4ec0\u4e48\u6570\u7ec4\u8868\u793a\u7684\u4e8c\u53c9\u6811\u4e00\u822c\u4e0d\u4f7f\u7528\u4e0b\u6807 0 0 \u4ece\u4e0a\u81f3\u4e0b\uff0c\u4ece\u5de6\u81f3\u53f3\u5bf9\u4e00\u68f5\u6ee1\u4e8c\u53c9\u6811\u7f16\u53f7\uff0c\u5982\u6839\u8282\u70b9\u7f16\u53f7\u4e3a 1 1 \uff0c\u5219\u8282\u70b9\u7684\u5de6\u53f3\u513f\u5b50\u548c\u7236\u4eb2\u5206\u522b\u4e3a p << 1 p << 1 , p << 1 | 1 p << 1 | 1 , p >> 1 p >> 1 \uff0c\u8282\u70b9\u4e4b\u95f4\u7684\u8f6c\u79fb\u53ef\u4ee5\u53ea\u901a\u8fc7\u4f4d\u8fd0\u7b97\u5b8c\u6210\u3002\u7136\u800c\u82e5\u6839\u8282\u70b9\u4ece\u5f00\u59cb\u7f16\u53f7\uff0c\u5219\u8282\u70b9p\u7684\u5de6\u53f3\u513f\u5b50\u5206\u522b\u4e3a 2p + 1 2p + 1 , 2p + 2 2p + 2 \uff0c\u7236\u4eb2\u7684\u7d22\u5f15\u4e0e p p \u7684\u5947\u5076\u6027\u6709\u5173\uff0c\u7d22\u5f15\u8f6c\u79fb\u56e0\u800c\u590d\u6742\u5f97\u591a\u3002 \u53d8\u4f53 \u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u3001\u67e5\u8be2\u533a\u95f4\u6700\u503c\u3002 \u6700\u5927\u503c template < typename T > class SGT { public : SGT () {} SGT ( int _sz ) : sz ( _sz ) { sgt = vector < T > ( sz << 1 , 0 ); } SGT ( vector < T > arr ) : sz (( int ) arr . size ()) { sgt = vector < T > ( sz << 1 , 0 ); for ( int i = 0 ; i < sz ; i ++ ) this -> Update ( i , arr [ i ]); } T Query ( int l , int r ) { T ans = numeric_limits < T >:: min (); for ( l += sz , r += sz ; l < r ; l >>= 1 , r >>= 1 ) { if ( l & 1 ) ans = max ( ans , sgt [ l ++ ]); if ( r & 1 ) ans = max ( ans , sgt [ -- r ]); } return ans ; } void Update ( int x , T val ) { for ( sgt [ x += sz ] = val ; x > 1 ; x >>= 1 ) sgt [ x >> 1 ] = max ( sgt [ x ], sgt [ x ^ 1 ]); } private : int sz ; vector < T > sgt ; }; \u6700\u5c0f\u503c template < typename T > class SGT { public : SGT () {} SGT ( int _sz ) : sz ( _sz ) { sgt = vector < T > ( sz << 1 , 0 ); } SGT ( vector < T > arr ) : sz (( int ) arr . size ()) { sgt = vector < T > ( sz << 1 , 0 ); for ( int i = 0 ; i < sz ; i ++ ) this -> Update ( i , arr [ i ]); } T Query ( int l , int r ) { T ans = numeric_limits < T >:: max (); for ( l += sz , r += sz ; l < r ; l >>= 1 , r >>= 1 ) { if ( l & 1 ) ans = min ( ans , sgt [ l ++ ]); if ( r & 1 ) ans = min ( ans , sgt [ -- r ]); } return ans ; } void Update ( int x , T val ) { for ( sgt [ x += sz ] = val ; x > 1 ; x >>= 1 ) sgt [ x >> 1 ] = min ( sgt [ x ], sgt [ x ^ 1 ]); } private : int sz ; vector < T > sgt ; };","title":"\u7ebf\u6bb5\u6811"},{"location":"competitive_programming/data_structure/segment_tree/#_1","text":"\u76f8\u8f83Fenwick\u6811\uff0c\u7ebf\u6bb5\u6811\u9664\u4e86\u652f\u6301\u5728 O(\\log n) O(\\log n) \u65f6\u95f4\u5185\u66f4\u65b0\u5236\u5b9a\u5143\u7d20\u548c\u8ba1\u7b97\u533a\u95f4\u548c\u4ee5\u5916\uff0c\u8fd8\u652f\u6301\u5728 O(\\log n) O(\\log n) \u65f6\u95f4\u5185\u8ba1\u7b97\u533a\u95f4\u6700\u503c\uff0c\u4f46\u4e3a\u6b64\u591a\u4ed8\u51fa\u4e86 O(n) O(n) \u7684\u7a7a\u95f4\u5f00\u9500\u3002","title":"\u7ebf\u6bb5\u6811"},{"location":"competitive_programming/data_structure/segment_tree/#_2","text":"\u7ed9\u5b9a\u957f\u5ea6\u4e3a n n \u7684\u5e8f\u5217 v v \uff0c\u8981\u6c42\u5728 O(\\log n) O(\\log n) \u7684\u65f6\u95f4\u5185\u5b8c\u6210\u5982\u4e0b\u64cd\u4f5c\uff1a \u66f4\u65b0\u5355\u4e2a\u5143\u7d20 v[i] v[i] \u7684\u503c \u67e5\u8be2\u4f4d\u4e8e\u533a\u95f4 [l, r) [l, r) \u7684\u5143\u7d20\u548c","title":"\u95ee\u9898"},{"location":"competitive_programming/data_structure/segment_tree/#_3","text":"\u7528\u4e8e\u7ef4\u62a4\u533a\u95f4\u6c42\u548c\u7684\u7ebf\u6bb5\u6811\uff1a template < typename T > class SGT { public : SGT () {} SGT ( int _sz ) : sz ( _sz ) { sgt = vector < T > ( sz << 1 , 0 ); } SGT ( vector < T > arr ) : sz (( int ) arr . size ()) { sgt = vector < T > ( sz << 1 , 0 ); for ( int i = 0 ; i < sz ; i ++ ) this -> Add ( i , arr [ i ]); } T Query ( int l , int r ) { T ans = 0 ; for ( l += sz , r += sz ; l < r ; l >>= 1 , r >>= 1 ) { if ( l & 1 ) ans += sgt [ l ++ ]; if ( r & 1 ) ans += sgt [ -- r ]; } return ans ; } void Add ( int x , T val ) { for ( sgt [ x += sz ] += val ; x > 1 ; x >>= 1 ) sgt [ x >> 1 ] = sgt [ x ] + sgt [ x ^ 1 ]; } private : int sz ; vector < T > sgt ; }; \u64cd\u4f5c\u8bf4\u660e\uff1a using ll = long long ; // \u5efa\u7acb\u4e00\u4e2a\u957f\u5ea6\u4e3a10\u7684\u6bb5\u6811 SGT < ll > s ( 10 ); for ( int i = 0 ; i < 10 ; i ++ ) { s . Add ( i , i ); } // \u67e5\u8be2 [3, 7) \u7684\u548c int sum = s . Query ( 3 , 7 ); cout << sum << endl ; \u8f93\u51fa\uff1a 18","title":"\u4ee3\u7801"},{"location":"competitive_programming/data_structure/segment_tree/#_4","text":"\u7ebf\u6bb5\u6811\u662f\u4e00\u9897\u6709\u5947\u6570\u4e2a\u8282\u70b9\u7684\u7684\u5b8c\u5168\u4e8c\u53c9\u6811: \u7531\u4e8e\u7ebf\u6bb5\u6811\u7684\u540e\u534a\u6bb5\uff08\u53f6\u8282\u70b9\uff09\u5b58\u50a8\u4e86\u539f\u6570\u7ec4\u7684\u5185\u5bb9\uff0c\u6545\u7ebf\u6bb5\u6811\u7684\u64cd\u4f5c\u65e0\u8bba\u5efa\u7acb\u3001\u6c42\u548c\u6216\u8005\u66f4\u65b0\u503c\u90fd\u662f\u5148\u5b9a\u4f4d\u5230\u53f6\u8282\u70b9\u7136\u540e\u81ea\u5e95\u5411\u4e0a\u8fdb\u884c\u3002 \u5177\u4f53\u5730\uff0c\u533a\u95f4\u548c\u64cd\u4f5c\u662f\u5148\u5c06\u8868\u5f81\u5de6\u53f3\u7aef\u70b9\u6307\u9488\u5b9a\u4f4d\u5728\u53f6\u8282\u70b9\u76f8\u5e94\u4f4d\u7f6e\uff0c\u7136\u540e\u4e00\u6b65\u6b65\u4e0a\u79fb\u7d27\u7f29\uff0c\u8fc7\u7a0b\u6bcf\u5f53\u7aef\u70b9\u51fa\u73b0\u5947\u6570\u5219\u9700\u8981\u201c\u63a5\u6f0f\u201d\u2014\u2014\u5176\u4e2d\u5de6\u7aef\u662f\u95ed\u533a\u95f4\u6240\u4ee5\u5148\u52a0\u518d\u7f29\uff0c\u53f3\u7aef\u662f\u5f00\u533a\u95f4\u6240\u4ee5\u5148\u7f29\u518d\u52a0\u3002","title":"\u7b97\u6cd5"},{"location":"competitive_programming/data_structure/segment_tree/#_5","text":"\u5173\u4e8e\u4e3a\u4ec0\u4e48\u6570\u7ec4\u8868\u793a\u7684\u4e8c\u53c9\u6811\u4e00\u822c\u4e0d\u4f7f\u7528\u4e0b\u6807 0 0 \u4ece\u4e0a\u81f3\u4e0b\uff0c\u4ece\u5de6\u81f3\u53f3\u5bf9\u4e00\u68f5\u6ee1\u4e8c\u53c9\u6811\u7f16\u53f7\uff0c\u5982\u6839\u8282\u70b9\u7f16\u53f7\u4e3a 1 1 \uff0c\u5219\u8282\u70b9\u7684\u5de6\u53f3\u513f\u5b50\u548c\u7236\u4eb2\u5206\u522b\u4e3a p << 1 p << 1 , p << 1 | 1 p << 1 | 1 , p >> 1 p >> 1 \uff0c\u8282\u70b9\u4e4b\u95f4\u7684\u8f6c\u79fb\u53ef\u4ee5\u53ea\u901a\u8fc7\u4f4d\u8fd0\u7b97\u5b8c\u6210\u3002\u7136\u800c\u82e5\u6839\u8282\u70b9\u4ece\u5f00\u59cb\u7f16\u53f7\uff0c\u5219\u8282\u70b9p\u7684\u5de6\u53f3\u513f\u5b50\u5206\u522b\u4e3a 2p + 1 2p + 1 , 2p + 2 2p + 2 \uff0c\u7236\u4eb2\u7684\u7d22\u5f15\u4e0e p p \u7684\u5947\u5076\u6027\u6709\u5173\uff0c\u7d22\u5f15\u8f6c\u79fb\u56e0\u800c\u590d\u6742\u5f97\u591a\u3002","title":"\u8ba8\u8bba"},{"location":"competitive_programming/data_structure/segment_tree/#_6","text":"\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u3001\u67e5\u8be2\u533a\u95f4\u6700\u503c\u3002 \u6700\u5927\u503c template < typename T > class SGT { public : SGT () {} SGT ( int _sz ) : sz ( _sz ) { sgt = vector < T > ( sz << 1 , 0 ); } SGT ( vector < T > arr ) : sz (( int ) arr . size ()) { sgt = vector < T > ( sz << 1 , 0 ); for ( int i = 0 ; i < sz ; i ++ ) this -> Update ( i , arr [ i ]); } T Query ( int l , int r ) { T ans = numeric_limits < T >:: min (); for ( l += sz , r += sz ; l < r ; l >>= 1 , r >>= 1 ) { if ( l & 1 ) ans = max ( ans , sgt [ l ++ ]); if ( r & 1 ) ans = max ( ans , sgt [ -- r ]); } return ans ; } void Update ( int x , T val ) { for ( sgt [ x += sz ] = val ; x > 1 ; x >>= 1 ) sgt [ x >> 1 ] = max ( sgt [ x ], sgt [ x ^ 1 ]); } private : int sz ; vector < T > sgt ; }; \u6700\u5c0f\u503c template < typename T > class SGT { public : SGT () {} SGT ( int _sz ) : sz ( _sz ) { sgt = vector < T > ( sz << 1 , 0 ); } SGT ( vector < T > arr ) : sz (( int ) arr . size ()) { sgt = vector < T > ( sz << 1 , 0 ); for ( int i = 0 ; i < sz ; i ++ ) this -> Update ( i , arr [ i ]); } T Query ( int l , int r ) { T ans = numeric_limits < T >:: max (); for ( l += sz , r += sz ; l < r ; l >>= 1 , r >>= 1 ) { if ( l & 1 ) ans = min ( ans , sgt [ l ++ ]); if ( r & 1 ) ans = min ( ans , sgt [ -- r ]); } return ans ; } void Update ( int x , T val ) { for ( sgt [ x += sz ] = val ; x > 1 ; x >>= 1 ) sgt [ x >> 1 ] = min ( sgt [ x ], sgt [ x ^ 1 ]); } private : int sz ; vector < T > sgt ; };","title":"\u53d8\u4f53"},{"location":"competitive_programming/data_structure/skiplist/","text":"\u8df3\u8868 \u95ee\u9898 \u5b9e\u73b0\u4e00\u79cd\u96c6\u5408\u6570\u636e\u7ed3\u6784\uff0c\u652f\u6301\u5982\u4e0b\u64cd\u4f5c\uff1a 1. \u63d2\u5165 / Insert 2. \u5220\u9664 / Delete 3. \u67e5\u627e / Search 4. \u6309\u5e8f\u904d\u5386 \u663e\u7136\uff0c \u5e73\u8861\u6811 \uff08\u5982\u7ea2\u9ed1\u6811\uff09\u7c7b\u7684\u6570\u636e\u7ed3\u6784\u7ec4\u7ec7\u6570\u636e\u53ef\u4ee5\u6253\u6ee1\u8db3\u4e0a\u8ff0\u8981\u6c42\uff0c\u589e\u3001\u5220\u3001\u67e5\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u90fd\u662f O(\\log n) O(\\log n) \uff0c\u800c\u987a\u5e8f\u8fed\u4ee3\u989d\u590d\u6742\u5ea6\u4e3a O(1) O(1) \u3002\u9664\u6b64\u4e4b\u5916\u8fd8\u6709\u4ec0\u4e48\u601d\u8def\uff1f \u8df3\u8868 \u901a\u8fc7\u5728\u6709\u5e8f\u94fe\u8868\u4e0a\u589e\u52a0\u82e5\u5e72\u7ea7\u7d22\u5f15\u5c42\u5b9e\u73b0\u4e0a\u8ff0\u9700\u6c42\u3002 C++\u5b9e\u73b0 \u5b9e\u73b0\u6210\u5458\u4e3a int \u578b\u7684\u8df3\u8868 SkipList \u7c7b\uff1a class Node { public : int key ; // Array to hold pointers to node of different level Node ** forward ; Node ( int , int ); }; Node :: Node ( int key , int level ) { this -> key = key ; // Allocate memory to forward forward = new Node * [ level + 1 ]; // Fill forward array with 0(NULL) memset ( forward , 0 , sizeof ( Node * ) * ( level + 1 )); }; class SkipList { public : SkipList ( int , float ); friend ostream & operator << ( ostream & out , const SkipList & src ); void Insert ( int ); void Delete ( int ); bool Search ( int ); private : int RandomLevel (); Node * CreateNode ( int , int ); // Maximum level for this skip list int MAXLVL ; // P is the fraction of the nodes with level // i pointers also having level i+1 pointers float P ; // current level of skip list int level ; // pointer to header node Node * header ; }; SkipList :: SkipList ( int MAXLVL , float P ) { this -> MAXLVL = MAXLVL ; this -> P = P ; level = 0 ; // create header node and initialize key to -1 header = new Node ( - 1 , MAXLVL ); }; int SkipList :: RandomLevel () { float r = ( float ) rand () / RAND_MAX ; int lvl = 0 ; while ( r < P && lvl < MAXLVL ) { lvl ++ ; r = ( float ) rand () / RAND_MAX ; } return lvl ; }; Node * SkipList :: CreateNode ( int key , int level ) { Node * n = new Node ( key , level ); return n ; }; void SkipList :: Insert ( int key ) { Node * current = header ; // create update array and initialize it Node * update [ MAXLVL + 1 ]; memset ( update , 0 , sizeof ( Node * ) * ( MAXLVL + 1 )); /* start from highest level of skip list move the current pointer forward while key is greater than key of node next to current Otherwise inserted current in update and move one level down and continue search */ for ( int i = level ; i >= 0 ; i -- ) { while ( current -> forward [ i ] != NULL && current -> forward [ i ] -> key < key ) current = current -> forward [ i ]; update [ i ] = current ; } /* reached level 0 and forward pointer to right, which is desired position to insert key. */ current = current -> forward [ 0 ]; /* if current is NULL that means we have reached to end of the level or current's key is not equal to key to insert that means we have to insert node between update[0] and current node */ if ( current == NULL || current -> key != key ) { // Generate a random level for node int rlevel = RandomLevel (); /* If random level is greater than list's current level (node with highest level inserted in list so far), initialize update value with pointer to header for further use */ if ( rlevel > level ) { for ( int i = level + 1 ; i < rlevel + 1 ; i ++ ) update [ i ] = header ; // Update the list current level level = rlevel ; } // create new node with random level generated Node * n = CreateNode ( key , rlevel ); // insert node by rearranging pointers for ( int i = 0 ; i <= rlevel ; i ++ ) { n -> forward [ i ] = update [ i ] -> forward [ i ]; update [ i ] -> forward [ i ] = n ; } // cout << \"Successfully Inserted key \" << key << \"\\n\"; } }; void SkipList :: Delete ( int key ) { Node * current = header ; // create update array and initialize it Node * update [ MAXLVL + 1 ]; memset ( update , 0 , sizeof ( Node * ) * ( MAXLVL + 1 )); /* start from highest level of skip list move the current pointer forward while key is greater than key of node next to current Otherwise inserted current in update and move one level down and continue search */ for ( int i = level ; i >= 0 ; i -- ) { while ( current -> forward [ i ] != NULL && current -> forward [ i ] -> key < key ) current = current -> forward [ i ]; update [ i ] = current ; } /* reached level 0 and forward pointer to right, which is possibly our desired node.*/ current = current -> forward [ 0 ]; // If current node is target node if ( current != NULL and current -> key == key ) { /* start from lowest level and rearrange pointers just like we do in singly linked list to remove target node */ for ( int i = 0 ; i <= level ; i ++ ) { /* If at level i, next node is not target node, break the loop, no need to move further level */ if ( update [ i ] -> forward [ i ] != current ) break ; update [ i ] -> forward [ i ] = current -> forward [ i ]; } // Remove levels having no elements while ( level > 0 && header -> forward [ level ] == 0 ) level -- ; // cout << \"Successfully deleted key \" << key << \"\\n\"; } }; // Search for element in skip list bool SkipList :: Search ( int key ) { Node * current = header ; /* start from highest level of skip list move the current pointer forward while key is greater than key of node next to current Otherwise inserted current in update and move one level down and continue search */ for ( int i = level ; i >= 0 ; i -- ) { while ( current -> forward [ i ] && current -> forward [ i ] -> key < key ) current = current -> forward [ i ]; } /* reached level 0 and advance pointer to right, which is possibly our desired node*/ current = current -> forward [ 0 ]; // If current node have key equal to // search key, we have found our target node if ( current and current -> key == key ) return true ; else return false ; }; // Display SkipList by overriding '<<' operator ostream & operator << ( ostream & out , const SkipList & src ) { cout << \" \\n *****Skip List*****\" << \" \\n \" ; for ( int i = 0 ; i <= src . level ; i ++ ) { Node * node = src . header -> forward [ i ]; cout << \"Level \" << i << \": \" ; while ( node != NULL ) { cout << node -> key << \" \" ; node = node -> forward [ i ]; } cout << \" \\n \" ; } return out ; } \u6d4b\u8bd5\u4ee3\u7801\uff1a int main () { // Seed random number generator srand (( unsigned ) time ( 0 )); // create SkipList object with MAXLVL and P SkipList lst ( 3 , 0.5 ); lst . Insert ( 3 ); lst . Insert ( 6 ); lst . Insert ( 7 ); lst . Insert ( 9 ); lst . Insert ( 12 ); lst . Insert ( 19 ); lst . Insert ( 17 ); lst . Insert ( 26 ); lst . Insert ( 21 ); lst . Insert ( 25 ); cout << lst << endl ; // Search for node 19 cout << \"search 19: \" ; cout << lst . Search ( 19 ) << endl ; // Delete node 19 lst . Delete ( 19 ); cout << lst << endl ; // Search for node 19 cout << \"search 19: \" ; cout << lst . Search ( 19 ) << endl ; } \u8f93\u51fa\uff1a ***** Skip List ***** Level 0 : 3 6 7 9 12 17 19 21 25 26 Level 1 : 3 7 9 19 21 Level 2 : 19 search 19 : 1 ***** Skip List ***** Level 0 : 3 6 7 9 12 17 21 25 26 Level 1 : 3 7 9 21 search 19 : 0","title":"\u8df3\u8868"},{"location":"competitive_programming/data_structure/skiplist/#_1","text":"","title":"\u8df3\u8868"},{"location":"competitive_programming/data_structure/skiplist/#_2","text":"\u5b9e\u73b0\u4e00\u79cd\u96c6\u5408\u6570\u636e\u7ed3\u6784\uff0c\u652f\u6301\u5982\u4e0b\u64cd\u4f5c\uff1a 1. \u63d2\u5165 / Insert 2. \u5220\u9664 / Delete 3. \u67e5\u627e / Search 4. \u6309\u5e8f\u904d\u5386 \u663e\u7136\uff0c \u5e73\u8861\u6811 \uff08\u5982\u7ea2\u9ed1\u6811\uff09\u7c7b\u7684\u6570\u636e\u7ed3\u6784\u7ec4\u7ec7\u6570\u636e\u53ef\u4ee5\u6253\u6ee1\u8db3\u4e0a\u8ff0\u8981\u6c42\uff0c\u589e\u3001\u5220\u3001\u67e5\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u90fd\u662f O(\\log n) O(\\log n) \uff0c\u800c\u987a\u5e8f\u8fed\u4ee3\u989d\u590d\u6742\u5ea6\u4e3a O(1) O(1) \u3002\u9664\u6b64\u4e4b\u5916\u8fd8\u6709\u4ec0\u4e48\u601d\u8def\uff1f","title":"\u95ee\u9898"},{"location":"competitive_programming/data_structure/skiplist/#_3","text":"\u901a\u8fc7\u5728\u6709\u5e8f\u94fe\u8868\u4e0a\u589e\u52a0\u82e5\u5e72\u7ea7\u7d22\u5f15\u5c42\u5b9e\u73b0\u4e0a\u8ff0\u9700\u6c42\u3002","title":"\u8df3\u8868"},{"location":"competitive_programming/data_structure/skiplist/#c","text":"\u5b9e\u73b0\u6210\u5458\u4e3a int \u578b\u7684\u8df3\u8868 SkipList \u7c7b\uff1a class Node { public : int key ; // Array to hold pointers to node of different level Node ** forward ; Node ( int , int ); }; Node :: Node ( int key , int level ) { this -> key = key ; // Allocate memory to forward forward = new Node * [ level + 1 ]; // Fill forward array with 0(NULL) memset ( forward , 0 , sizeof ( Node * ) * ( level + 1 )); }; class SkipList { public : SkipList ( int , float ); friend ostream & operator << ( ostream & out , const SkipList & src ); void Insert ( int ); void Delete ( int ); bool Search ( int ); private : int RandomLevel (); Node * CreateNode ( int , int ); // Maximum level for this skip list int MAXLVL ; // P is the fraction of the nodes with level // i pointers also having level i+1 pointers float P ; // current level of skip list int level ; // pointer to header node Node * header ; }; SkipList :: SkipList ( int MAXLVL , float P ) { this -> MAXLVL = MAXLVL ; this -> P = P ; level = 0 ; // create header node and initialize key to -1 header = new Node ( - 1 , MAXLVL ); }; int SkipList :: RandomLevel () { float r = ( float ) rand () / RAND_MAX ; int lvl = 0 ; while ( r < P && lvl < MAXLVL ) { lvl ++ ; r = ( float ) rand () / RAND_MAX ; } return lvl ; }; Node * SkipList :: CreateNode ( int key , int level ) { Node * n = new Node ( key , level ); return n ; }; void SkipList :: Insert ( int key ) { Node * current = header ; // create update array and initialize it Node * update [ MAXLVL + 1 ]; memset ( update , 0 , sizeof ( Node * ) * ( MAXLVL + 1 )); /* start from highest level of skip list move the current pointer forward while key is greater than key of node next to current Otherwise inserted current in update and move one level down and continue search */ for ( int i = level ; i >= 0 ; i -- ) { while ( current -> forward [ i ] != NULL && current -> forward [ i ] -> key < key ) current = current -> forward [ i ]; update [ i ] = current ; } /* reached level 0 and forward pointer to right, which is desired position to insert key. */ current = current -> forward [ 0 ]; /* if current is NULL that means we have reached to end of the level or current's key is not equal to key to insert that means we have to insert node between update[0] and current node */ if ( current == NULL || current -> key != key ) { // Generate a random level for node int rlevel = RandomLevel (); /* If random level is greater than list's current level (node with highest level inserted in list so far), initialize update value with pointer to header for further use */ if ( rlevel > level ) { for ( int i = level + 1 ; i < rlevel + 1 ; i ++ ) update [ i ] = header ; // Update the list current level level = rlevel ; } // create new node with random level generated Node * n = CreateNode ( key , rlevel ); // insert node by rearranging pointers for ( int i = 0 ; i <= rlevel ; i ++ ) { n -> forward [ i ] = update [ i ] -> forward [ i ]; update [ i ] -> forward [ i ] = n ; } // cout << \"Successfully Inserted key \" << key << \"\\n\"; } }; void SkipList :: Delete ( int key ) { Node * current = header ; // create update array and initialize it Node * update [ MAXLVL + 1 ]; memset ( update , 0 , sizeof ( Node * ) * ( MAXLVL + 1 )); /* start from highest level of skip list move the current pointer forward while key is greater than key of node next to current Otherwise inserted current in update and move one level down and continue search */ for ( int i = level ; i >= 0 ; i -- ) { while ( current -> forward [ i ] != NULL && current -> forward [ i ] -> key < key ) current = current -> forward [ i ]; update [ i ] = current ; } /* reached level 0 and forward pointer to right, which is possibly our desired node.*/ current = current -> forward [ 0 ]; // If current node is target node if ( current != NULL and current -> key == key ) { /* start from lowest level and rearrange pointers just like we do in singly linked list to remove target node */ for ( int i = 0 ; i <= level ; i ++ ) { /* If at level i, next node is not target node, break the loop, no need to move further level */ if ( update [ i ] -> forward [ i ] != current ) break ; update [ i ] -> forward [ i ] = current -> forward [ i ]; } // Remove levels having no elements while ( level > 0 && header -> forward [ level ] == 0 ) level -- ; // cout << \"Successfully deleted key \" << key << \"\\n\"; } }; // Search for element in skip list bool SkipList :: Search ( int key ) { Node * current = header ; /* start from highest level of skip list move the current pointer forward while key is greater than key of node next to current Otherwise inserted current in update and move one level down and continue search */ for ( int i = level ; i >= 0 ; i -- ) { while ( current -> forward [ i ] && current -> forward [ i ] -> key < key ) current = current -> forward [ i ]; } /* reached level 0 and advance pointer to right, which is possibly our desired node*/ current = current -> forward [ 0 ]; // If current node have key equal to // search key, we have found our target node if ( current and current -> key == key ) return true ; else return false ; }; // Display SkipList by overriding '<<' operator ostream & operator << ( ostream & out , const SkipList & src ) { cout << \" \\n *****Skip List*****\" << \" \\n \" ; for ( int i = 0 ; i <= src . level ; i ++ ) { Node * node = src . header -> forward [ i ]; cout << \"Level \" << i << \": \" ; while ( node != NULL ) { cout << node -> key << \" \" ; node = node -> forward [ i ]; } cout << \" \\n \" ; } return out ; } \u6d4b\u8bd5\u4ee3\u7801\uff1a int main () { // Seed random number generator srand (( unsigned ) time ( 0 )); // create SkipList object with MAXLVL and P SkipList lst ( 3 , 0.5 ); lst . Insert ( 3 ); lst . Insert ( 6 ); lst . Insert ( 7 ); lst . Insert ( 9 ); lst . Insert ( 12 ); lst . Insert ( 19 ); lst . Insert ( 17 ); lst . Insert ( 26 ); lst . Insert ( 21 ); lst . Insert ( 25 ); cout << lst << endl ; // Search for node 19 cout << \"search 19: \" ; cout << lst . Search ( 19 ) << endl ; // Delete node 19 lst . Delete ( 19 ); cout << lst << endl ; // Search for node 19 cout << \"search 19: \" ; cout << lst . Search ( 19 ) << endl ; } \u8f93\u51fa\uff1a ***** Skip List ***** Level 0 : 3 6 7 9 12 17 19 21 25 26 Level 1 : 3 7 9 19 21 Level 2 : 19 search 19 : 1 ***** Skip List ***** Level 0 : 3 6 7 9 12 17 21 25 26 Level 1 : 3 7 9 21 search 19 : 0","title":"C++\u5b9e\u73b0"},{"location":"competitive_programming/data_structure/union_find/","text":"\u5e76\u67e5\u96c6 \u95ee\u9898 \u5bf9\u4e8e\u6709 n n \u4e2a\u8282\u70b9\u7684\u56fe\uff0c\u8bbe\u8ba1\u4e00\u79cd\u7ef4\u62a4\u52a8\u6001\u8fde\u901a\u6027\u95ee\u9898\u7684\u6570\u636e\u7ed3\u6784\uff0c\u652f\u6301\u5982\u4e0b\u64cd\u4f5c\uff1a Find(i) - \u67e5\u8be2\u7f16\u53f7\u4e3a i i \u7684\u8282\u70b9\u6240\u5c5e\u7684\u8fde\u901a\u5206\u91cf Union(i, j) - \u8fde\u63a5\u7f16\u53f7\u4e3a i i \u548c j j \u7684\u8282\u70b9\uff08\u4e8c\u8005\u6240\u5728\u7684\u8fde\u901a\u5206\u91cf\u8fde\u901a\uff09 \u4ee3\u7801 class UnionFind { public : UnionFind ( int _sz ) : sz ( _sz ) { pre = vector < int > ( sz ); for ( int i = 0 ; i < sz ; i ++ ) pre [ i ] = i ; } int Find ( int x ) { // Find root. int r = x ; while ( r != pre [ r ]) r = pre [ r ]; // Path compress. while ( x != r ) { int tmp = pre [ x ]; pre [ x ] = r ; x = tmp ; } return r ; } void Join ( int x , int y ) { int rx = Find ( x ), ry = Find ( y ); if ( rx != ry ) pre [ rx ] = ry ; } int size () { return sz ; } private : int sz ; vector < int > pre ; }; \u7b97\u6cd5 \u6570\u7ec4 pre pre \u8bb0\u5f55\u4e86\u6bcf\u4e2a\u8282\u70b9\u7684\u524d\u5bfc\u8282\u70b9\u3002 \u5e76\u67e5\u96c6\u6bcf\u6b21 Union \u64cd\u4f5c\u968f\u673a\u5c06\u4e00\u4e2a\u95e8\u6d3e\u7684\u638c\u95e8\u4f5c\u4e3a\u53e6\u4e00\u4e2a\u95e8\u6d3e\u638c\u95e8\u7684\u76f4\u63a5\u4e0a\u7ea7\uff1b\u800c\u6bcf\u6b21 Find \u64cd\u4f5c\u5728\u9010\u5c42\u5411\u4e0a\u627e\u5230\u638c\u95e8\u4e4b\u540e\u53c8\u5c06\u8def\u5f84\u4e2d\u6240\u6709\u8fc7\u7a0b\u8282\u70b9\u90fd\u6539\u6210\u638c\u95e8\u7684\u76f4\u63a5\u4e0b\u7ea7\u3002\u6240\u4ee5\u8bf4\uff0c\u5f53 Union \u64cd\u4f5c\u7684\u589e\u591a\u4f1a\u5bfc\u81f4\u6811\u72b6\u6570\u636e\u7ed3\u6784\u8d8b\u4e8e\u4e0d\u5e73\u8861\uff0c\u800c Find \u64cd\u4f5c\u5f88\u591a\u7684\u65f6\u5019\uff0c\u5c06\u6700\u7ec8\u5bfc\u81f4\u6240\u6709\u8282\u70b9\u90fd\u4ee5\u638c\u95e8\u4e3a\u76f4\u63a5\u4e0a\u7ea7\uff08\u6c47\u62a5\u8ddd\u79bb\u53d8\u6210 1 1 \uff09\u3002","title":"\u5e76\u67e5\u96c6"},{"location":"competitive_programming/data_structure/union_find/#_1","text":"","title":"\u5e76\u67e5\u96c6"},{"location":"competitive_programming/data_structure/union_find/#_2","text":"\u5bf9\u4e8e\u6709 n n \u4e2a\u8282\u70b9\u7684\u56fe\uff0c\u8bbe\u8ba1\u4e00\u79cd\u7ef4\u62a4\u52a8\u6001\u8fde\u901a\u6027\u95ee\u9898\u7684\u6570\u636e\u7ed3\u6784\uff0c\u652f\u6301\u5982\u4e0b\u64cd\u4f5c\uff1a Find(i) - \u67e5\u8be2\u7f16\u53f7\u4e3a i i \u7684\u8282\u70b9\u6240\u5c5e\u7684\u8fde\u901a\u5206\u91cf Union(i, j) - \u8fde\u63a5\u7f16\u53f7\u4e3a i i \u548c j j \u7684\u8282\u70b9\uff08\u4e8c\u8005\u6240\u5728\u7684\u8fde\u901a\u5206\u91cf\u8fde\u901a\uff09","title":"\u95ee\u9898"},{"location":"competitive_programming/data_structure/union_find/#_3","text":"class UnionFind { public : UnionFind ( int _sz ) : sz ( _sz ) { pre = vector < int > ( sz ); for ( int i = 0 ; i < sz ; i ++ ) pre [ i ] = i ; } int Find ( int x ) { // Find root. int r = x ; while ( r != pre [ r ]) r = pre [ r ]; // Path compress. while ( x != r ) { int tmp = pre [ x ]; pre [ x ] = r ; x = tmp ; } return r ; } void Join ( int x , int y ) { int rx = Find ( x ), ry = Find ( y ); if ( rx != ry ) pre [ rx ] = ry ; } int size () { return sz ; } private : int sz ; vector < int > pre ; };","title":"\u4ee3\u7801"},{"location":"competitive_programming/data_structure/union_find/#_4","text":"\u6570\u7ec4 pre pre \u8bb0\u5f55\u4e86\u6bcf\u4e2a\u8282\u70b9\u7684\u524d\u5bfc\u8282\u70b9\u3002 \u5e76\u67e5\u96c6\u6bcf\u6b21 Union \u64cd\u4f5c\u968f\u673a\u5c06\u4e00\u4e2a\u95e8\u6d3e\u7684\u638c\u95e8\u4f5c\u4e3a\u53e6\u4e00\u4e2a\u95e8\u6d3e\u638c\u95e8\u7684\u76f4\u63a5\u4e0a\u7ea7\uff1b\u800c\u6bcf\u6b21 Find \u64cd\u4f5c\u5728\u9010\u5c42\u5411\u4e0a\u627e\u5230\u638c\u95e8\u4e4b\u540e\u53c8\u5c06\u8def\u5f84\u4e2d\u6240\u6709\u8fc7\u7a0b\u8282\u70b9\u90fd\u6539\u6210\u638c\u95e8\u7684\u76f4\u63a5\u4e0b\u7ea7\u3002\u6240\u4ee5\u8bf4\uff0c\u5f53 Union \u64cd\u4f5c\u7684\u589e\u591a\u4f1a\u5bfc\u81f4\u6811\u72b6\u6570\u636e\u7ed3\u6784\u8d8b\u4e8e\u4e0d\u5e73\u8861\uff0c\u800c Find \u64cd\u4f5c\u5f88\u591a\u7684\u65f6\u5019\uff0c\u5c06\u6700\u7ec8\u5bfc\u81f4\u6240\u6709\u8282\u70b9\u90fd\u4ee5\u638c\u95e8\u4e3a\u76f4\u63a5\u4e0a\u7ea7\uff08\u6c47\u62a5\u8ddd\u79bb\u53d8\u6210 1 1 \uff09\u3002","title":"\u7b97\u6cd5"},{"location":"competitive_programming/graph_theory/bipartite_matching/","text":"\u4e8c\u5206\u56fe\u5339\u914d \u672c\u9875\u9762\u90e8\u5206\u5b9a\u4e49\u5f15\u81ea\u672c\u79d1\u540c\u5b66renfei\u7684 \u4e2a\u4eba\u535a\u5ba2 \u3002 \u95ee\u9898\uff08\u6700\u5927\u4e8c\u5206\u5339\u914d\uff09 \u7ed9\u5b9a\u4e8c\u5206\u56fe\uff0c\u6c42\u89e3\u5176\u6700\u5927\u5339\u914d\u7684\u5339\u914d\u8fb9\u6570 \u4e8c\u5206\u56fe \u4e8c\u5206\u56fe G=(V,E) G=(V,E) \u662f\u4e00\u4e2a\u65e0\u5411\u56fe\uff0c\u5176\u9876\u70b9\u96c6 V V \u53ef\u5206\u89e3\u4e3a\u4e24\u4e2a\u4e92\u4e0d\u76f8\u4ea4\u7684\u5b50\u96c6 A, B A, B \uff0c\u5bf9 \\forall e=(a, b) \\in E \\forall e=(a, b) \\in E \u6709 a \\in A, b \\in B a \\in A, b \\in B \u5339\u914d \u5728\u56fe\u8bba\u4e2d\uff0c\u4e00\u4e2a\u300c\u5339\u914d\u300d\uff08matching\uff09\u662f\u4e00\u4e2a\u8fb9\u7684\u96c6\u5408\uff0c\u5176\u4e2d\u4efb\u610f\u4e24\u6761\u8fb9\u90fd\u6ca1\u6709\u516c\u5171\u9876\u70b9\u3002 \u6700\u5927\u5339\u914d\uff1a\u4e00\u4e2a\u56fe\u7684\u6240\u6709\u5339\u914d\u4e2d\uff0c\u6240\u542b\u5339\u914d\u53d8\u6570\u6700\u591a\u7684\u5339\u914d\uff0c\u5219\u79f0\u5176\u4e3a\u4e00\u4e2a\u6700\u5927\u5339\u914d \u5b8c\u7f8e\u5339\u914d\uff1a\u5982\u679c\u4e00\u4e2a\u56fe\u7684\u6240\u6709\u5339\u914d\u4e2d\uff0c\u6240\u6709\u9876\u70b9\u90fd\u662f\u5339\u914d\u70b9\uff0c\u5219\u79f0\u5176\u4e3a\u4e00\u4e2a\u5b8c\u7f8e\u5339\u914d \u7b97\u6cd5 \u4e8c\u5206\u56fe\u7684\u6700\u5927\u5339\u914d\u95ee\u9898\u5728CLRS\u7684\u89e3\u6cd5\u662f\u7531\u6700\u5927\u7f51\u7edc\u6d41\u7684\u7b97\u6cd5\u89c4\u7ea6\u5f97\u5230\u3002\u4f46\u4e00\u79cd\u66f4\u7b80\u4fbf\u7684\u65b9\u5f0f\u662f\u901a\u8fc7\u4e0d\u65ad\u5bfb\u627e \u589e\u5e7f\u8def \u7684\u65b9\u5f0f\u5f97\u5230\uff0c\u8fd9\u79cd\u6c42\u6700\u5927\u5339\u914d\u7684\u7b97\u6cd5\u88ab\u79f0\u4e3a\u5308\u7259\u5229\u7b97\u6cd5\u3002 \u4ea4\u66ff\u8def\u4e0e\u589e\u5e7f\u8def \u4ea4\u66ff\u8def\uff1a\u4ece\u4e00\u4e2a\u672a\u5339\u914d\u70b9\u51fa\u53d1\uff0c\u4f9d\u6b21\u7ecf\u8fc7\u975e\u5339\u914d\u8fb9\u3001\u5339\u914d\u8fb9\u3001\u975e\u5339\u914d\u8fb9\u2026\u5f62\u6210\u7684\u8def\u5f84\u53eb\u4ea4\u66ff\u8def\u3002 \u589e\u5e7f\u8def\uff1a\u4ece\u4e00\u4e2a\u672a\u5339\u914d\u70b9\u51fa\u53d1\uff0c\u8d70\u4ea4\u66ff\u8def\uff0c\u5982\u679c\u9014\u5f84\u53e6\u4e00\u4e2a\u672a\u5339\u914d\u70b9\uff08\u51fa\u53d1\u7684\u70b9\u4e0d\u7b97\uff09\uff0c\u5219\u8fd9\u6761\u4ea4\u66ff\u8def\u79f0\u4e3a\u589e\u5e7f\u8def\uff08agumenting path\uff09 \u589e\u5e7f\u8def\u6709\u4e00\u4e2a\u91cd\u8981\u7279\u70b9\uff1a\u975e\u5339\u914d\u8fb9\u6bd4\u5339\u914d\u8fb9\u591a\u4e00\u6761\u3002\u56e0\u6b64\uff0c\u7814\u7a76\u589e\u5e7f\u8def\u7684\u610f\u4e49\u662f\u6539\u8fdb\u5339\u914d\u3002\u53ea\u8981\u628a\u589e\u5e7f\u8def\u4e2d\u7684\u5339\u914d\u8fb9\u548c\u975e\u5339\u914d\u8fb9\u7684\u8eab\u4efd\u4ea4\u6362\u5373\u53ef\u3002\u7531\u4e8e\u4e2d\u95f4\u7684\u5339\u914d\u8282\u70b9\u4e0d\u5b58\u5728\u5176\u4ed6\u76f8\u8fde\u7684\u5339\u914d\u8fb9\uff0c\u6240\u4ee5\u8fd9\u6837\u505a\u4e0d\u4f1a\u7834\u574f\u5339\u914d\u7684\u6027\u8d28\u3002\u4ea4\u6362\u540e\uff0c\u56fe\u4e2d\u7684\u5339\u914d\u8fb9\u6570\u76ee\u6bd4\u539f\u6765\u591a\u4e86 1 1 \u6761\u3002 \u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u4e0d\u505c\u5730\u627e\u589e\u5e7f\u8def\u6765\u589e\u52a0\u5339\u914d\u4e2d\u7684\u5339\u914d\u8fb9\u548c\u5339\u914d\u70b9\u3002\u627e\u4e0d\u5230\u589e\u5e7f\u8def\u65f6\uff0c\u8fbe\u5230\u6700\u5927\u5339\u914d\uff08\u8fd9\u662f\u589e\u5e7f\u8def\u5b9a\u7406\uff09\u3002\u5308\u7259\u5229\u7b97\u6cd5\u6b63\u662f\u8fd9\u4e48\u505a\u7684\u3002 \u4ee3\u7801 class Match { public : Match ( int _n , int _m ) : n ( _n ), m ( _m ) { assert ( 0 <= n && 0 <= m ); g . resize ( n ); } void Add ( int from , int to ) { assert ( 0 <= from && from <= n && 0 <= to && to <= m ); g [ from ]. push_back ( to ); } int MaxMatchNum () { int res = 0 , iter = 0 ; vector < int > pa ( n , - 1 ), pb ( m , - 1 ), was ( n , 0 ); while ( 1 ) { iter ++ ; int add = 0 ; function < bool ( int ) > Dfs = [ & ]( int v ) { // Find an augmenting path starting from v was [ v ] = iter ; for ( int u : g [ v ]) if ( pb [ u ] == - 1 ) { pa [ v ] = u ; pb [ u ] = v ; return true ; } for ( int u : g [ v ]) if ( was [ pb [ u ]] != iter && Dfs ( pb [ u ])) { pa [ v ] = u ; pb [ u ] = v ; return true ; } return false ; }; for ( int i = 0 ; i < n ; i ++ ) if ( pa [ i ] == - 1 && Dfs ( i )) add ++ ; if ( add == 0 ) break ; res += add ; } return res ; } private : int n , m ; vector < vector < int >> g ; }; n, m n, m - \u4e8c\u5206\u56fe\u4e24\u4e2a\u4e92\u4e0d\u76f8\u4ea4\u9876\u70b9\u96c6\u7684\u9876\u70b9\u6570 g g - \u4e8c\u5206\u56fe res res - \u5f53\u524d\u5339\u914d\u6570 pa pa - A A \u4e2d\u9876\u70b9\u7684\u5339\u914d\u5bf9\u8c61\uff0c\u5931\u914d\u4e3a -1 -1 pb pb - B B \u4e2d\u9876\u70b9\u7684\u5339\u914d\u5bf9\u8c61\uff0c\u5931\u914d\u4e3a -1 -1 iter iter - \u5f53\u524d\u8fed\u4ee3\u6b21\u6570 was was - A A \u4e2d\u9876\u70b9\u6700\u8fd1\u88ab\u4fee\u6539\u7684\u8fed\u4ee3\u8f6e\u6b21\uff08\u5b9e\u73b0\u4e2d\u914d\u5408 iter iter \u7528\u4e8e\u5bfb\u627e\u5f53\u524d\u8f6e\u6b21\u4e2d\u672a\u88ab\u4fee\u6539\u7684\u70b9\uff0c\u907f\u514d\u589e\u5e7f\u8def\u627e\u5230\u5df2\u7ecf\u88ab\u6539\u53d8\u7684\u70b9\u4e0a\uff09 \u8ba8\u8bba Q: \u4e0a\u8ff0\u5b9e\u73b0\u4e2d\u6bcf\u6b21\u8fed\u4ee3\u90fd\u4ece\u5de6\u4fa7\u5f00\u59cb\u5bfb\u627e\u589e\u5e7f\u8def\uff0c\u8fd9\u6837\u6709\u6ca1\u6709\u53ef\u80fd\u6f0f\u6389\u4ece\u53f3\u4fa7\u5f00\u59cb\u7684\u589e\u5e7f\u8def\u5462\uff1f A: \u4e0d\u4f1a\uff0c\u56e0\u4e3a\u589e\u5e7f\u8def\u7684\u957f\u5ea6\u5fc5\u7136\u662f\u5947\u6570\u8df3\uff0c\u8fd9\u5bfc\u81f4\u8d77\u70b9\u7ec8\u70b9\u5fc5\u7136\u4f4d\u4e8e\u5206\u522b\u4f4d\u4e8e\u5de6\u53f3\u4e24\u4fa7\uff0c\u7531\u4e8c\u5206\u56fe\u7684\u65e0\u5411\u6027\uff0c\u4e0d\u59a8\u53d6\u5de6\u4fa7\u70b9\u4e3a\u8d77\u70b9\u3002","title":"\u4e8c\u5206\u56fe\u5339\u914d"},{"location":"competitive_programming/graph_theory/bipartite_matching/#_1","text":"\u672c\u9875\u9762\u90e8\u5206\u5b9a\u4e49\u5f15\u81ea\u672c\u79d1\u540c\u5b66renfei\u7684 \u4e2a\u4eba\u535a\u5ba2 \u3002","title":"\u4e8c\u5206\u56fe\u5339\u914d"},{"location":"competitive_programming/graph_theory/bipartite_matching/#_2","text":"\u7ed9\u5b9a\u4e8c\u5206\u56fe\uff0c\u6c42\u89e3\u5176\u6700\u5927\u5339\u914d\u7684\u5339\u914d\u8fb9\u6570","title":"\u95ee\u9898\uff08\u6700\u5927\u4e8c\u5206\u5339\u914d\uff09"},{"location":"competitive_programming/graph_theory/bipartite_matching/#_3","text":"\u4e8c\u5206\u56fe G=(V,E) G=(V,E) \u662f\u4e00\u4e2a\u65e0\u5411\u56fe\uff0c\u5176\u9876\u70b9\u96c6 V V \u53ef\u5206\u89e3\u4e3a\u4e24\u4e2a\u4e92\u4e0d\u76f8\u4ea4\u7684\u5b50\u96c6 A, B A, B \uff0c\u5bf9 \\forall e=(a, b) \\in E \\forall e=(a, b) \\in E \u6709 a \\in A, b \\in B a \\in A, b \\in B","title":"\u4e8c\u5206\u56fe"},{"location":"competitive_programming/graph_theory/bipartite_matching/#_4","text":"\u5728\u56fe\u8bba\u4e2d\uff0c\u4e00\u4e2a\u300c\u5339\u914d\u300d\uff08matching\uff09\u662f\u4e00\u4e2a\u8fb9\u7684\u96c6\u5408\uff0c\u5176\u4e2d\u4efb\u610f\u4e24\u6761\u8fb9\u90fd\u6ca1\u6709\u516c\u5171\u9876\u70b9\u3002 \u6700\u5927\u5339\u914d\uff1a\u4e00\u4e2a\u56fe\u7684\u6240\u6709\u5339\u914d\u4e2d\uff0c\u6240\u542b\u5339\u914d\u53d8\u6570\u6700\u591a\u7684\u5339\u914d\uff0c\u5219\u79f0\u5176\u4e3a\u4e00\u4e2a\u6700\u5927\u5339\u914d \u5b8c\u7f8e\u5339\u914d\uff1a\u5982\u679c\u4e00\u4e2a\u56fe\u7684\u6240\u6709\u5339\u914d\u4e2d\uff0c\u6240\u6709\u9876\u70b9\u90fd\u662f\u5339\u914d\u70b9\uff0c\u5219\u79f0\u5176\u4e3a\u4e00\u4e2a\u5b8c\u7f8e\u5339\u914d","title":"\u5339\u914d"},{"location":"competitive_programming/graph_theory/bipartite_matching/#_5","text":"\u4e8c\u5206\u56fe\u7684\u6700\u5927\u5339\u914d\u95ee\u9898\u5728CLRS\u7684\u89e3\u6cd5\u662f\u7531\u6700\u5927\u7f51\u7edc\u6d41\u7684\u7b97\u6cd5\u89c4\u7ea6\u5f97\u5230\u3002\u4f46\u4e00\u79cd\u66f4\u7b80\u4fbf\u7684\u65b9\u5f0f\u662f\u901a\u8fc7\u4e0d\u65ad\u5bfb\u627e \u589e\u5e7f\u8def \u7684\u65b9\u5f0f\u5f97\u5230\uff0c\u8fd9\u79cd\u6c42\u6700\u5927\u5339\u914d\u7684\u7b97\u6cd5\u88ab\u79f0\u4e3a\u5308\u7259\u5229\u7b97\u6cd5\u3002","title":"\u7b97\u6cd5"},{"location":"competitive_programming/graph_theory/bipartite_matching/#_6","text":"\u4ea4\u66ff\u8def\uff1a\u4ece\u4e00\u4e2a\u672a\u5339\u914d\u70b9\u51fa\u53d1\uff0c\u4f9d\u6b21\u7ecf\u8fc7\u975e\u5339\u914d\u8fb9\u3001\u5339\u914d\u8fb9\u3001\u975e\u5339\u914d\u8fb9\u2026\u5f62\u6210\u7684\u8def\u5f84\u53eb\u4ea4\u66ff\u8def\u3002 \u589e\u5e7f\u8def\uff1a\u4ece\u4e00\u4e2a\u672a\u5339\u914d\u70b9\u51fa\u53d1\uff0c\u8d70\u4ea4\u66ff\u8def\uff0c\u5982\u679c\u9014\u5f84\u53e6\u4e00\u4e2a\u672a\u5339\u914d\u70b9\uff08\u51fa\u53d1\u7684\u70b9\u4e0d\u7b97\uff09\uff0c\u5219\u8fd9\u6761\u4ea4\u66ff\u8def\u79f0\u4e3a\u589e\u5e7f\u8def\uff08agumenting path\uff09 \u589e\u5e7f\u8def\u6709\u4e00\u4e2a\u91cd\u8981\u7279\u70b9\uff1a\u975e\u5339\u914d\u8fb9\u6bd4\u5339\u914d\u8fb9\u591a\u4e00\u6761\u3002\u56e0\u6b64\uff0c\u7814\u7a76\u589e\u5e7f\u8def\u7684\u610f\u4e49\u662f\u6539\u8fdb\u5339\u914d\u3002\u53ea\u8981\u628a\u589e\u5e7f\u8def\u4e2d\u7684\u5339\u914d\u8fb9\u548c\u975e\u5339\u914d\u8fb9\u7684\u8eab\u4efd\u4ea4\u6362\u5373\u53ef\u3002\u7531\u4e8e\u4e2d\u95f4\u7684\u5339\u914d\u8282\u70b9\u4e0d\u5b58\u5728\u5176\u4ed6\u76f8\u8fde\u7684\u5339\u914d\u8fb9\uff0c\u6240\u4ee5\u8fd9\u6837\u505a\u4e0d\u4f1a\u7834\u574f\u5339\u914d\u7684\u6027\u8d28\u3002\u4ea4\u6362\u540e\uff0c\u56fe\u4e2d\u7684\u5339\u914d\u8fb9\u6570\u76ee\u6bd4\u539f\u6765\u591a\u4e86 1 1 \u6761\u3002 \u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u4e0d\u505c\u5730\u627e\u589e\u5e7f\u8def\u6765\u589e\u52a0\u5339\u914d\u4e2d\u7684\u5339\u914d\u8fb9\u548c\u5339\u914d\u70b9\u3002\u627e\u4e0d\u5230\u589e\u5e7f\u8def\u65f6\uff0c\u8fbe\u5230\u6700\u5927\u5339\u914d\uff08\u8fd9\u662f\u589e\u5e7f\u8def\u5b9a\u7406\uff09\u3002\u5308\u7259\u5229\u7b97\u6cd5\u6b63\u662f\u8fd9\u4e48\u505a\u7684\u3002","title":"\u4ea4\u66ff\u8def\u4e0e\u589e\u5e7f\u8def"},{"location":"competitive_programming/graph_theory/bipartite_matching/#_7","text":"class Match { public : Match ( int _n , int _m ) : n ( _n ), m ( _m ) { assert ( 0 <= n && 0 <= m ); g . resize ( n ); } void Add ( int from , int to ) { assert ( 0 <= from && from <= n && 0 <= to && to <= m ); g [ from ]. push_back ( to ); } int MaxMatchNum () { int res = 0 , iter = 0 ; vector < int > pa ( n , - 1 ), pb ( m , - 1 ), was ( n , 0 ); while ( 1 ) { iter ++ ; int add = 0 ; function < bool ( int ) > Dfs = [ & ]( int v ) { // Find an augmenting path starting from v was [ v ] = iter ; for ( int u : g [ v ]) if ( pb [ u ] == - 1 ) { pa [ v ] = u ; pb [ u ] = v ; return true ; } for ( int u : g [ v ]) if ( was [ pb [ u ]] != iter && Dfs ( pb [ u ])) { pa [ v ] = u ; pb [ u ] = v ; return true ; } return false ; }; for ( int i = 0 ; i < n ; i ++ ) if ( pa [ i ] == - 1 && Dfs ( i )) add ++ ; if ( add == 0 ) break ; res += add ; } return res ; } private : int n , m ; vector < vector < int >> g ; }; n, m n, m - \u4e8c\u5206\u56fe\u4e24\u4e2a\u4e92\u4e0d\u76f8\u4ea4\u9876\u70b9\u96c6\u7684\u9876\u70b9\u6570 g g - \u4e8c\u5206\u56fe res res - \u5f53\u524d\u5339\u914d\u6570 pa pa - A A \u4e2d\u9876\u70b9\u7684\u5339\u914d\u5bf9\u8c61\uff0c\u5931\u914d\u4e3a -1 -1 pb pb - B B \u4e2d\u9876\u70b9\u7684\u5339\u914d\u5bf9\u8c61\uff0c\u5931\u914d\u4e3a -1 -1 iter iter - \u5f53\u524d\u8fed\u4ee3\u6b21\u6570 was was - A A \u4e2d\u9876\u70b9\u6700\u8fd1\u88ab\u4fee\u6539\u7684\u8fed\u4ee3\u8f6e\u6b21\uff08\u5b9e\u73b0\u4e2d\u914d\u5408 iter iter \u7528\u4e8e\u5bfb\u627e\u5f53\u524d\u8f6e\u6b21\u4e2d\u672a\u88ab\u4fee\u6539\u7684\u70b9\uff0c\u907f\u514d\u589e\u5e7f\u8def\u627e\u5230\u5df2\u7ecf\u88ab\u6539\u53d8\u7684\u70b9\u4e0a\uff09","title":"\u4ee3\u7801"},{"location":"competitive_programming/graph_theory/bipartite_matching/#_8","text":"Q: \u4e0a\u8ff0\u5b9e\u73b0\u4e2d\u6bcf\u6b21\u8fed\u4ee3\u90fd\u4ece\u5de6\u4fa7\u5f00\u59cb\u5bfb\u627e\u589e\u5e7f\u8def\uff0c\u8fd9\u6837\u6709\u6ca1\u6709\u53ef\u80fd\u6f0f\u6389\u4ece\u53f3\u4fa7\u5f00\u59cb\u7684\u589e\u5e7f\u8def\u5462\uff1f A: \u4e0d\u4f1a\uff0c\u56e0\u4e3a\u589e\u5e7f\u8def\u7684\u957f\u5ea6\u5fc5\u7136\u662f\u5947\u6570\u8df3\uff0c\u8fd9\u5bfc\u81f4\u8d77\u70b9\u7ec8\u70b9\u5fc5\u7136\u4f4d\u4e8e\u5206\u522b\u4f4d\u4e8e\u5de6\u53f3\u4e24\u4fa7\uff0c\u7531\u4e8c\u5206\u56fe\u7684\u65e0\u5411\u6027\uff0c\u4e0d\u59a8\u53d6\u5de6\u4fa7\u70b9\u4e3a\u8d77\u70b9\u3002","title":"\u8ba8\u8bba"},{"location":"competitive_programming/graph_theory/dijkstra/","text":"\u5355\u6e90\u6700\u77ed\u8def \u95ee\u9898 \u7ed9\u5b9a\u5e26\u975e\u8d1f\u6743\u7684\u6709\u5411\u56fe g g \u548c\u6e90\u9876\u70b9 s s \uff0c\u6c42\u4eces\u51fa\u53d1\u5230\u56fe\u4e2d\u6240\u6709\u9876\u70b9\u7684\u6700\u77ed\u8def\u5f84\u957f\u5ea6\u3002 \u4ee3\u7801 #include <bits/stdc++.h> using namespace std ; const int INF = 2e9 ; const int maxn = 10 ; int n ; int g [ maxn ][ maxn ]; bool vis [ maxn ]; int dis [ maxn ]; int pre [ maxn ]; void Dijkstra ( int s ) { for ( int i = 0 ; i < n ; i ++ ) { // Init. dis [ i ] = g [ s ][ i ]; vis [ i ] = i == s ? true : false ; pre [ i ] = dis [ i ] == INF ? - 1 : s ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { // n - 1 steps. int mn = INF ; int u = s ; for ( int j = 0 ; j < n ; j ++ ) // Find the closest vertex u can be reached from s. if ( ! vis [ j ] && dis [ j ] < mn ) u = j , mn = dis [ j ]; vis [ u ] = true ; for ( int j = 0 ; j < n ; j ++ ) // Update distance according to u if ( ! vis [ j ] && g [ u ][ j ] < INF ) if ( dis [ u ] + g [ u ][ j ] < dis [ j ]) dis [ j ] = dis [ u ] + g [ u ][ j ], pre [ j ] = u ; } } g g - \u90bb\u63a5\u77e9\u9635 n n - \u9876\u70b9\u6570\u91cf vis vis - \u5df2\u8bbf\u95ee\u9876\u70b9\u6807\u8bb0\uff08\u5df2\u8bbf\u95ee\u9876\u70b9\u96c6\u5408 U U \uff09 dis dis - \u6e90\u70b9 s s \u5230\u5176\u4ed6\u9876\u70b9\u7684\u6700\u77ed\u8def\u5f84\u957f\u5ea6 pre pre - \u6e90\u70b9 s s \u5230\u5176\u4ed6\u9876\u70b9\u7684\u6700\u77ed\u8def\u5f84\u4e0a\u7684\u524d\u9a71\u7ed3\u70b9\uff08\u7528\u4e8e\u751f\u6210\u5177\u4f53\u8def\u5f84\uff09 \u7b97\u6cd5 Dijkstra\u7b97\u6cd5\u603b\u662f\u9009\u62e9\u5269\u4f59\u70b9\u96c6\u4e2d\u6700\u8fd1\u7684\u9876\u70b9\u52a0\u5165\u5230\u5df2\u8bbf\u95ee\u70b9\u96c6\uff0c\u5c5e\u4e8e\u8d2a\u5fc3\u6cd5\uff0c\u6b32\u8bc1\u660e\u5176\u6b63\u786e\u6027\u5373\u662f\u8bc1\u660e\u8d2a\u5fc3\u8fc7\u7a0b\u6bcf\u4e00\u6b65\u7684\u5c40\u90e8\u6700\u4f18\u5728\u8be5\u95ee\u9898\u4e2d\u5c31\u662f\u5168\u5c40\u6700\u4f18\u89e3\u3002 \u7b97\u6cd5\u4e0a\u8ff0\u5b9e\u73b0\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(|V|^2) O(|V|^2) \uff0c\u9002\u5408\u7a20\u5bc6\u56fe\u3002\u7528\u57fa\u4e8e\u5806\u7ed3\u6784\u7684\u4f18\u5148\u961f\u5217\u7ef4\u62a4\u5df2\u8bbf\u95ee\u70b9\u96c6\u53ef\u4ee5\u8fdb\u4e00\u6b65\u4f18\u5316\u4e4b\u3002\u7b97\u6cd5\u5171 |V| |V| \u6b65\uff0c\u6bcf\u4e00\u6b65\u7684\u590d\u6742\u5ea6\u4e3a \u5bfb\u627e\u6700\u8fd1\u70b9 \u548c \u66f4\u65b0\u8ddd\u79bb \u590d\u6742\u5ea6\u4e4b\u548c\u3002\u6839\u636eCLRS\uff0c\u4e8c\u53c9\u5806\u5b9e\u73b0\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O((V+E)\\log E) O((V+E)\\log E) \uff0c\u6590\u6ce2\u90a3\u5951\u5806\u5b9e\u73b0\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(V\\log V + E) O(V\\log V + E) \u3002","title":"\u5355\u6e90\u6700\u77ed\u8def"},{"location":"competitive_programming/graph_theory/dijkstra/#_1","text":"","title":"\u5355\u6e90\u6700\u77ed\u8def"},{"location":"competitive_programming/graph_theory/dijkstra/#_2","text":"\u7ed9\u5b9a\u5e26\u975e\u8d1f\u6743\u7684\u6709\u5411\u56fe g g \u548c\u6e90\u9876\u70b9 s s \uff0c\u6c42\u4eces\u51fa\u53d1\u5230\u56fe\u4e2d\u6240\u6709\u9876\u70b9\u7684\u6700\u77ed\u8def\u5f84\u957f\u5ea6\u3002","title":"\u95ee\u9898"},{"location":"competitive_programming/graph_theory/dijkstra/#_3","text":"#include <bits/stdc++.h> using namespace std ; const int INF = 2e9 ; const int maxn = 10 ; int n ; int g [ maxn ][ maxn ]; bool vis [ maxn ]; int dis [ maxn ]; int pre [ maxn ]; void Dijkstra ( int s ) { for ( int i = 0 ; i < n ; i ++ ) { // Init. dis [ i ] = g [ s ][ i ]; vis [ i ] = i == s ? true : false ; pre [ i ] = dis [ i ] == INF ? - 1 : s ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { // n - 1 steps. int mn = INF ; int u = s ; for ( int j = 0 ; j < n ; j ++ ) // Find the closest vertex u can be reached from s. if ( ! vis [ j ] && dis [ j ] < mn ) u = j , mn = dis [ j ]; vis [ u ] = true ; for ( int j = 0 ; j < n ; j ++ ) // Update distance according to u if ( ! vis [ j ] && g [ u ][ j ] < INF ) if ( dis [ u ] + g [ u ][ j ] < dis [ j ]) dis [ j ] = dis [ u ] + g [ u ][ j ], pre [ j ] = u ; } } g g - \u90bb\u63a5\u77e9\u9635 n n - \u9876\u70b9\u6570\u91cf vis vis - \u5df2\u8bbf\u95ee\u9876\u70b9\u6807\u8bb0\uff08\u5df2\u8bbf\u95ee\u9876\u70b9\u96c6\u5408 U U \uff09 dis dis - \u6e90\u70b9 s s \u5230\u5176\u4ed6\u9876\u70b9\u7684\u6700\u77ed\u8def\u5f84\u957f\u5ea6 pre pre - \u6e90\u70b9 s s \u5230\u5176\u4ed6\u9876\u70b9\u7684\u6700\u77ed\u8def\u5f84\u4e0a\u7684\u524d\u9a71\u7ed3\u70b9\uff08\u7528\u4e8e\u751f\u6210\u5177\u4f53\u8def\u5f84\uff09","title":"\u4ee3\u7801"},{"location":"competitive_programming/graph_theory/dijkstra/#_4","text":"Dijkstra\u7b97\u6cd5\u603b\u662f\u9009\u62e9\u5269\u4f59\u70b9\u96c6\u4e2d\u6700\u8fd1\u7684\u9876\u70b9\u52a0\u5165\u5230\u5df2\u8bbf\u95ee\u70b9\u96c6\uff0c\u5c5e\u4e8e\u8d2a\u5fc3\u6cd5\uff0c\u6b32\u8bc1\u660e\u5176\u6b63\u786e\u6027\u5373\u662f\u8bc1\u660e\u8d2a\u5fc3\u8fc7\u7a0b\u6bcf\u4e00\u6b65\u7684\u5c40\u90e8\u6700\u4f18\u5728\u8be5\u95ee\u9898\u4e2d\u5c31\u662f\u5168\u5c40\u6700\u4f18\u89e3\u3002 \u7b97\u6cd5\u4e0a\u8ff0\u5b9e\u73b0\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(|V|^2) O(|V|^2) \uff0c\u9002\u5408\u7a20\u5bc6\u56fe\u3002\u7528\u57fa\u4e8e\u5806\u7ed3\u6784\u7684\u4f18\u5148\u961f\u5217\u7ef4\u62a4\u5df2\u8bbf\u95ee\u70b9\u96c6\u53ef\u4ee5\u8fdb\u4e00\u6b65\u4f18\u5316\u4e4b\u3002\u7b97\u6cd5\u5171 |V| |V| \u6b65\uff0c\u6bcf\u4e00\u6b65\u7684\u590d\u6742\u5ea6\u4e3a \u5bfb\u627e\u6700\u8fd1\u70b9 \u548c \u66f4\u65b0\u8ddd\u79bb \u590d\u6742\u5ea6\u4e4b\u548c\u3002\u6839\u636eCLRS\uff0c\u4e8c\u53c9\u5806\u5b9e\u73b0\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O((V+E)\\log E) O((V+E)\\log E) \uff0c\u6590\u6ce2\u90a3\u5951\u5806\u5b9e\u73b0\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(V\\log V + E) O(V\\log V + E) \u3002","title":"\u7b97\u6cd5"},{"location":"competitive_programming/graph_theory/floyd/","text":"\u6240\u6709\u70b9\u5bf9\u95f4\u7684\u6700\u77ed\u8def\u5f84 \u95ee\u9898 \u7ed9\u5b9a\u5e26\u5b9e\u6570\u6743\u7684\u6709\u5411\u56fe g g \uff0c\u6c42\u4efb\u610f\u4e24\u70b9\u4e4b\u95f4\u7684\u6700\u77ed\u8ddd\u79bb \u4ee3\u7801 #include <bits/stdc++.h> using namespace std ; const int INF = 1e9 ; const int maxn = 10 ; int n ; int g [ maxn ][ maxn ]; int d [ maxn ][ maxn ]; int p [ maxn ][ maxn ]; void Floyd () { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) d [ i ][ j ] = g [ i ][ j ], p [ i ][ j ] = - 1 ; for ( int k = 0 ; k < n ; k ++ ) for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( d [ i ][ k ] + d [ k ][ j ] < d [ i ][ j ]) d [ i ][ j ] = d [ i ][ k ] + d [ k ][ j ], p [ i ][ j ] = k ; } g g - \u90bb\u63a5\u77e9\u9635 n n - \u9876\u70b9\u6570\u91cf d d - \u4efb\u610f\u4e24\u70b9\u95f4\u6700\u77ed\u8def\u5f84\u7684\u957f\u5ea6 p p - \u4efb\u610f\u4e24\u70b9\u95f4\u6700\u77ed\u8def\u5f84\u7684\u4e2d\u8f6c\u70b9\uff08\u7528\u4e8e\u751f\u6210\u5177\u4f53\u8def\u5f84\uff09 \u7b97\u6cd5 Floyd\u7b97\u6cd5\u5c5e\u4e8e\u52a8\u6001\u89c4\u5212\uff0c \u91cd\u53e0\u5b50\u95ee\u9898 \u662f\u201c\u53ef\u4ee5\u4f7f\u7528\u524d k k \u4e2a\u9876\u70b9\u4f5c\u4e3a\u4e2d\u8f6c\u70b9\u7684\u6700\u77ed\u8def\u5f84\u201d\u3002","title":"\u6240\u6709\u70b9\u5bf9\u4e4b\u95f4\u6700\u77ed\u8def"},{"location":"competitive_programming/graph_theory/floyd/#_1","text":"","title":"\u6240\u6709\u70b9\u5bf9\u95f4\u7684\u6700\u77ed\u8def\u5f84"},{"location":"competitive_programming/graph_theory/floyd/#_2","text":"\u7ed9\u5b9a\u5e26\u5b9e\u6570\u6743\u7684\u6709\u5411\u56fe g g \uff0c\u6c42\u4efb\u610f\u4e24\u70b9\u4e4b\u95f4\u7684\u6700\u77ed\u8ddd\u79bb","title":"\u95ee\u9898"},{"location":"competitive_programming/graph_theory/floyd/#_3","text":"#include <bits/stdc++.h> using namespace std ; const int INF = 1e9 ; const int maxn = 10 ; int n ; int g [ maxn ][ maxn ]; int d [ maxn ][ maxn ]; int p [ maxn ][ maxn ]; void Floyd () { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) d [ i ][ j ] = g [ i ][ j ], p [ i ][ j ] = - 1 ; for ( int k = 0 ; k < n ; k ++ ) for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( d [ i ][ k ] + d [ k ][ j ] < d [ i ][ j ]) d [ i ][ j ] = d [ i ][ k ] + d [ k ][ j ], p [ i ][ j ] = k ; } g g - \u90bb\u63a5\u77e9\u9635 n n - \u9876\u70b9\u6570\u91cf d d - \u4efb\u610f\u4e24\u70b9\u95f4\u6700\u77ed\u8def\u5f84\u7684\u957f\u5ea6 p p - \u4efb\u610f\u4e24\u70b9\u95f4\u6700\u77ed\u8def\u5f84\u7684\u4e2d\u8f6c\u70b9\uff08\u7528\u4e8e\u751f\u6210\u5177\u4f53\u8def\u5f84\uff09","title":"\u4ee3\u7801"},{"location":"competitive_programming/graph_theory/floyd/#_4","text":"Floyd\u7b97\u6cd5\u5c5e\u4e8e\u52a8\u6001\u89c4\u5212\uff0c \u91cd\u53e0\u5b50\u95ee\u9898 \u662f\u201c\u53ef\u4ee5\u4f7f\u7528\u524d k k \u4e2a\u9876\u70b9\u4f5c\u4e3a\u4e2d\u8f6c\u70b9\u7684\u6700\u77ed\u8def\u5f84\u201d\u3002","title":"\u7b97\u6cd5"},{"location":"competitive_programming/graph_theory/minimum_spanning_tree/","text":"\u6700\u5c0f\u751f\u6210\u6811 \u95ee\u9898 \u7ed9\u5b9a\u65e0\u5411\u8fde\u901a\u56fe g g \uff0c\u627e\u5230\u4e00\u68f5\u751f\u6210\u6811\uff0c\u4f7f\u5f97\u8fb9\u7684\u603b\u6743\u91cd\u6700\u5c0f \u7b97\u6cd5I - Prim \u7ef4\u62a4\u4e00\u4e2aMST\u70b9\u96c6\uff0c\u521d\u59cb\u53ea\u6709\u4efb\u4e00\u70b9\uff08\u4e00\u822c\u53d6\u7f16\u53f7\u4e3a 0 0 \u7684\u70b9\uff09\uff0c\u6bcf\u6b21\u53d6\u6240\u6709\u4e00\u7aef\u5728MST\u70b9\u96c6\u5185\u90e8\u53e6\u4e00\u7aef\u5728MST\u70b9\u96c6\u5916\u90e8\u7684\u8fb9\u4e2d\u6743\u503c\u6700\u5c0f\u7684\u4e00\u6761\uff0c\u5c06\u8be5\u8fb9\u7684\u53e6\u4e00\u7aef\u52a0\u5165MST\u70b9\u96c6\u5e76\u8bb0\u5f55\u8be5\u8fb9\uff0c\u5219\u7ecf\u8fc7 n-1 n-1 \u6b65\u5f97\u5230\u6700\u5c0f\u751f\u6210\u6811\u3002 Prim\u7b97\u6cd5\u5c5e\u4e8e\u8d2a\u5fc3\u6cd5\uff0c\u5176\u6b63\u786e\u6027\u57fa\u4e8eMST\u6027\u8d28\uff1a \u5bf9\u4e8e\u4e00\u9897 \u6b63\u5728\u6784\u9020\u4e2d \u7684\u6700\u5c0f\u751f\u6210\u6811\uff0c\u8bbe U, V U, V \u5206\u522b\u4e3a\u6811\u7684\u9876\u70b9\u96c6\u53ca\u5176\u8865\u96c6\u3002\u82e5\u8fb9 (u, v) (u, v) \u4e3a\u4e00\u7aef\u5728\u5f53\u524d\u70b9\u96c6\u4e2d u \\in U u \\in U \uff0c\u53e6\u4e00\u7aef\u4e0d\u5728\u5f53\u524d\u70b9\u96c6\u4e2d v \\in V v \\in V \uff0c\u4e14\u6743\u91cd\u6700\u5c0f\u7684\u8fb9\uff0c\u5219\u5fc5\u7136\u5b58\u5728\u4e00\u9897\u5305\u542b\u8be5\u8fb9 (u, v) (u, v) \u7684\u6700\u5c0f\u751f\u6210\u6811\u3002 \u4ee3\u7801 #include <bits/stdc++.h> using namespace std ; using ll = long long ; const int maxn = 10 ; const int INF = 2e9 ; int n ; int G [ maxn ][ maxn ]; int NextVertex ( int low_cost [], bool mst_set []) { int mn = INF , mn_idx = - 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( ! mst_set [ i ] && low_cost [ i ] < mn ) mn = low_cost [ i ], mn_idx = i ; return mn_idx ; } ll PrimMST () { int par [ n ]; // Store which inner vertex to connect for outer vertexes. int low_cost [ n ]; // lowest cost for outer vertexes to connect to a inner vertex. bool mst_set [ n ]; // Mark inner vertices. // Initially put the 1st vertex into mst_set. mst_set [ 0 ] = true , par [ 0 ] = - 1 ; for ( int i = 1 ; i < n ; i ++ ) low_cost [ i ] = G [ 0 ][ i ], mst_set [ i ] = false , par [ i ] = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { // There are n - 1 steps to construct MST. int u = NextVertex ( low_cost , mst_set ); mst_set [ u ] = true ; for ( int v = 0 ; v < n ; v ++ ) if ( ! mst_set [ v ] && G [ u ][ v ] < low_cost [ v ]) par [ v ] = u , low_cost [ v ] = G [ u ][ v ]; } ll ans = 0 ; for ( int i = 1 ; i < n ; i ++ ) ans += G [ i ][ par [ i ]]; return ans ; } G G - \u90bb\u63a5\u77e9\u9635 n n - \u9876\u70b9\u6570\u91cf par par - par[i] par[i] \u8868\u793a\u7f16\u53f7\u4e3a i i \u7684\u9876\u70b9\u5728\u88ab\u52a0\u5165MST\u7684\u65f6\u5019\u6240\u8fde\u7684\u6b63\u5728\u751f\u6210\u4e2dMST\u4e0a\u7684\u9876\u70b9\uff08\u7528\u4e8e\u83b7\u53d6\u5177\u4f53\u751f\u6210\u6811\u7684\u8fb9\u96c6\uff0c par[1, n-1] par[1, n-1] \u5373\u4e3a\u6240\u6c42\uff09 low_cost low_cost - \u5f53\u524d\u9636\u6bb5\u6b63\u5728\u751f\u6210\u4e2d\u7684MST\u4e4b\u5916\u7684\u70b9\u5230\u5f53\u524dMST\u7684\u6700\u77ed\u8ddd\u79bb $ mst_set mst_set - \u5c5e\u4e8e\u6b63\u5728\u751f\u6210\u4e2d\u7684MST\u7684\u9876\u70b9\u6807\u8bb0 \u4ee5\u4e0a\u5b9e\u73b0\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(|V|^2) O(|V|^2) \u3002 \u7b97\u6cd52 - Kruskal Kruskal\u7b97\u6cd5\u7684\u601d\u8def\u5f88\u6e05\u6670\uff0c\u5982\u4f7f\u7528\u5e76\u67e5\u96c6\uff0c\u53ef\u5c06\u6b65\u9aa4\u603b\u7ed3\u5982\u4e0b\uff1a \u65b0\u5efa\u56fe G G \uff0c\u56fe G G \u4e2d\u6709\u4e0e\u539f\u56fe\u76f8\u540c\u7684\u9876\u70b9\uff0c\u4f46\u6ca1\u6709\u8fb9\uff1b \u5c06\u539f\u56fe\u4e2d\u6240\u6709\u7684\u8fb9\u6309\u6743\u503c\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\uff1b \u4ece\u6743\u503c\u6700\u5c0f\u7684\u8fb9\u5f00\u59cb\uff0c\u5982\u679c\u8fd9\u4e24\u4e2a\u8fb9\u8fde\u63a5\u7684\u4e24\u4e2a\u9876\u70b9\u5728\u56fe G G \u5185\u4e0d\u5728\u4e00\u4e2a\u8fde\u901a\u5206\u91cf\u4e2d\uff0c\u5219\u6dfb\u52a0\u8fd9\u6761\u8fb9\u5230\u56fe G G \u4e2d\uff1b \u91cd\u590d3\uff0c\u76f4\u5230\u56fe G G \u53ea\u5269\u4e00\u4e2a\u8fde\u901a\u5206\u91cf\u3002 \uff08\u6ce8\uff1a\u8be5\u56fe\u53ea\u5173\u6ce8\u52a8\u6001\u8fde\u901a\u6027\uff0c\u7528\u5e76\u67e5\u96c6\u5b9e\u73b0\u5c31\u597d\u3002\uff09 \u4f18\u5316 \u6839\u636eCLRS\uff0c\u5982\u679c\u4f7f\u7528\u666e\u901a\u4e8c\u53c9\u5806\uff0c\u5219\u53ef\u4ee5\u5c06Prim\u548cKruskal\u7b97\u6cd5\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u9650\u5236\u5728 O(E\\log V) O(E\\log V) \uff0c\u5982\u679c\u4f7f\u7528\u6590\u6ce2\u90a3\u5951\u5806\uff0cPrim\u7b97\u6cd5\u7684\u8fd0\u884c\u65f6\u95f4\u5c06\u6539\u5584\u4e3a O(E+V\\log V) O(E+V\\log V) \u3002\u6b64\u8fd0\u884c\u65f6\u95f4\u5728 |V| \\ll |E| |V| \\ll |E| \uff08\u7a00\u758f\u56fe\uff09 \u7684\u60c5\u51b5\u4e0b\u8f83\u4e8c\u53c9\u5806\u6709\u76f8\u5f53\u5927\u7684\u6539\u8fdb\u3002","title":"\u6700\u5c0f\u751f\u6210\u6811"},{"location":"competitive_programming/graph_theory/minimum_spanning_tree/#_1","text":"","title":"\u6700\u5c0f\u751f\u6210\u6811"},{"location":"competitive_programming/graph_theory/minimum_spanning_tree/#_2","text":"\u7ed9\u5b9a\u65e0\u5411\u8fde\u901a\u56fe g g \uff0c\u627e\u5230\u4e00\u68f5\u751f\u6210\u6811\uff0c\u4f7f\u5f97\u8fb9\u7684\u603b\u6743\u91cd\u6700\u5c0f","title":"\u95ee\u9898"},{"location":"competitive_programming/graph_theory/minimum_spanning_tree/#i-prim","text":"\u7ef4\u62a4\u4e00\u4e2aMST\u70b9\u96c6\uff0c\u521d\u59cb\u53ea\u6709\u4efb\u4e00\u70b9\uff08\u4e00\u822c\u53d6\u7f16\u53f7\u4e3a 0 0 \u7684\u70b9\uff09\uff0c\u6bcf\u6b21\u53d6\u6240\u6709\u4e00\u7aef\u5728MST\u70b9\u96c6\u5185\u90e8\u53e6\u4e00\u7aef\u5728MST\u70b9\u96c6\u5916\u90e8\u7684\u8fb9\u4e2d\u6743\u503c\u6700\u5c0f\u7684\u4e00\u6761\uff0c\u5c06\u8be5\u8fb9\u7684\u53e6\u4e00\u7aef\u52a0\u5165MST\u70b9\u96c6\u5e76\u8bb0\u5f55\u8be5\u8fb9\uff0c\u5219\u7ecf\u8fc7 n-1 n-1 \u6b65\u5f97\u5230\u6700\u5c0f\u751f\u6210\u6811\u3002 Prim\u7b97\u6cd5\u5c5e\u4e8e\u8d2a\u5fc3\u6cd5\uff0c\u5176\u6b63\u786e\u6027\u57fa\u4e8eMST\u6027\u8d28\uff1a \u5bf9\u4e8e\u4e00\u9897 \u6b63\u5728\u6784\u9020\u4e2d \u7684\u6700\u5c0f\u751f\u6210\u6811\uff0c\u8bbe U, V U, V \u5206\u522b\u4e3a\u6811\u7684\u9876\u70b9\u96c6\u53ca\u5176\u8865\u96c6\u3002\u82e5\u8fb9 (u, v) (u, v) \u4e3a\u4e00\u7aef\u5728\u5f53\u524d\u70b9\u96c6\u4e2d u \\in U u \\in U \uff0c\u53e6\u4e00\u7aef\u4e0d\u5728\u5f53\u524d\u70b9\u96c6\u4e2d v \\in V v \\in V \uff0c\u4e14\u6743\u91cd\u6700\u5c0f\u7684\u8fb9\uff0c\u5219\u5fc5\u7136\u5b58\u5728\u4e00\u9897\u5305\u542b\u8be5\u8fb9 (u, v) (u, v) \u7684\u6700\u5c0f\u751f\u6210\u6811\u3002","title":"\u7b97\u6cd5I - Prim"},{"location":"competitive_programming/graph_theory/minimum_spanning_tree/#_3","text":"#include <bits/stdc++.h> using namespace std ; using ll = long long ; const int maxn = 10 ; const int INF = 2e9 ; int n ; int G [ maxn ][ maxn ]; int NextVertex ( int low_cost [], bool mst_set []) { int mn = INF , mn_idx = - 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( ! mst_set [ i ] && low_cost [ i ] < mn ) mn = low_cost [ i ], mn_idx = i ; return mn_idx ; } ll PrimMST () { int par [ n ]; // Store which inner vertex to connect for outer vertexes. int low_cost [ n ]; // lowest cost for outer vertexes to connect to a inner vertex. bool mst_set [ n ]; // Mark inner vertices. // Initially put the 1st vertex into mst_set. mst_set [ 0 ] = true , par [ 0 ] = - 1 ; for ( int i = 1 ; i < n ; i ++ ) low_cost [ i ] = G [ 0 ][ i ], mst_set [ i ] = false , par [ i ] = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { // There are n - 1 steps to construct MST. int u = NextVertex ( low_cost , mst_set ); mst_set [ u ] = true ; for ( int v = 0 ; v < n ; v ++ ) if ( ! mst_set [ v ] && G [ u ][ v ] < low_cost [ v ]) par [ v ] = u , low_cost [ v ] = G [ u ][ v ]; } ll ans = 0 ; for ( int i = 1 ; i < n ; i ++ ) ans += G [ i ][ par [ i ]]; return ans ; } G G - \u90bb\u63a5\u77e9\u9635 n n - \u9876\u70b9\u6570\u91cf par par - par[i] par[i] \u8868\u793a\u7f16\u53f7\u4e3a i i \u7684\u9876\u70b9\u5728\u88ab\u52a0\u5165MST\u7684\u65f6\u5019\u6240\u8fde\u7684\u6b63\u5728\u751f\u6210\u4e2dMST\u4e0a\u7684\u9876\u70b9\uff08\u7528\u4e8e\u83b7\u53d6\u5177\u4f53\u751f\u6210\u6811\u7684\u8fb9\u96c6\uff0c par[1, n-1] par[1, n-1] \u5373\u4e3a\u6240\u6c42\uff09 low_cost low_cost - \u5f53\u524d\u9636\u6bb5\u6b63\u5728\u751f\u6210\u4e2d\u7684MST\u4e4b\u5916\u7684\u70b9\u5230\u5f53\u524dMST\u7684\u6700\u77ed\u8ddd\u79bb $ mst_set mst_set - \u5c5e\u4e8e\u6b63\u5728\u751f\u6210\u4e2d\u7684MST\u7684\u9876\u70b9\u6807\u8bb0 \u4ee5\u4e0a\u5b9e\u73b0\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(|V|^2) O(|V|^2) \u3002","title":"\u4ee3\u7801"},{"location":"competitive_programming/graph_theory/minimum_spanning_tree/#2-kruskal","text":"Kruskal\u7b97\u6cd5\u7684\u601d\u8def\u5f88\u6e05\u6670\uff0c\u5982\u4f7f\u7528\u5e76\u67e5\u96c6\uff0c\u53ef\u5c06\u6b65\u9aa4\u603b\u7ed3\u5982\u4e0b\uff1a \u65b0\u5efa\u56fe G G \uff0c\u56fe G G \u4e2d\u6709\u4e0e\u539f\u56fe\u76f8\u540c\u7684\u9876\u70b9\uff0c\u4f46\u6ca1\u6709\u8fb9\uff1b \u5c06\u539f\u56fe\u4e2d\u6240\u6709\u7684\u8fb9\u6309\u6743\u503c\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\uff1b \u4ece\u6743\u503c\u6700\u5c0f\u7684\u8fb9\u5f00\u59cb\uff0c\u5982\u679c\u8fd9\u4e24\u4e2a\u8fb9\u8fde\u63a5\u7684\u4e24\u4e2a\u9876\u70b9\u5728\u56fe G G \u5185\u4e0d\u5728\u4e00\u4e2a\u8fde\u901a\u5206\u91cf\u4e2d\uff0c\u5219\u6dfb\u52a0\u8fd9\u6761\u8fb9\u5230\u56fe G G \u4e2d\uff1b \u91cd\u590d3\uff0c\u76f4\u5230\u56fe G G \u53ea\u5269\u4e00\u4e2a\u8fde\u901a\u5206\u91cf\u3002 \uff08\u6ce8\uff1a\u8be5\u56fe\u53ea\u5173\u6ce8\u52a8\u6001\u8fde\u901a\u6027\uff0c\u7528\u5e76\u67e5\u96c6\u5b9e\u73b0\u5c31\u597d\u3002\uff09","title":"\u7b97\u6cd52 - Kruskal"},{"location":"competitive_programming/graph_theory/minimum_spanning_tree/#_4","text":"\u6839\u636eCLRS\uff0c\u5982\u679c\u4f7f\u7528\u666e\u901a\u4e8c\u53c9\u5806\uff0c\u5219\u53ef\u4ee5\u5c06Prim\u548cKruskal\u7b97\u6cd5\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u9650\u5236\u5728 O(E\\log V) O(E\\log V) \uff0c\u5982\u679c\u4f7f\u7528\u6590\u6ce2\u90a3\u5951\u5806\uff0cPrim\u7b97\u6cd5\u7684\u8fd0\u884c\u65f6\u95f4\u5c06\u6539\u5584\u4e3a O(E+V\\log V) O(E+V\\log V) \u3002\u6b64\u8fd0\u884c\u65f6\u95f4\u5728 |V| \\ll |E| |V| \\ll |E| \uff08\u7a00\u758f\u56fe\uff09 \u7684\u60c5\u51b5\u4e0b\u8f83\u4e8c\u53c9\u5806\u6709\u76f8\u5f53\u5927\u7684\u6539\u8fdb\u3002","title":"\u4f18\u5316"},{"location":"competitive_programming/math/catalan_number/","text":"Catalan number / \u5361\u7279\u5170\u6570 \u95ee\u9898 n n \u5bf9\u62ec\u53f7 () \u6784\u6210\u7684\u5e8f\u5217\uff0c\u6c42\u6ee1\u8db3\u62ec\u53f7\u5408\u6cd5\u5339\u914d\u7684\u6392\u5217\u6570\u91cf\u3002 \u5206\u6790 \u6392\u5217\u7684\u7b2c\u4e00\u4e2a\u5143\u7d20\u4e00\u5b9a\u662f ( \u8bc1\u660e\uff1a\u5982\u679c\u9996\u5143\u662f ) \u5219\u5176\u65e0\u6cd5\u88ab\u5339\u914d \u7ed9\u5b9a\u5408\u6cd5\u6392\u5217\uff0c\u5219\u5339\u914d\u65b9\u5f0f\u552f\u4e00 \u8bbe a_i a_i \u8868\u793a\u7531 i i \u5bf9\u62ec\u53f7\u7ec4\u6210\u7684\u5339\u914d\u6392\u5217\u7684\u6570\u91cf\uff0c\u663e\u7136 a_1 = 1 a_1 = 1 \uff0c\u4ece\u4e0b\u9762\u7684\u9012\u63a8\u5f0f\u5206\u6790\u4e2d\u53ef\u4ee5\u770b\u51fa a_0 a_0 \u8d77\u5230\u4e86\u4e58\u6cd5\u5e7a\u5143\u7684\u4f5c\u7528\uff0c\u6545\u4ee4 a_0 = 1 a_0 = 1 \u3002 \u5bf9\u4e8e\u7531 n n \u5bf9\u62ec\u53f7\u7ec4\u6210\u7684\u6392\u5217\uff0c\u8003\u8651\u4e0e\u9996\u4f4d ( \u5339\u914d\u7684 ) \u7684\u4f4d\u7f6e\uff0c\u5176\u5de6\u53f3\u5404\u6709\u4e00\u4e2a\u957f\u5ea6\u66f4\u77ed\u7684\u5339\u914d\u5e8f\u5217\uff0c\u9012\u63a8\u5f0f\u4e3a a_n = \\sum_{i=0}^{n-1} a_i a_{n - 1 - i} a_n = \\sum_{i=0}^{n-1} a_i a_{n - 1 - i} \u5982\u6b64\u53ef\u4ee5\u5728 O(n^2) O(n^2) \u7684\u65f6\u95f4\u5185\u5f97\u5230\u7ed3\u679c\u3002 Catalan\u6570 \u5728\u8fd9\u4e2a\u95ee\u9898\u4e2d\uff0c\u6570\u5217 {a_1, a_2, ...} {a_1, a_2, ...} \u79f0\u4e3a Catalan\u6570\u5217 \u3002 \u901a\u9879 a_n a_n \u79f0\u4e3a Catalan\u6570 \u901a\u9879\u516c\u5f0f \u4e0a\u8ff0\u9012\u63a8\u5173\u7cfb\u7684\u89e3\u4e3a\uff1a a_0 = a_1 = 1 a_0 = a_1 = 1 a_n = \\frac{C_{2n}^n}{n+1} (n \\geq 2, n \\in \\mathbb{N}_+) a_n = \\frac{C_{2n}^n}{n+1} (n \\geq 2, n \\in \\mathbb{N}_+) \u5173\u4e8e Catalan\u6570 \u7684\u5e38\u89c1\u516c\u5f0f a_n = \\begin{cases} \\sum_{i=1}^{n} a_{i-1} a_{n-i} & n \\geq 2, n \\in \\mathbb{N_{+}}\\ 1 & n = 0, 1 \\end{cases} a_n = \\begin{cases} \\sum_{i=1}^{n} a_{i-1} a_{n-i} & n \\geq 2, n \\in \\mathbb{N_{+}}\\ 1 & n = 0, 1 \\end{cases} a_n = \\frac{a_{n-1} (4n-2)}{n+1} a_n = \\frac{a_{n-1} (4n-2)}{n+1} a_n = C_{2n}^{n} - C_{2n}^{n-1} a_n = C_{2n}^{n} - C_{2n}^{n-1} \u53ef\u7528Catalan\u6570\u5217\u5efa\u6a21\u7684\u95ee\u9898 \u4e70\u7968\u627e\u96f6\uff1a 2n 2n \u4e2a\u4eba\u4e70\u7968\uff0c\u7968\u4ef7 50 50 \uff0c\u5176\u4e2d n n \u4e2a\u4eba\u624b\u4e2d\u63e1\u6709 100 100 \u5143\u949e\u7968\uff0c n n \u4e2a\u4eba\u624b\u4e2d\u63e1\u6709 50 50 \u5143\u949e\u7968\u3002\u5047\u8bbe\u5f00\u59cb\u65f6\u552e\u7968\u5904\u6ca1\u6709\u96f6\u94b1\uff0c\u8bf7\u95ee\u6709\u591a\u5c11\u79cd\u6392\u961f\u65b9\u5f0f\u53ef\u4ee5\u907f\u514d\u51fa\u73b0\u627e\u4e0d\u5f00\u94b1\u7684\u95ee\u9898\uff1f n n \u4e2a\u8282\u70b9\u53ef\u6784\u9020\u591a\u5c11\u4e2a\u4e0d\u540c\u7684\u4e8c\u53c9\u6811 \u591a\u8fb9\u5f62\u5212\u5206\u6210\u4e09\u89d2\u5f62\u7684\u95ee\u9898\uff1a\u6c42\u4e00\u4e2a\u51f8\u591a\u8fb9\u5f62\u533a\u57df\u5212\u5206\u6210\u4e09\u89d2\u5f62\u533a\u57df\u7684\u65b9\u6cd5\u6570 \u7c7b\u4f3c\u9898\u76ee\uff1a\u5706\u4e0a\u7684 2n 2n \u4e2a\u70b9\uff0c\u6210\u5bf9\u8fde\u63a5\u5f97\u5230 n n \u6761\u7ebf\u6bb5\u4e0d\u60f3\u4ea4\uff0c\u6c42\u53ef\u884c\u7684\u65b9\u6cd5\u6570 \u8def\u5f84\u8ba1\u6570\u95ee\u9898\uff1a \u8003\u8651\u975e\u964d\u8def\u5f84 \u4ece (0, 0) (0, 0) \u5230 (m, n) (m, n) \u7684\u975e\u964d\u8def\u5f84\u6570\u7b49\u4e8e m m \u4e2a x x \u548c n n \u4e2a y y \u7684\u6392\u5217\u6570\uff0c\u5373 C_{n + m}^m C_{n + m}^m \u4ece 0, 0 0, 0 \u5230 n, n n, n \u7684\u9664\u7aef\u70b9\u5916\u4e0d\u63a5\u89e6\u76f4\u7ebf y = x y = x \u7684\u975e\u964d\u8def\u5f84\u6570\uff1a \u5148\u8003\u8651 y=x y=x \u4e0b\u65b9\u7684\u8def\u5f84\uff0c\u90fd\u662f\u4ece (0, 0) (0, 0) \u51fa\u53d1\uff0c\u7ecf\u8fc7 (1, 0) (1, 0) \u53ca (n, n-1) (n, n-1) \u5230 (n,n) (n,n) \uff0c\u53ef\u4ee5\u770b\u505a\u662f (1,0) (1,0) \u5230 (n,n-1) (n,n-1) \u4e0d\u63a5\u89e6 y=x y=x \u7684\u975e\u964d\u8def\u5f84\u6570\u3002 \u6240\u6709\u7684\u7684\u975e\u964d\u8def\u5f84\u6709 C_{2n-2}^{n-1} C_{2n-2}^{n-1} \u6761\u3002\u5bf9\u4e8e\u8fd9\u91cc\u9762\u4efb\u610f\u4e00\u6761\u63a5\u89e6\u4e86 y=x y=x \u7684\u8def\u5f84\uff0c\u53ef\u4ee5\u628a\u5b83\u6700\u540e\u79bb\u5f00\u8fd9\u6761\u7ebf\u7684\u70b9\u5230 (1,0) (1,0) \u4e4b\u95f4\u7684\u90e8\u5206\u5173\u4e8e y=x y=x \u5bf9\u79f0\u53d8\u6362\uff0c\u5c31\u5f97\u5230\u4ece (0,1) (0,1) \u5230 (n,n-1) (n,n-1) \u7684\u4e00\u6761\u975e\u964d\u8def\u5f84\u3002\u53cd\u4e4b\u4e5f\u6210\u7acb\u3002\u4ece\u800c y=x y=x \u4e0b\u65b9\u7684\u975e\u964d\u8def\u5f84\u6570\u662f C_{2n-2}^{n-1} - C_{2n-2}^n C_{2n-2}^{n-1} - C_{2n-2}^n \u3002\u6839\u636e\u5bf9\u79f0\u6027\u53ef\u77e5\u6240\u6c42\u7b54\u6848\u4e3a 2(C_{2n-2}^{n-1} - C_{2n-2}^n) 2(C_{2n-2}^{n-1} - C_{2n-2}^n) \u3002","title":"\u5361\u7279\u5170\u6570"},{"location":"competitive_programming/math/catalan_number/#catalan-number","text":"","title":"Catalan number / \u5361\u7279\u5170\u6570"},{"location":"competitive_programming/math/catalan_number/#_1","text":"n n \u5bf9\u62ec\u53f7 () \u6784\u6210\u7684\u5e8f\u5217\uff0c\u6c42\u6ee1\u8db3\u62ec\u53f7\u5408\u6cd5\u5339\u914d\u7684\u6392\u5217\u6570\u91cf\u3002","title":"\u95ee\u9898"},{"location":"competitive_programming/math/catalan_number/#_2","text":"\u6392\u5217\u7684\u7b2c\u4e00\u4e2a\u5143\u7d20\u4e00\u5b9a\u662f ( \u8bc1\u660e\uff1a\u5982\u679c\u9996\u5143\u662f ) \u5219\u5176\u65e0\u6cd5\u88ab\u5339\u914d \u7ed9\u5b9a\u5408\u6cd5\u6392\u5217\uff0c\u5219\u5339\u914d\u65b9\u5f0f\u552f\u4e00 \u8bbe a_i a_i \u8868\u793a\u7531 i i \u5bf9\u62ec\u53f7\u7ec4\u6210\u7684\u5339\u914d\u6392\u5217\u7684\u6570\u91cf\uff0c\u663e\u7136 a_1 = 1 a_1 = 1 \uff0c\u4ece\u4e0b\u9762\u7684\u9012\u63a8\u5f0f\u5206\u6790\u4e2d\u53ef\u4ee5\u770b\u51fa a_0 a_0 \u8d77\u5230\u4e86\u4e58\u6cd5\u5e7a\u5143\u7684\u4f5c\u7528\uff0c\u6545\u4ee4 a_0 = 1 a_0 = 1 \u3002 \u5bf9\u4e8e\u7531 n n \u5bf9\u62ec\u53f7\u7ec4\u6210\u7684\u6392\u5217\uff0c\u8003\u8651\u4e0e\u9996\u4f4d ( \u5339\u914d\u7684 ) \u7684\u4f4d\u7f6e\uff0c\u5176\u5de6\u53f3\u5404\u6709\u4e00\u4e2a\u957f\u5ea6\u66f4\u77ed\u7684\u5339\u914d\u5e8f\u5217\uff0c\u9012\u63a8\u5f0f\u4e3a a_n = \\sum_{i=0}^{n-1} a_i a_{n - 1 - i} a_n = \\sum_{i=0}^{n-1} a_i a_{n - 1 - i} \u5982\u6b64\u53ef\u4ee5\u5728 O(n^2) O(n^2) \u7684\u65f6\u95f4\u5185\u5f97\u5230\u7ed3\u679c\u3002","title":"\u5206\u6790"},{"location":"competitive_programming/math/catalan_number/#catalan","text":"\u5728\u8fd9\u4e2a\u95ee\u9898\u4e2d\uff0c\u6570\u5217 {a_1, a_2, ...} {a_1, a_2, ...} \u79f0\u4e3a Catalan\u6570\u5217 \u3002 \u901a\u9879 a_n a_n \u79f0\u4e3a Catalan\u6570","title":"Catalan\u6570"},{"location":"competitive_programming/math/catalan_number/#_3","text":"\u4e0a\u8ff0\u9012\u63a8\u5173\u7cfb\u7684\u89e3\u4e3a\uff1a a_0 = a_1 = 1 a_0 = a_1 = 1 a_n = \\frac{C_{2n}^n}{n+1} (n \\geq 2, n \\in \\mathbb{N}_+) a_n = \\frac{C_{2n}^n}{n+1} (n \\geq 2, n \\in \\mathbb{N}_+)","title":"\u901a\u9879\u516c\u5f0f"},{"location":"competitive_programming/math/catalan_number/#catalan_1","text":"a_n = \\begin{cases} \\sum_{i=1}^{n} a_{i-1} a_{n-i} & n \\geq 2, n \\in \\mathbb{N_{+}}\\ 1 & n = 0, 1 \\end{cases} a_n = \\begin{cases} \\sum_{i=1}^{n} a_{i-1} a_{n-i} & n \\geq 2, n \\in \\mathbb{N_{+}}\\ 1 & n = 0, 1 \\end{cases} a_n = \\frac{a_{n-1} (4n-2)}{n+1} a_n = \\frac{a_{n-1} (4n-2)}{n+1} a_n = C_{2n}^{n} - C_{2n}^{n-1} a_n = C_{2n}^{n} - C_{2n}^{n-1}","title":"\u5173\u4e8e Catalan\u6570 \u7684\u5e38\u89c1\u516c\u5f0f"},{"location":"competitive_programming/math/catalan_number/#catalan_2","text":"\u4e70\u7968\u627e\u96f6\uff1a 2n 2n \u4e2a\u4eba\u4e70\u7968\uff0c\u7968\u4ef7 50 50 \uff0c\u5176\u4e2d n n \u4e2a\u4eba\u624b\u4e2d\u63e1\u6709 100 100 \u5143\u949e\u7968\uff0c n n \u4e2a\u4eba\u624b\u4e2d\u63e1\u6709 50 50 \u5143\u949e\u7968\u3002\u5047\u8bbe\u5f00\u59cb\u65f6\u552e\u7968\u5904\u6ca1\u6709\u96f6\u94b1\uff0c\u8bf7\u95ee\u6709\u591a\u5c11\u79cd\u6392\u961f\u65b9\u5f0f\u53ef\u4ee5\u907f\u514d\u51fa\u73b0\u627e\u4e0d\u5f00\u94b1\u7684\u95ee\u9898\uff1f n n \u4e2a\u8282\u70b9\u53ef\u6784\u9020\u591a\u5c11\u4e2a\u4e0d\u540c\u7684\u4e8c\u53c9\u6811 \u591a\u8fb9\u5f62\u5212\u5206\u6210\u4e09\u89d2\u5f62\u7684\u95ee\u9898\uff1a\u6c42\u4e00\u4e2a\u51f8\u591a\u8fb9\u5f62\u533a\u57df\u5212\u5206\u6210\u4e09\u89d2\u5f62\u533a\u57df\u7684\u65b9\u6cd5\u6570 \u7c7b\u4f3c\u9898\u76ee\uff1a\u5706\u4e0a\u7684 2n 2n \u4e2a\u70b9\uff0c\u6210\u5bf9\u8fde\u63a5\u5f97\u5230 n n \u6761\u7ebf\u6bb5\u4e0d\u60f3\u4ea4\uff0c\u6c42\u53ef\u884c\u7684\u65b9\u6cd5\u6570 \u8def\u5f84\u8ba1\u6570\u95ee\u9898\uff1a \u8003\u8651\u975e\u964d\u8def\u5f84 \u4ece (0, 0) (0, 0) \u5230 (m, n) (m, n) \u7684\u975e\u964d\u8def\u5f84\u6570\u7b49\u4e8e m m \u4e2a x x \u548c n n \u4e2a y y \u7684\u6392\u5217\u6570\uff0c\u5373 C_{n + m}^m C_{n + m}^m \u4ece 0, 0 0, 0 \u5230 n, n n, n \u7684\u9664\u7aef\u70b9\u5916\u4e0d\u63a5\u89e6\u76f4\u7ebf y = x y = x \u7684\u975e\u964d\u8def\u5f84\u6570\uff1a \u5148\u8003\u8651 y=x y=x \u4e0b\u65b9\u7684\u8def\u5f84\uff0c\u90fd\u662f\u4ece (0, 0) (0, 0) \u51fa\u53d1\uff0c\u7ecf\u8fc7 (1, 0) (1, 0) \u53ca (n, n-1) (n, n-1) \u5230 (n,n) (n,n) \uff0c\u53ef\u4ee5\u770b\u505a\u662f (1,0) (1,0) \u5230 (n,n-1) (n,n-1) \u4e0d\u63a5\u89e6 y=x y=x \u7684\u975e\u964d\u8def\u5f84\u6570\u3002 \u6240\u6709\u7684\u7684\u975e\u964d\u8def\u5f84\u6709 C_{2n-2}^{n-1} C_{2n-2}^{n-1} \u6761\u3002\u5bf9\u4e8e\u8fd9\u91cc\u9762\u4efb\u610f\u4e00\u6761\u63a5\u89e6\u4e86 y=x y=x \u7684\u8def\u5f84\uff0c\u53ef\u4ee5\u628a\u5b83\u6700\u540e\u79bb\u5f00\u8fd9\u6761\u7ebf\u7684\u70b9\u5230 (1,0) (1,0) \u4e4b\u95f4\u7684\u90e8\u5206\u5173\u4e8e y=x y=x \u5bf9\u79f0\u53d8\u6362\uff0c\u5c31\u5f97\u5230\u4ece (0,1) (0,1) \u5230 (n,n-1) (n,n-1) \u7684\u4e00\u6761\u975e\u964d\u8def\u5f84\u3002\u53cd\u4e4b\u4e5f\u6210\u7acb\u3002\u4ece\u800c y=x y=x \u4e0b\u65b9\u7684\u975e\u964d\u8def\u5f84\u6570\u662f C_{2n-2}^{n-1} - C_{2n-2}^n C_{2n-2}^{n-1} - C_{2n-2}^n \u3002\u6839\u636e\u5bf9\u79f0\u6027\u53ef\u77e5\u6240\u6c42\u7b54\u6848\u4e3a 2(C_{2n-2}^{n-1} - C_{2n-2}^n) 2(C_{2n-2}^{n-1} - C_{2n-2}^n) \u3002","title":"\u53ef\u7528Catalan\u6570\u5217\u5efa\u6a21\u7684\u95ee\u9898"},{"location":"competitive_programming/math/combination/","text":"\u7ec4\u5408\u6570 \u95ee\u9898 \u8bbe\u8ba1\u4e00\u4e2a\u7c7b\uff0c\u63d0\u4f9b\u8ba1\u7b97\u7ec4\u5408\u6570 C_x^y=\\frac{x!}{y!(x-y)!} C_x^y=\\frac{x!}{y!(x-y)!} \u7684\u65b9\u6cd5\uff0c\u7ed3\u679c\u5bf9 10^9 + 7 10^9 + 7 \u53d6\u6a21 \u4ee3\u7801 \u4ee5\u4e0b Combination \u63d0\u4f9b int C(int x, int y) \u65b9\u6cd5\u8ba1\u7b97\u7ec4\u5408\u6570 C_x^y C_x^y \u9ed8\u8ba4\u6784\u9020\u51fd\u6570\u8981\u6c42 0 \\leq y \\leq x \\leq 2e5 0 \\leq y \\leq x \\leq 2e5 \uff0c\u5e76\u63d0\u4f9b\u4e86\u4fee\u6539\u4e0a\u9650\u7684\u6784\u9020\u51fd\u6570\u3002 class Combination { public : Combination () { PreProcess (); } Combination ( int _mx ) : mx ( _mx ) { PreProcess (); } int C ( int x , int y ) { // Choose y from x. assert ( 0 <= y ), assert ( y <= x ), assert ( x <= mx ); return 1ll * fac [ x ] * facinv [ y ] % mod * facinv [ x - y ] % mod ; } private : int mx = 2e5 ; int mod = 1e9 + 7 ; vector < int > fac , facinv ; int qpower ( int a , int b ) { int ans = 1 ; while ( b ) { if ( b & 1 ) ans = 1ll * ans * a % mod ; a = 1ll * a * a % mod ; b >>= 1 ; } return ans ; } void PreProcess () { fac . resize ( mx + 1 ), facinv . resize ( mx + 1 ); fac [ 0 ] = 1 ; for ( int i = 1 ; i <= mx ; i ++ ) { fac [ i ] = 1ll * fac [ i - 1 ] * i % mod ; } facinv [ mx ] = qpower ( fac [ mx ], mod - 2 ); for ( int i = mx - 1 ; i >= 0 ; i -- ) { facinv [ i ] = 1ll * facinv [ i + 1 ] * ( i + 1 ) % mod ; } } }; \u7b97\u6cd5 \u6839\u636e\u7ec4\u5408\u6570\u8ba1\u7b97\u5f0f C_x^y=\\frac{x!}{y!(x-y)!} C_x^y=\\frac{x!}{y!(x-y)!} \uff0c\u95ee\u9898\u7684\u5173\u952e\u5728\u4e8e\u9884\u5904\u7406\u6c42\u51fa x \\in [0, x_{max}] x \\in [0, x_{max}] \u8303\u56f4\u5185\u6240\u6709\u6570\u7684\u9636\u4e58 x! x! \u548c\u9636\u4e58\u7684\u4e58\u6cd5\u9006\u5143 (x!)^{-1} (x!)^{-1} \u3002 \u663e\u7136\uff0c\u9636\u4e58\u8868 x! x! \u53ef\u4ee5\u5728 O(n) O(n) \u65f6\u95f4\u5185\u5f97\u5230\u3002 \u4e0b\u9762\u6c42\u9636\u4e58\u8868\u7684\u9006\u5143\u8868\uff1a \u7531 ((x - 1)!)^{-1} = (x!)^{-1} \\cdot x ((x - 1)!)^{-1} = (x!)^{-1} \\cdot x \u53ef\u77e5\u9636\u4e58\u9006\u5143\u8868\u53ef\u964d\u5e8f\u751f\u6210\uff0c\u90a3\u4e48\u5982\u4f55\u83b7\u5f97\u521d\u59cb\u503c (x_{max}!)^{-1} (x_{max}!)^{-1} \u5462\uff1f \u6839\u636e\u8d39\u9a6c\u5c0f\u5b9a\u7406\uff1a a^{p-1} \\equiv 1 \\pmod p a^{p-1} \\equiv 1 \\pmod p \u53ef\u5f97 a \\cdot a^{p-2} \\equiv 1 \\pmod p a \\cdot a^{p-2} \\equiv 1 \\pmod p \u7531\u4e0a\u5f0f\u53ef\u77e5 a^{p-2} a^{p-2} \u53ef\u4f5c\u4e3a a a \u5728 \\pmod p \\pmod p \u610f\u4e49\u4e0b\u7684\u4e58\u6cd5\u9006\u5143\u3002 \u5373 (x_{max}!)^{-1} = (x_{max}!)^{p-2} \\pmod p (x_{max}!)^{-1} = (x_{max}!)^{p-2} \\pmod p","title":"\u7ec4\u5408\u6570"},{"location":"competitive_programming/math/combination/#_1","text":"","title":"\u7ec4\u5408\u6570"},{"location":"competitive_programming/math/combination/#_2","text":"\u8bbe\u8ba1\u4e00\u4e2a\u7c7b\uff0c\u63d0\u4f9b\u8ba1\u7b97\u7ec4\u5408\u6570 C_x^y=\\frac{x!}{y!(x-y)!} C_x^y=\\frac{x!}{y!(x-y)!} \u7684\u65b9\u6cd5\uff0c\u7ed3\u679c\u5bf9 10^9 + 7 10^9 + 7 \u53d6\u6a21","title":"\u95ee\u9898"},{"location":"competitive_programming/math/combination/#_3","text":"\u4ee5\u4e0b Combination \u63d0\u4f9b int C(int x, int y) \u65b9\u6cd5\u8ba1\u7b97\u7ec4\u5408\u6570 C_x^y C_x^y \u9ed8\u8ba4\u6784\u9020\u51fd\u6570\u8981\u6c42 0 \\leq y \\leq x \\leq 2e5 0 \\leq y \\leq x \\leq 2e5 \uff0c\u5e76\u63d0\u4f9b\u4e86\u4fee\u6539\u4e0a\u9650\u7684\u6784\u9020\u51fd\u6570\u3002 class Combination { public : Combination () { PreProcess (); } Combination ( int _mx ) : mx ( _mx ) { PreProcess (); } int C ( int x , int y ) { // Choose y from x. assert ( 0 <= y ), assert ( y <= x ), assert ( x <= mx ); return 1ll * fac [ x ] * facinv [ y ] % mod * facinv [ x - y ] % mod ; } private : int mx = 2e5 ; int mod = 1e9 + 7 ; vector < int > fac , facinv ; int qpower ( int a , int b ) { int ans = 1 ; while ( b ) { if ( b & 1 ) ans = 1ll * ans * a % mod ; a = 1ll * a * a % mod ; b >>= 1 ; } return ans ; } void PreProcess () { fac . resize ( mx + 1 ), facinv . resize ( mx + 1 ); fac [ 0 ] = 1 ; for ( int i = 1 ; i <= mx ; i ++ ) { fac [ i ] = 1ll * fac [ i - 1 ] * i % mod ; } facinv [ mx ] = qpower ( fac [ mx ], mod - 2 ); for ( int i = mx - 1 ; i >= 0 ; i -- ) { facinv [ i ] = 1ll * facinv [ i + 1 ] * ( i + 1 ) % mod ; } } };","title":"\u4ee3\u7801"},{"location":"competitive_programming/math/combination/#_4","text":"\u6839\u636e\u7ec4\u5408\u6570\u8ba1\u7b97\u5f0f C_x^y=\\frac{x!}{y!(x-y)!} C_x^y=\\frac{x!}{y!(x-y)!} \uff0c\u95ee\u9898\u7684\u5173\u952e\u5728\u4e8e\u9884\u5904\u7406\u6c42\u51fa x \\in [0, x_{max}] x \\in [0, x_{max}] \u8303\u56f4\u5185\u6240\u6709\u6570\u7684\u9636\u4e58 x! x! \u548c\u9636\u4e58\u7684\u4e58\u6cd5\u9006\u5143 (x!)^{-1} (x!)^{-1} \u3002 \u663e\u7136\uff0c\u9636\u4e58\u8868 x! x! \u53ef\u4ee5\u5728 O(n) O(n) \u65f6\u95f4\u5185\u5f97\u5230\u3002 \u4e0b\u9762\u6c42\u9636\u4e58\u8868\u7684\u9006\u5143\u8868\uff1a \u7531 ((x - 1)!)^{-1} = (x!)^{-1} \\cdot x ((x - 1)!)^{-1} = (x!)^{-1} \\cdot x \u53ef\u77e5\u9636\u4e58\u9006\u5143\u8868\u53ef\u964d\u5e8f\u751f\u6210\uff0c\u90a3\u4e48\u5982\u4f55\u83b7\u5f97\u521d\u59cb\u503c (x_{max}!)^{-1} (x_{max}!)^{-1} \u5462\uff1f \u6839\u636e\u8d39\u9a6c\u5c0f\u5b9a\u7406\uff1a a^{p-1} \\equiv 1 \\pmod p a^{p-1} \\equiv 1 \\pmod p \u53ef\u5f97 a \\cdot a^{p-2} \\equiv 1 \\pmod p a \\cdot a^{p-2} \\equiv 1 \\pmod p \u7531\u4e0a\u5f0f\u53ef\u77e5 a^{p-2} a^{p-2} \u53ef\u4f5c\u4e3a a a \u5728 \\pmod p \\pmod p \u610f\u4e49\u4e0b\u7684\u4e58\u6cd5\u9006\u5143\u3002 \u5373 (x_{max}!)^{-1} = (x_{max}!)^{p-2} \\pmod p (x_{max}!)^{-1} = (x_{max}!)^{p-2} \\pmod p","title":"\u7b97\u6cd5"},{"location":"competitive_programming/math/eratosthenes/","text":"\u57c3\u62c9\u6258\u8272\u5c3c\u7b5b\u9009\u6cd5 \u95ee\u9898 \u5bfb\u627e n n \u4ee5\u5185\u6240\u6709\u7d20\u6570\u3002 \u7b97\u6cd5 \u521d\u59cb\u5316\u957f\u5ea6\u4e3a n n \u7684\u7a7a\u8868\u672a\u88ab\u6807\u8bb0\uff0c\u4ece 2 2 \u5230 n n \u9012\u589e\uff0c\u82e5\u5f53\u524d\u5143\u7d20\u672a\u88ab\u6807\u8bb0\uff0c\u5219\u8bb0\u5f55\u8be5\u5143\u7d20\u4e3a\u7d20\u6570\uff0c\u5e76\u6807\u8bb0\u8be5\u5143\u7d20\u5728 n n \u4ee5\u5185\u7684\u6240\u6709\u500d\u6570\u4e3a\u5408\u6570\u3002 \u6ce8\u610f\u5230 \u6807\u8bb0\u500d\u6570\u4e3a\u5408\u6570 \u7684\u64cd\u4f5c\u53ea\u5bf9 [2, \\sqrt{n}] [2, \\sqrt{n}] \u8303\u56f4\u5185\u627e\u5230\u7684\u7d20\u6570\u64cd\u4f5c\u5373\u53ef\u3002 \u53ef\u8bc1\u660e\u8be5\u7b97\u6cd5\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n\\log \\log n) O(n\\log \\log n) \u3002 \u4ee3\u7801 const int N = 20 ; bool vis [ N + 5 ]; std :: vector < int > Eratosthenes_sieve () { std :: vector < int > primes ; for ( int i = 2 ; i <= N ; i ++ ) { if ( ! vis [ i ]) primes . push_back ( i ); for ( int j = i * i ; j <= N ; j += i ) if ( ! vis [ j ]) vis [ j ] = true ; } return primes ; } \u5e94\u7528 \u751f\u6210 n n \u4ee5\u5185\u6240\u6709\u6574\u6570\u7684\u6700\u5c0f\u7d20\u56e0\u6570 \u5728\u6807\u8bb0 p p \u7684\u6240\u6709\u500d\u6570\u7684\u8fc7\u7a0b\u4e2d p p \u5373\u4e3a\u6240\u6709\u500d\u6570\u7684\u6700\u5c0f\u7d20\u56e0\u6570\u3002","title":"\u57c3\u62c9\u6258\u8272\u5c3c\u7b5b"},{"location":"competitive_programming/math/eratosthenes/#_1","text":"","title":"\u57c3\u62c9\u6258\u8272\u5c3c\u7b5b\u9009\u6cd5"},{"location":"competitive_programming/math/eratosthenes/#_2","text":"\u5bfb\u627e n n \u4ee5\u5185\u6240\u6709\u7d20\u6570\u3002","title":"\u95ee\u9898"},{"location":"competitive_programming/math/eratosthenes/#_3","text":"\u521d\u59cb\u5316\u957f\u5ea6\u4e3a n n \u7684\u7a7a\u8868\u672a\u88ab\u6807\u8bb0\uff0c\u4ece 2 2 \u5230 n n \u9012\u589e\uff0c\u82e5\u5f53\u524d\u5143\u7d20\u672a\u88ab\u6807\u8bb0\uff0c\u5219\u8bb0\u5f55\u8be5\u5143\u7d20\u4e3a\u7d20\u6570\uff0c\u5e76\u6807\u8bb0\u8be5\u5143\u7d20\u5728 n n \u4ee5\u5185\u7684\u6240\u6709\u500d\u6570\u4e3a\u5408\u6570\u3002 \u6ce8\u610f\u5230 \u6807\u8bb0\u500d\u6570\u4e3a\u5408\u6570 \u7684\u64cd\u4f5c\u53ea\u5bf9 [2, \\sqrt{n}] [2, \\sqrt{n}] \u8303\u56f4\u5185\u627e\u5230\u7684\u7d20\u6570\u64cd\u4f5c\u5373\u53ef\u3002 \u53ef\u8bc1\u660e\u8be5\u7b97\u6cd5\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n\\log \\log n) O(n\\log \\log n) \u3002","title":"\u7b97\u6cd5"},{"location":"competitive_programming/math/eratosthenes/#_4","text":"const int N = 20 ; bool vis [ N + 5 ]; std :: vector < int > Eratosthenes_sieve () { std :: vector < int > primes ; for ( int i = 2 ; i <= N ; i ++ ) { if ( ! vis [ i ]) primes . push_back ( i ); for ( int j = i * i ; j <= N ; j += i ) if ( ! vis [ j ]) vis [ j ] = true ; } return primes ; }","title":"\u4ee3\u7801"},{"location":"competitive_programming/math/eratosthenes/#_5","text":"\u751f\u6210 n n \u4ee5\u5185\u6240\u6709\u6574\u6570\u7684\u6700\u5c0f\u7d20\u56e0\u6570 \u5728\u6807\u8bb0 p p \u7684\u6240\u6709\u500d\u6570\u7684\u8fc7\u7a0b\u4e2d p p \u5373\u4e3a\u6240\u6709\u500d\u6570\u7684\u6700\u5c0f\u7d20\u56e0\u6570\u3002","title":"\u5e94\u7528"},{"location":"competitive_programming/math/greatest_common_devisor/","text":"\u6700\u5927\u516c\u7ea6\u6570 Euclid\u7b97\u6cd5 \u8ba1\u7b97 big big \u548c small small \uff08\u5176\u4e2d small \\leq big small \\leq big \uff09\u7684\u6700\u5927\u516c\u7ea6\u6570 \u53ea\u8981 samll samll \u4e0d\u4e3a 0 0 \u5219\uff1a big\uff0csamll = small\uff0cbig \\pmod {small} big\uff0csamll = small\uff0cbig \\pmod {small} \u5426\u5219\uff1a big big \u4e3a\u6240\u6c42 Euclid\u7b97\u6cd5\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(max(big)) O(max(big)) \u3002 \u4ee3\u7801 \u8fed\u4ee3\u7248 int gcd ( int big , int small ) { int tmp ; while ( small != 0 ) tmp = small , small = big % small , big = small ; return big ; } \u9012\u5f52\u7248 int gcd ( int big , int small ) { if ( small == 0 ) return big ; return gcd ( big % small , small ); }","title":"\u6700\u5927\u516c\u7ea6\u6570"},{"location":"competitive_programming/math/greatest_common_devisor/#_1","text":"","title":"\u6700\u5927\u516c\u7ea6\u6570"},{"location":"competitive_programming/math/greatest_common_devisor/#euclid","text":"\u8ba1\u7b97 big big \u548c small small \uff08\u5176\u4e2d small \\leq big small \\leq big \uff09\u7684\u6700\u5927\u516c\u7ea6\u6570 \u53ea\u8981 samll samll \u4e0d\u4e3a 0 0 \u5219\uff1a big\uff0csamll = small\uff0cbig \\pmod {small} big\uff0csamll = small\uff0cbig \\pmod {small} \u5426\u5219\uff1a big big \u4e3a\u6240\u6c42 Euclid\u7b97\u6cd5\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(max(big)) O(max(big)) \u3002","title":"Euclid\u7b97\u6cd5"},{"location":"competitive_programming/math/greatest_common_devisor/#_2","text":"\u8fed\u4ee3\u7248 int gcd ( int big , int small ) { int tmp ; while ( small != 0 ) tmp = small , small = big % small , big = small ; return big ; } \u9012\u5f52\u7248 int gcd ( int big , int small ) { if ( small == 0 ) return big ; return gcd ( big % small , small ); }","title":"\u4ee3\u7801"},{"location":"competitive_programming/math/inverse/","text":"\u4e58\u6cd5\u9006\u5143 \u95ee\u9898 \u5728 O(n) O(n) \u65f6\u95f4\u5185\u6c42\u51fa 0 0 \u5230 n n \u4e4b\u95f4\u6240\u6709\u6570\u5728 \\pmod p \\pmod p \u610f\u4e49\u4e0b\u7684\u4e58\u6cd5\u9006\u5143\u3002 \u4ee3\u7801 #include <bits/stdc++.h> using namespace std ; using ll = long long ; const int maxn = 1000005 ; const ll MOD = 1000000007 ; ll qpw ( ll a , ll b ) { ll ans = 1 ; while ( b ) { if ( b & 1 ) ans = ans * a % MOD , b -- ; a = a * a % MOD ; b >>= 1 ; } return ans ; } ll inv [ maxn + 1 ]; void pre_process () { inv [ 1 ] = 1 ; for ( int i = 2 ; i <= maxn ; i ++ ) inv [ i ] = ( MOD - MOD / i ) * inv [ MOD % i ] % MOD ; } \u7b97\u6cd5 \u5bf9\u4e8e\u4efb\u610f\u6b63\u6574\u6570 x x \uff0c\u5728 \\pmod p \\pmod p \u610f\u4e49\u4e0b\u7684\u4e58\u6cd5\u9006\u5143\u57fa\u4e8e\u975e\u9a6c\u5c0f\u5b9a\u7406\u53ef\u4ee5\u7528\u5feb\u901f\u5e42\u5728 O(\\log p) O(\\log p) \u7684\u65f6\u95f4\u6c42\u51fa\uff0c\u5373 x^{-1}=x^{p-2} \\pmod {p-2} x^{-1}=x^{p-2} \\pmod {p-2} \u66f4\u8fdb\u4e00\u6b65\uff0c\u5229\u7528 \u52a8\u6001\u89c4\u5212 \u53ef\u4ee5\u5728\u7ebf\u6027\u65f6\u95f4 T(n) T(n) \u751f\u6210\u524d n n \u4e2a\u6b63\u6574\u6570\u7684\u4e58\u6cd5\u9006\u5143\u8868\u3002 \u5bf9\u4e8e x^{-1} \\pmod p x^{-1} \\pmod p \uff0c\u9996\u5148\u5c06 p p \u5206\u6210 x x \u7684\u4f59\u6570\u548c\u500d\u6570\u4e24\u90e8\u5206\uff1a \\begin{align} p &= (p\\%x) + \\lfloor \\frac{p}{x} \\rfloor \\times x \\\\ &= a + bx \\end{align} \\begin{align} p &= (p\\%x) + \\lfloor \\frac{p}{x} \\rfloor \\times x \\\\ &= a + bx \\end{align} \u5176\u4e2d a=p\\%x, b=\\lfloor\\frac{p}{x}\\rfloor a=p\\%x, b=\\lfloor\\frac{p}{x}\\rfloor \u4e8e\u662f\u6709 a + bx \\equiv 0 \\pmod p a + bx \\equiv 0 \\pmod p \u5c06 a a \u79fb\u5230\u53f3\u8fb9\u5e76\u5728\u4e24\u8fb9\u540c\u65f6\u4e58 b^{-1} b^{-1} x \\equiv -b^{-1}a \\pmod p x \\equiv -b^{-1}a \\pmod p \u5bf9\u4e24\u8fb9\u53d6\u9006 x^{-1} = (-b)a^{-1} \\pmod p x^{-1} = (-b)a^{-1} \\pmod p \u5c06 -b=p-\\lfloor\\frac{p}{x}\\rfloor -b=p-\\lfloor\\frac{p}{x}\\rfloor $ \u5e26\u5165\u4e0a\u5f0f\uff0c\u5f97\u5230 x^{-1}=(p-\\lfloor\\frac{p}{x}\\rfloor)(p\\%x) \\pmod p x^{-1}=(p-\\lfloor\\frac{p}{x}\\rfloor)(p\\%x) \\pmod p \u81f3\u6b64\u5f97\u5230\u6700\u4f18\u5b50\u7ed3\u6784\uff0c\u7531\u4e8e (p%x) < x (p%x) < x \uff0c\u6545\u5728\u6c42\u89e3 x^{-1} x^{-1} \u65f6\uff0c (p\\%x)^{-1} (p\\%x)^{-1} \u662f\u5df2\u7ecf\u6c42\u89e3\u8fc7\u7684\u91cd\u53e0\u5b50\u95ee\u9898\uff0c\u53ef\u4ee5\u76f4\u63a5\u5f97\u5230\u7ed3\u679c\u3002","title":"\u4e58\u6cd5\u9006\u5143"},{"location":"competitive_programming/math/inverse/#_1","text":"","title":"\u4e58\u6cd5\u9006\u5143"},{"location":"competitive_programming/math/inverse/#_2","text":"\u5728 O(n) O(n) \u65f6\u95f4\u5185\u6c42\u51fa 0 0 \u5230 n n \u4e4b\u95f4\u6240\u6709\u6570\u5728 \\pmod p \\pmod p \u610f\u4e49\u4e0b\u7684\u4e58\u6cd5\u9006\u5143\u3002","title":"\u95ee\u9898"},{"location":"competitive_programming/math/inverse/#_3","text":"#include <bits/stdc++.h> using namespace std ; using ll = long long ; const int maxn = 1000005 ; const ll MOD = 1000000007 ; ll qpw ( ll a , ll b ) { ll ans = 1 ; while ( b ) { if ( b & 1 ) ans = ans * a % MOD , b -- ; a = a * a % MOD ; b >>= 1 ; } return ans ; } ll inv [ maxn + 1 ]; void pre_process () { inv [ 1 ] = 1 ; for ( int i = 2 ; i <= maxn ; i ++ ) inv [ i ] = ( MOD - MOD / i ) * inv [ MOD % i ] % MOD ; }","title":"\u4ee3\u7801"},{"location":"competitive_programming/math/inverse/#_4","text":"\u5bf9\u4e8e\u4efb\u610f\u6b63\u6574\u6570 x x \uff0c\u5728 \\pmod p \\pmod p \u610f\u4e49\u4e0b\u7684\u4e58\u6cd5\u9006\u5143\u57fa\u4e8e\u975e\u9a6c\u5c0f\u5b9a\u7406\u53ef\u4ee5\u7528\u5feb\u901f\u5e42\u5728 O(\\log p) O(\\log p) \u7684\u65f6\u95f4\u6c42\u51fa\uff0c\u5373 x^{-1}=x^{p-2} \\pmod {p-2} x^{-1}=x^{p-2} \\pmod {p-2} \u66f4\u8fdb\u4e00\u6b65\uff0c\u5229\u7528 \u52a8\u6001\u89c4\u5212 \u53ef\u4ee5\u5728\u7ebf\u6027\u65f6\u95f4 T(n) T(n) \u751f\u6210\u524d n n \u4e2a\u6b63\u6574\u6570\u7684\u4e58\u6cd5\u9006\u5143\u8868\u3002 \u5bf9\u4e8e x^{-1} \\pmod p x^{-1} \\pmod p \uff0c\u9996\u5148\u5c06 p p \u5206\u6210 x x \u7684\u4f59\u6570\u548c\u500d\u6570\u4e24\u90e8\u5206\uff1a \\begin{align} p &= (p\\%x) + \\lfloor \\frac{p}{x} \\rfloor \\times x \\\\ &= a + bx \\end{align} \\begin{align} p &= (p\\%x) + \\lfloor \\frac{p}{x} \\rfloor \\times x \\\\ &= a + bx \\end{align} \u5176\u4e2d a=p\\%x, b=\\lfloor\\frac{p}{x}\\rfloor a=p\\%x, b=\\lfloor\\frac{p}{x}\\rfloor \u4e8e\u662f\u6709 a + bx \\equiv 0 \\pmod p a + bx \\equiv 0 \\pmod p \u5c06 a a \u79fb\u5230\u53f3\u8fb9\u5e76\u5728\u4e24\u8fb9\u540c\u65f6\u4e58 b^{-1} b^{-1} x \\equiv -b^{-1}a \\pmod p x \\equiv -b^{-1}a \\pmod p \u5bf9\u4e24\u8fb9\u53d6\u9006 x^{-1} = (-b)a^{-1} \\pmod p x^{-1} = (-b)a^{-1} \\pmod p \u5c06 -b=p-\\lfloor\\frac{p}{x}\\rfloor -b=p-\\lfloor\\frac{p}{x}\\rfloor $ \u5e26\u5165\u4e0a\u5f0f\uff0c\u5f97\u5230 x^{-1}=(p-\\lfloor\\frac{p}{x}\\rfloor)(p\\%x) \\pmod p x^{-1}=(p-\\lfloor\\frac{p}{x}\\rfloor)(p\\%x) \\pmod p \u81f3\u6b64\u5f97\u5230\u6700\u4f18\u5b50\u7ed3\u6784\uff0c\u7531\u4e8e (p%x) < x (p%x) < x \uff0c\u6545\u5728\u6c42\u89e3 x^{-1} x^{-1} \u65f6\uff0c (p\\%x)^{-1} (p\\%x)^{-1} \u662f\u5df2\u7ecf\u6c42\u89e3\u8fc7\u7684\u91cd\u53e0\u5b50\u95ee\u9898\uff0c\u53ef\u4ee5\u76f4\u63a5\u5f97\u5230\u7ed3\u679c\u3002","title":"\u7b97\u6cd5"},{"location":"competitive_programming/math/quick_power/","text":"\u5feb\u901f\u5e42 \u95ee\u9898 \u5728 O(\\log{b}) O(\\log{b}) \u65f6\u95f4\u5185\u6c42\u5e42\u503c a^b a^b \uff0c\u7ed3\u679c\u5bf9 MOD MOD \u53d6\u4f59\u3002 \u4ee3\u7801 const int MOD = 1000000007 ; int qpw ( int a , int b ) { // Quick power for a^b. int ans = 1 ; while ( b ) { if ( b & 1 ) ans = 1ll * ans * a % MOD ; a = 1ll * a * a % MOD ; b >>= 1 ; } return ans ; }","title":"\u5feb\u901f\u5e42"},{"location":"competitive_programming/math/quick_power/#_1","text":"","title":"\u5feb\u901f\u5e42"},{"location":"competitive_programming/math/quick_power/#_2","text":"\u5728 O(\\log{b}) O(\\log{b}) \u65f6\u95f4\u5185\u6c42\u5e42\u503c a^b a^b \uff0c\u7ed3\u679c\u5bf9 MOD MOD \u53d6\u4f59\u3002","title":"\u95ee\u9898"},{"location":"competitive_programming/math/quick_power/#_3","text":"const int MOD = 1000000007 ; int qpw ( int a , int b ) { // Quick power for a^b. int ans = 1 ; while ( b ) { if ( b & 1 ) ans = 1ll * ans * a % MOD ; a = 1ll * a * a % MOD ; b >>= 1 ; } return ans ; }","title":"\u4ee3\u7801"},{"location":"competitive_programming/string/suffix_automation/","text":"\u540e\u7f00\u81ea\u52a8\u673a \u672c\u8282\u5185\u5bb9\u90e8\u5206\u6765\u81ea\u9648\u7acb\u67702012NOI\u51ac\u4ee4\u8425\u8bb2\u7a3f\uff0c\u5728\u6b64\u5bf9\u9648\u7acb\u6770\u5bf9SAM\u6240\u505a\u7684\u603b\u7ed3\u8868\u793a\u611f\u8c22\u3002 \u672c\u8282\u5c06\u4ece\u6027\u8d28\u5206\u6790\u3001\u7ebf\u6027\u65f6\u95f4\u6784\u9020\u7b97\u6cd5\u4e24\u4e2a\u5c42\u9762\u6765\u8ba8\u8bba\u540e\u7f00\u81ea\u52a8\u673a\u3002 SAM\u5206\u6790 \u8bbe\u8981\u5206\u6790\u7684\u5b57\u7b26\u4e32\u4e3a\uff0cSAM\u7684\u672c\u8d28\u662f\u4e00\u4e2a\u589e\u52a0\u4e86\u540e\u7f00\u94fe\u7684DFA\uff08\u6709\u9650\u72b6\u6001\u81ea\u52a8\u673a\uff09\u3002\u5176\u72b6\u6001\u662f\u7684\u6240\u6709\u5b50\u4e32\u7684\u5206\u7ec4\uff0c\u5206\u7ec4\u7684\u4f9d\u636e\u662f\u5b50\u4e32\u7684\u7ed3\u675f\u4f4d\u7f6e\u96c6\u5408\uff08right\u96c6\u5408\uff09\u3002 \u5bf9\u4e8e\u4e00\u4e2a\u72b6\u6001\uff0c\u5176\u6240\u5305\u542b\u7684\u6240\u6709\u5b50\u4e32\u662f\u5176\u4e2d\u6700\u957f\u5b57\u7b26\u4e32\u7684\u4e00\u7cfb\u5217\u957f\u5ea6\u8fde\u7eed\u7684\u540e\u7f00\u3002 \u4e0d\u540c\u72b6\u6001\u5bf9\u5e94\u7684right\u96c6\u5408\u8981\u4e48\u4e0d\u76f8\u4ea4\uff0c\u8981\u4e48\u76f8\u4e92\u771f\u5305\u542b\uff0c\u8fd9\u6761\u6027\u8d28\u4fdd\u8bc1\u4e86\u72b6\u6001\u6570\u662f\u7ebf\u6027\u7684\u3002 \u4e0d\u540c\u72b6\u6001\u5bf9\u5e94\u7684right\u96c6\u5408\u4e4b\u95f4\u7684\u5305\u542b\u5173\u7cfb\u4e2a\u6784\u6210\u4e86\u4e00\u68f5\u6811\u72b6\u7ed3\u6784\uff0c\u5c06\u5176\u79f0\u4e3aparent\u6811\u3002 SAM\u7684\u7ebf\u6027\u6784\u9020\u7b97\u6cd5 \u5bf9\u4e8e\u6bcf\u4e2a\u72b6\u6001 st st \uff0c\u8bb0\u5f55\u5176\u4e2d\u6700\u957f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6 val val \uff0c\u53e6\u5916\u8bb0\u5f55\u5176\u5728 parent parent \u6811\u4e0a\u7684\u7236\u4eb2\u5730\u5740\uff0c\u4ee5\u53ca\u5176\u5728 DFA DFA \u4e2d\u7684\u8f6c\u79fb\u8fb9\u3002\u5219\u5176\u4e2d\u5305\u542b\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u533a\u95f4\u4e3a [st \\rightarrow par \\rightarrow val, st \\rightarrow val] [st \\rightarrow par \\rightarrow val, st \\rightarrow val] \u3002\u91c7\u7528\u5982\u4e0b\u589e\u91cf\u6cd5\u5728\u7ebf\u6784\u9020\uff1a \u4ee4\u5f53\u524d\u4e32\u4e3a T T \uff0c\u52a0\u5165\u5b57\u7b26 x x \u4ee4 p=ST(T), Right(p)=\\{length(T)\\} p=ST(T), Right(p)=\\{length(T)\\} \u7684\u8282\u70b9 \u65b0\u5efa np=ST(Tx), Right(p)=\\{llength(T) + 1\\} np=ST(Tx), Right(p)=\\{llength(T) + 1\\} \u7684\u8282\u70b9 \u5bf9\u4e8e p p \u548c p p \u6ca1\u6709\u6807\u53f7 x x \u7684\u7956\u5148 v v , trans(v, x)=np trans(v, x)=np \u627e\u5230 p p \u7684\u7b2c\u4e00\u4e2a\u5b58\u5728\u6807\u53f7 x x \u7684\u8fb9\u7684\u7956\u5148 v_p v_p \u3002\u5982\u679c\u8fd9\u6837\u7684 v_p v_p \u4e0d\u5b58\u5728\uff0c\u90a3\u4e48 Parent(np)=root Parent(np)=root \uff0c\u7b97\u6cd5\u7ec8\u6b62 \u4ee4 q=trans(v_p, x) q=trans(v_p, x) \uff0c\u82e5 MAX(q)=MAX(v_p) + 1 MAX(q)=MAX(v_p) + 1 \uff0c\u4ee4 Parent(np)=q Parent(np)=q \uff0c\u7b97\u6cd5\u7ec8\u6b62 \u5426\u5219\u65b0\u5efa\u8282\u70b9 nq nq \uff0c\u4ee4 trans(nq, *)=trans(q, *) trans(nq, *)=trans(q, *) \u7528 nq nq \u66ff\u4ee3 q q \u5728 parent parent \u6811\u4e2d\u7684\u4f4d\u7f6e\uff0c\u8ba9 q q \u548c np np \u90fd\u6210\u4e3a nq nq \u7684\u5b69\u5b50 Parent(nq)=Parent(q) Parent(nq)=Parent(q) Parent(q) = nq Parent(q) = nq Parent(np)=nq Parent(np)=nq \u5bf9\u6240\u6709 trans(v, x)=q trans(v, x)=q \u7684 p p \u7684\u7956\u5148 v v \uff0c trans(v, x) trans(v, x) \u6539\u6210 nq nq \u4ee3\u7801 struct State { State * par , * trans [ 26 ]; int val ; State ( int _val ) : par ( 0 ), val ( _val ) { memset ( trans , 0 , sizeof trans ); } }; State * root , * last = new State ( 0 ); void extend ( int w ) { State * p = last ; State * np = p ? new State ( p -> val + 1 ) : new State ( 1 ); while ( p && p -> trans [ w ] == 0 ) p -> trans [ w ] = np , p = p -> par ; if ( p == 0 ) np -> par = root ; else { State * q = p -> trans [ w ]; if ( p -> val + 1 == q -> val ) np -> par = q ; else { State * nq = new State ( p -> val + 1 ); memcpy ( nq -> trans , q -> trans , sizeof q -> trans ); nq -> par = q -> par ; q -> par = nq ; np -> par = nq ; while ( p && p -> trans [ w ] == q ) p -> trans [ w ] = nq , p = p -> par ; } } last = np ; } \u5e94\u7528 \u6c42\u5b57\u7b26\u4e32 s s \u7684\u6240\u6709\u5faa\u73af\u79fb\u4f4d\u4e2d\u5b57\u5178\u5e8f\u6700\u5c0f\u7684 \u6cbf s\\#s s\\#s \u7684SAM\u6309\u7167\u5b57\u5178\u5e8f\u79fb\u52a8 len(s) len(s) \u6b21\u5f97\u5230\u7684\u5b57\u7b26\u4e32\u4e3a\u6240\u6c42\uff0c\u65f6\u95f4\u7a7a\u95f4\u590d\u6742\u5ea6\u90fd\u662f\u7ebf\u6027\u3002 \u6c42\u4e24\u4e2a\u5b57\u7b26\u4e32 A, B A, B \u7684LCS\uff08\u6700\u957f\u516c\u5171\u8fde\u7eed\u5b50\u4e32 \u5f85\u7eed...","title":"\u540e\u7f00\u81ea\u52a8\u673a"},{"location":"competitive_programming/string/suffix_automation/#_1","text":"\u672c\u8282\u5185\u5bb9\u90e8\u5206\u6765\u81ea\u9648\u7acb\u67702012NOI\u51ac\u4ee4\u8425\u8bb2\u7a3f\uff0c\u5728\u6b64\u5bf9\u9648\u7acb\u6770\u5bf9SAM\u6240\u505a\u7684\u603b\u7ed3\u8868\u793a\u611f\u8c22\u3002 \u672c\u8282\u5c06\u4ece\u6027\u8d28\u5206\u6790\u3001\u7ebf\u6027\u65f6\u95f4\u6784\u9020\u7b97\u6cd5\u4e24\u4e2a\u5c42\u9762\u6765\u8ba8\u8bba\u540e\u7f00\u81ea\u52a8\u673a\u3002","title":"\u540e\u7f00\u81ea\u52a8\u673a"},{"location":"competitive_programming/string/suffix_automation/#sam","text":"\u8bbe\u8981\u5206\u6790\u7684\u5b57\u7b26\u4e32\u4e3a\uff0cSAM\u7684\u672c\u8d28\u662f\u4e00\u4e2a\u589e\u52a0\u4e86\u540e\u7f00\u94fe\u7684DFA\uff08\u6709\u9650\u72b6\u6001\u81ea\u52a8\u673a\uff09\u3002\u5176\u72b6\u6001\u662f\u7684\u6240\u6709\u5b50\u4e32\u7684\u5206\u7ec4\uff0c\u5206\u7ec4\u7684\u4f9d\u636e\u662f\u5b50\u4e32\u7684\u7ed3\u675f\u4f4d\u7f6e\u96c6\u5408\uff08right\u96c6\u5408\uff09\u3002 \u5bf9\u4e8e\u4e00\u4e2a\u72b6\u6001\uff0c\u5176\u6240\u5305\u542b\u7684\u6240\u6709\u5b50\u4e32\u662f\u5176\u4e2d\u6700\u957f\u5b57\u7b26\u4e32\u7684\u4e00\u7cfb\u5217\u957f\u5ea6\u8fde\u7eed\u7684\u540e\u7f00\u3002 \u4e0d\u540c\u72b6\u6001\u5bf9\u5e94\u7684right\u96c6\u5408\u8981\u4e48\u4e0d\u76f8\u4ea4\uff0c\u8981\u4e48\u76f8\u4e92\u771f\u5305\u542b\uff0c\u8fd9\u6761\u6027\u8d28\u4fdd\u8bc1\u4e86\u72b6\u6001\u6570\u662f\u7ebf\u6027\u7684\u3002 \u4e0d\u540c\u72b6\u6001\u5bf9\u5e94\u7684right\u96c6\u5408\u4e4b\u95f4\u7684\u5305\u542b\u5173\u7cfb\u4e2a\u6784\u6210\u4e86\u4e00\u68f5\u6811\u72b6\u7ed3\u6784\uff0c\u5c06\u5176\u79f0\u4e3aparent\u6811\u3002","title":"SAM\u5206\u6790"},{"location":"competitive_programming/string/suffix_automation/#sam_1","text":"\u5bf9\u4e8e\u6bcf\u4e2a\u72b6\u6001 st st \uff0c\u8bb0\u5f55\u5176\u4e2d\u6700\u957f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6 val val \uff0c\u53e6\u5916\u8bb0\u5f55\u5176\u5728 parent parent \u6811\u4e0a\u7684\u7236\u4eb2\u5730\u5740\uff0c\u4ee5\u53ca\u5176\u5728 DFA DFA \u4e2d\u7684\u8f6c\u79fb\u8fb9\u3002\u5219\u5176\u4e2d\u5305\u542b\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u533a\u95f4\u4e3a [st \\rightarrow par \\rightarrow val, st \\rightarrow val] [st \\rightarrow par \\rightarrow val, st \\rightarrow val] \u3002\u91c7\u7528\u5982\u4e0b\u589e\u91cf\u6cd5\u5728\u7ebf\u6784\u9020\uff1a \u4ee4\u5f53\u524d\u4e32\u4e3a T T \uff0c\u52a0\u5165\u5b57\u7b26 x x \u4ee4 p=ST(T), Right(p)=\\{length(T)\\} p=ST(T), Right(p)=\\{length(T)\\} \u7684\u8282\u70b9 \u65b0\u5efa np=ST(Tx), Right(p)=\\{llength(T) + 1\\} np=ST(Tx), Right(p)=\\{llength(T) + 1\\} \u7684\u8282\u70b9 \u5bf9\u4e8e p p \u548c p p \u6ca1\u6709\u6807\u53f7 x x \u7684\u7956\u5148 v v , trans(v, x)=np trans(v, x)=np \u627e\u5230 p p \u7684\u7b2c\u4e00\u4e2a\u5b58\u5728\u6807\u53f7 x x \u7684\u8fb9\u7684\u7956\u5148 v_p v_p \u3002\u5982\u679c\u8fd9\u6837\u7684 v_p v_p \u4e0d\u5b58\u5728\uff0c\u90a3\u4e48 Parent(np)=root Parent(np)=root \uff0c\u7b97\u6cd5\u7ec8\u6b62 \u4ee4 q=trans(v_p, x) q=trans(v_p, x) \uff0c\u82e5 MAX(q)=MAX(v_p) + 1 MAX(q)=MAX(v_p) + 1 \uff0c\u4ee4 Parent(np)=q Parent(np)=q \uff0c\u7b97\u6cd5\u7ec8\u6b62 \u5426\u5219\u65b0\u5efa\u8282\u70b9 nq nq \uff0c\u4ee4 trans(nq, *)=trans(q, *) trans(nq, *)=trans(q, *) \u7528 nq nq \u66ff\u4ee3 q q \u5728 parent parent \u6811\u4e2d\u7684\u4f4d\u7f6e\uff0c\u8ba9 q q \u548c np np \u90fd\u6210\u4e3a nq nq \u7684\u5b69\u5b50 Parent(nq)=Parent(q) Parent(nq)=Parent(q) Parent(q) = nq Parent(q) = nq Parent(np)=nq Parent(np)=nq \u5bf9\u6240\u6709 trans(v, x)=q trans(v, x)=q \u7684 p p \u7684\u7956\u5148 v v \uff0c trans(v, x) trans(v, x) \u6539\u6210 nq nq","title":"SAM\u7684\u7ebf\u6027\u6784\u9020\u7b97\u6cd5"},{"location":"competitive_programming/string/suffix_automation/#_2","text":"struct State { State * par , * trans [ 26 ]; int val ; State ( int _val ) : par ( 0 ), val ( _val ) { memset ( trans , 0 , sizeof trans ); } }; State * root , * last = new State ( 0 ); void extend ( int w ) { State * p = last ; State * np = p ? new State ( p -> val + 1 ) : new State ( 1 ); while ( p && p -> trans [ w ] == 0 ) p -> trans [ w ] = np , p = p -> par ; if ( p == 0 ) np -> par = root ; else { State * q = p -> trans [ w ]; if ( p -> val + 1 == q -> val ) np -> par = q ; else { State * nq = new State ( p -> val + 1 ); memcpy ( nq -> trans , q -> trans , sizeof q -> trans ); nq -> par = q -> par ; q -> par = nq ; np -> par = nq ; while ( p && p -> trans [ w ] == q ) p -> trans [ w ] = nq , p = p -> par ; } } last = np ; }","title":"\u4ee3\u7801"},{"location":"competitive_programming/string/suffix_automation/#_3","text":"\u6c42\u5b57\u7b26\u4e32 s s \u7684\u6240\u6709\u5faa\u73af\u79fb\u4f4d\u4e2d\u5b57\u5178\u5e8f\u6700\u5c0f\u7684 \u6cbf s\\#s s\\#s \u7684SAM\u6309\u7167\u5b57\u5178\u5e8f\u79fb\u52a8 len(s) len(s) \u6b21\u5f97\u5230\u7684\u5b57\u7b26\u4e32\u4e3a\u6240\u6c42\uff0c\u65f6\u95f4\u7a7a\u95f4\u590d\u6742\u5ea6\u90fd\u662f\u7ebf\u6027\u3002 \u6c42\u4e24\u4e2a\u5b57\u7b26\u4e32 A, B A, B \u7684LCS\uff08\u6700\u957f\u516c\u5171\u8fde\u7eed\u5b50\u4e32 \u5f85\u7eed...","title":"\u5e94\u7528"},{"location":"competitive_programming/string/trie/","text":"\u5b57\u5178\u6811 \u95ee\u9898 \u7ed9\u5b9a\u5b57\u7b26\u96c6\uff0c\u8bbe\u8ba1\u4e00\u79cd\u6570\u636e\u7ed3\u6784\uff0c\u5b9e\u73b0\u5355\u8bcd\u96c6\u5408\uff0c\u652f\u6301\u4ee5\u4e0b\u4e09\u79cd\u64cd\u4f5c\uff1a \u52a0\u5165/Add - \u5c06\u5355\u8bcd\u52a0\u5165\u96c6\u5408 \u5220\u9664/Remove - \u5c06\u5355\u8bcd\u4ece\u96c6\u5408\u4e2d\u53bb\u9664 \u67e5\u627e/Find - \u5224\u65ad\u76ee\u6807\u5355\u8bcd\u662f\u5426\u5728\u96c6\u5408\u4e2d \u4ee3\u7801 \u4e0b\u9762\u7684\u5b57\u5178\u6811\uff0c\u652f\u6301\u7531 26 26 \u4e2a\u5c0f\u5199\u82f1\u6587\u5b57\u6bcd\u6784\u6210\u7684\u5355\u8bcd\u7684\u589e\u3001\u5220\u3001\u67e5\u64cd\u4f5c\u3002\u5bf9\u4e8e\u5176\u4ed6\u5b57\u7b26\u96c6\uff0c\u53ea\u9700\u6539\u53d8\u7c7b\u4e2d\u4ece\u5b57\u7b26\u5230\u5176\u5728\u5b57\u7b26\u96c6\u4e2d\u7684\u5e8f\u53f7\u7684\u6620\u5c04\u5373\u53ef\u3002 class Trie { public : Trie () {} virtual ~ Trie () { RemoveTrie ( root ); } void Add ( string word ) { TrieNode * cur = root ; for ( int i = 0 ; i < word . size (); i ++ ) { if ( cur -> next [ word [ i ] - 'a' ] != nullptr ) cur = cur -> next [ word [ i ] - 'a' ]; else { TrieNode * tmp = new TrieNode ( false ); cur -> next [ word [ i ] - 'a' ] = tmp ; cur = tmp ; } if ( i == word . size () - 1 ) cur -> isword = true ; } } void Remove ( string word ) { TrieNode * cur = root ; for ( int i = 0 ; i < word . size (); i ++ ) { if ( cur -> next [ word [ i ] - 'a' ] == nullptr ) { cout << \" \\\" \" << word << \" \\\" \" << \"was not in Trie.\" << endl ; return ; } cur = cur -> next [ word [ i ] - 'a' ]; } cur -> isword = false ; } bool Find ( string word ) { TrieNode * cur = root ; for ( int i = 0 ; i < word . size (); i ++ ) { if ( cur -> next [ word [ i ] - 'a' ] == nullptr ) return false ; cur = cur -> next [ word [ i ] - 'a' ]; } return cur -> isword ; } private : static const int alphabat_size = 26 ; struct TrieNode { bool isword ; TrieNode * next [ alphabat_size ]; TrieNode () {} TrieNode ( bool _isword ) : isword ( _isword ) { for ( int i = 0 ; i < alphabat_size ; i ++ ) next [ i ] = nullptr ; } }; TrieNode * root = new TrieNode ( false ); void RemoveTrie ( TrieNode * cur ) { for ( int i = 0 ; i < alphabat_size ; i ++ ) if ( cur -> next [ i ] != nullptr ) RemoveTrie ( cur -> next [ i ]); delete cur ; } }; \u9700\u8981\u6ce8\u610f Trie \u7c7b\u4e2d\u7528\u94fe\u5f0f\u7ed3\u6784\u5728\u5185\u5b58\u4e2d\u7ef4\u62a4\u4e00\u68f5\u6811\uff0c\u6790\u6784\u51fd\u6570\u4e2d\u8981\u9012\u5f52\u5220\u9664\u3002 \u7b97\u6cd5 \u5b57\u5178\u6811\u662f\u4e00\u68f5\u5ea6\u6570\u7b49\u4e8e\u5b57\u7b26\u8868\u5927\u5c0f\u7684\u591a\u53c9\u6811\uff0c\u589e\u3001\u5220\u3001\u67e5\u7684\u590d\u6742\u5ea6\u90fd\u662f\u5355\u8bcd\u957f\u5ea6 l l \u7684\u7ebf\u6027\u51fd\u6570\uff0c\u5373 O(l) O(l) \u3002 \u5e94\u7528 \u4ece\u5b57\u5178\u6811\u7684\u7684\u6839\u8282\u70b9DFS\u53ef\u4ee5\u5f97\u5230\u6240\u6709\u5355\u8bcd\u7684\u5b57\u5178\u5e8f\u6392\u5e8f\u3002","title":"\u5b57\u5178\u6811"},{"location":"competitive_programming/string/trie/#_1","text":"","title":"\u5b57\u5178\u6811"},{"location":"competitive_programming/string/trie/#_2","text":"\u7ed9\u5b9a\u5b57\u7b26\u96c6\uff0c\u8bbe\u8ba1\u4e00\u79cd\u6570\u636e\u7ed3\u6784\uff0c\u5b9e\u73b0\u5355\u8bcd\u96c6\u5408\uff0c\u652f\u6301\u4ee5\u4e0b\u4e09\u79cd\u64cd\u4f5c\uff1a \u52a0\u5165/Add - \u5c06\u5355\u8bcd\u52a0\u5165\u96c6\u5408 \u5220\u9664/Remove - \u5c06\u5355\u8bcd\u4ece\u96c6\u5408\u4e2d\u53bb\u9664 \u67e5\u627e/Find - \u5224\u65ad\u76ee\u6807\u5355\u8bcd\u662f\u5426\u5728\u96c6\u5408\u4e2d","title":"\u95ee\u9898"},{"location":"competitive_programming/string/trie/#_3","text":"\u4e0b\u9762\u7684\u5b57\u5178\u6811\uff0c\u652f\u6301\u7531 26 26 \u4e2a\u5c0f\u5199\u82f1\u6587\u5b57\u6bcd\u6784\u6210\u7684\u5355\u8bcd\u7684\u589e\u3001\u5220\u3001\u67e5\u64cd\u4f5c\u3002\u5bf9\u4e8e\u5176\u4ed6\u5b57\u7b26\u96c6\uff0c\u53ea\u9700\u6539\u53d8\u7c7b\u4e2d\u4ece\u5b57\u7b26\u5230\u5176\u5728\u5b57\u7b26\u96c6\u4e2d\u7684\u5e8f\u53f7\u7684\u6620\u5c04\u5373\u53ef\u3002 class Trie { public : Trie () {} virtual ~ Trie () { RemoveTrie ( root ); } void Add ( string word ) { TrieNode * cur = root ; for ( int i = 0 ; i < word . size (); i ++ ) { if ( cur -> next [ word [ i ] - 'a' ] != nullptr ) cur = cur -> next [ word [ i ] - 'a' ]; else { TrieNode * tmp = new TrieNode ( false ); cur -> next [ word [ i ] - 'a' ] = tmp ; cur = tmp ; } if ( i == word . size () - 1 ) cur -> isword = true ; } } void Remove ( string word ) { TrieNode * cur = root ; for ( int i = 0 ; i < word . size (); i ++ ) { if ( cur -> next [ word [ i ] - 'a' ] == nullptr ) { cout << \" \\\" \" << word << \" \\\" \" << \"was not in Trie.\" << endl ; return ; } cur = cur -> next [ word [ i ] - 'a' ]; } cur -> isword = false ; } bool Find ( string word ) { TrieNode * cur = root ; for ( int i = 0 ; i < word . size (); i ++ ) { if ( cur -> next [ word [ i ] - 'a' ] == nullptr ) return false ; cur = cur -> next [ word [ i ] - 'a' ]; } return cur -> isword ; } private : static const int alphabat_size = 26 ; struct TrieNode { bool isword ; TrieNode * next [ alphabat_size ]; TrieNode () {} TrieNode ( bool _isword ) : isword ( _isword ) { for ( int i = 0 ; i < alphabat_size ; i ++ ) next [ i ] = nullptr ; } }; TrieNode * root = new TrieNode ( false ); void RemoveTrie ( TrieNode * cur ) { for ( int i = 0 ; i < alphabat_size ; i ++ ) if ( cur -> next [ i ] != nullptr ) RemoveTrie ( cur -> next [ i ]); delete cur ; } }; \u9700\u8981\u6ce8\u610f Trie \u7c7b\u4e2d\u7528\u94fe\u5f0f\u7ed3\u6784\u5728\u5185\u5b58\u4e2d\u7ef4\u62a4\u4e00\u68f5\u6811\uff0c\u6790\u6784\u51fd\u6570\u4e2d\u8981\u9012\u5f52\u5220\u9664\u3002","title":"\u4ee3\u7801"},{"location":"competitive_programming/string/trie/#_4","text":"\u5b57\u5178\u6811\u662f\u4e00\u68f5\u5ea6\u6570\u7b49\u4e8e\u5b57\u7b26\u8868\u5927\u5c0f\u7684\u591a\u53c9\u6811\uff0c\u589e\u3001\u5220\u3001\u67e5\u7684\u590d\u6742\u5ea6\u90fd\u662f\u5355\u8bcd\u957f\u5ea6 l l \u7684\u7ebf\u6027\u51fd\u6570\uff0c\u5373 O(l) O(l) \u3002","title":"\u7b97\u6cd5"},{"location":"competitive_programming/string/trie/#_5","text":"\u4ece\u5b57\u5178\u6811\u7684\u7684\u6839\u8282\u70b9DFS\u53ef\u4ee5\u5f97\u5230\u6240\u6709\u5355\u8bcd\u7684\u5b57\u5178\u5e8f\u6392\u5e8f\u3002","title":"\u5e94\u7528"},{"location":"competitive_programming/string/z-func/","text":"Z\u51fd\u6570\uff08\u6269\u5c55KMP\uff09 \u95ee\u9898 \u7ed9\u5b9a\u5b57\u7b26\u4e32 s s \uff0c\u8fd4\u56de\u5b57\u7b26\u4e32 z z \uff0c z[i] z[i] \u662f s[i, n - 1] s[i, n - 1] \u4e0e s s \u7684LCP\uff08\u6700\u957f\u516c\u5171\u524d\u7f00\uff09\u7684\u957f\u5ea6\u3002 \u4ee3\u7801 vector < int > ZFunction ( string s ) { int n = s . length (); vector < int > z ( n ); for ( int i = 1 , l = 0 , r = 0 ; i < n ; ++ i ) { if ( i <= r ) z [ i ] = min ( z [ i - l ], r - i + 1 ); while ( i + z [ i ] < n && s [ z [ i ]] == s [ i + z [ i ]]) z [ i ] ++ ; if ( i + z [ i ] - 1 > r ) l = i , r = i + z [ i ] - 1 ; } return z ; } \u7b97\u6cd5 \u7ef4\u62a4\u5df2\u53d1\u73b0\u7684\u6700\u9760\u53f3\u4fa7\u7684\u5339\u914d\u6bb5 [l ,r] [l ,r] \uff0c\u5373\u7b97\u6cd5\u5f53\u524d\u626b\u63cf\u5230\u7684\u6700\u9760\u53f3\u7684\u4f4d\u7f6e\u3002 \u6ce8\u610f\u5230\u7b97\u6cd5\u4e2d for \u5faa\u73af\u7684\u521d\u59cb\u4f4d\u7f6e\u4e3a 1 1 \uff0c\u5982\u679c\u521d\u59cb\u4f4d\u7f6e\u4e3a 0 0 \u5219\u7b2c\u4e00\u6b21\u6267\u884c\u5faa\u73af\u65f6 [l, r] [l, r] \u88ab\u8bbe\u7f6e\u6210 [0, n - 1] [0, n - 1] \uff0c\u7b97\u6cd5\u8fdb\u800c\u9000\u5316\u6210\u6734\u7d20\u7684 O(n^2) O(n^2) \u7248\u672c\u3002 \u590d\u6742\u5ea6 \u65f6\u95f4\u3000 O(n) O(n) \u6ce8\u610f\u5230 for \u5faa\u73af\u6700\u591a\u6267\u884c n n \u6b21\uff0c\u53ea\u9700\u8bc1\u660e\u5185\u5c42 while \u5faa\u73af\u7684\u6267\u884c\u6b21\u6570\u4e0a\u7ebf\u662f O(n) O(n) \u7684\u3002\u4e0d\u96be\u8bc1\u660e while \u6bcf\u6b21\u6267\u884c\u5fc5\u7136\u4f7f\u53f3\u8fb9\u754c r \u589e\u5927 1 1 \u3002","title":"Z \u51fd\u6570\uff08\u6269\u5c55KMP\uff09"},{"location":"competitive_programming/string/z-func/#zkmp","text":"","title":"Z\u51fd\u6570\uff08\u6269\u5c55KMP\uff09"},{"location":"competitive_programming/string/z-func/#_1","text":"\u7ed9\u5b9a\u5b57\u7b26\u4e32 s s \uff0c\u8fd4\u56de\u5b57\u7b26\u4e32 z z \uff0c z[i] z[i] \u662f s[i, n - 1] s[i, n - 1] \u4e0e s s \u7684LCP\uff08\u6700\u957f\u516c\u5171\u524d\u7f00\uff09\u7684\u957f\u5ea6\u3002","title":"\u95ee\u9898"},{"location":"competitive_programming/string/z-func/#_2","text":"vector < int > ZFunction ( string s ) { int n = s . length (); vector < int > z ( n ); for ( int i = 1 , l = 0 , r = 0 ; i < n ; ++ i ) { if ( i <= r ) z [ i ] = min ( z [ i - l ], r - i + 1 ); while ( i + z [ i ] < n && s [ z [ i ]] == s [ i + z [ i ]]) z [ i ] ++ ; if ( i + z [ i ] - 1 > r ) l = i , r = i + z [ i ] - 1 ; } return z ; }","title":"\u4ee3\u7801"},{"location":"competitive_programming/string/z-func/#_3","text":"\u7ef4\u62a4\u5df2\u53d1\u73b0\u7684\u6700\u9760\u53f3\u4fa7\u7684\u5339\u914d\u6bb5 [l ,r] [l ,r] \uff0c\u5373\u7b97\u6cd5\u5f53\u524d\u626b\u63cf\u5230\u7684\u6700\u9760\u53f3\u7684\u4f4d\u7f6e\u3002 \u6ce8\u610f\u5230\u7b97\u6cd5\u4e2d for \u5faa\u73af\u7684\u521d\u59cb\u4f4d\u7f6e\u4e3a 1 1 \uff0c\u5982\u679c\u521d\u59cb\u4f4d\u7f6e\u4e3a 0 0 \u5219\u7b2c\u4e00\u6b21\u6267\u884c\u5faa\u73af\u65f6 [l, r] [l, r] \u88ab\u8bbe\u7f6e\u6210 [0, n - 1] [0, n - 1] \uff0c\u7b97\u6cd5\u8fdb\u800c\u9000\u5316\u6210\u6734\u7d20\u7684 O(n^2) O(n^2) \u7248\u672c\u3002","title":"\u7b97\u6cd5"},{"location":"competitive_programming/string/z-func/#_4","text":"\u65f6\u95f4\u3000 O(n) O(n) \u6ce8\u610f\u5230 for \u5faa\u73af\u6700\u591a\u6267\u884c n n \u6b21\uff0c\u53ea\u9700\u8bc1\u660e\u5185\u5c42 while \u5faa\u73af\u7684\u6267\u884c\u6b21\u6570\u4e0a\u7ebf\u662f O(n) O(n) \u7684\u3002\u4e0d\u96be\u8bc1\u660e while \u6bcf\u6b21\u6267\u884c\u5fc5\u7136\u4f7f\u53f3\u8fb9\u754c r \u589e\u5927 1 1 \u3002","title":"\u590d\u6742\u5ea6"},{"location":"design_pattern/add_layers/","text":"\u589e\u52a0\u62bd\u8c61\u5c42\u7ea7\uff0c\u9694\u79bb\u590d\u6742\u53d8\u5316 \u5c01\u88c5\u591a\u6001\u521b\u5efa\u8fc7\u7a0b - \u7b80\u5355\u5de5\u5382\u6a21\u5f0f \u5728\u9762\u5411\u63a5\u53e3\u7f16\u7a0b\u7684\u5b9e\u8df5\u4e2d\uff0c\u7ecf\u5e38\u505a\u7684\u64cd\u4f5c\u662f\u5c06\u57fa\u7c7b\u6307\u9488\u53ea\u4e0a\u4e00\u4e2a\u5b50\u7c7b\u5bf9\u8c61\uff0c\u76f8\u6bd4\u4e8e\u663e\u5f0f\u5730\u8c03\u7528\u6784\u9020\u51fd\u6570\uff0c\u53ef\u4ee5\u8bb2\u591a\u6001\u5bf9\u8c61\u7684\u9009\u62e9\u4e0e\u6784\u9020\u8fc7\u7a0b\u5c01\u88c5\u8d77\u6765\u3002 \u5c01\u88c5\u591a\u6001\u5bf9\u8c61\u7684\u9009\u62e9\u4e0e\u521b\u5efa \u5148\u9694\u79bb\u5f00\uff08\u501f\u52a9\u5c01\u88c5\uff09\uff0c\u518d\u5f90\u56fe\u4e4b\uff08\u589e\u52a0\u53d8\u5316\uff09 \u5c06\u521b\u5efa\u5bf9\u8c61\u4e2d\u7684\u201c\u9009\u62e9\u6027\u201d\u5265\u79bb\u51fa\u6765 \u4f5c\u4e3a\u63a7\u5236\u521b\u5efa\u8fc7\u7a0b\u7684\u53c2\u6570 \u4ece\u4f7f\u7528\u5177\u4f53\u7c7b\u7684\u7c7b\u578b\u540d\u79f0\u6765\u76f4\u63a5\u63a7\u5236\u591a\u6001\u5bf9\u8c61\u7684\u521b\u5efa\uff0c\u8f6c\u53d8\u6210\u4f7f\u7528\u53d8\u91cf\u548c\u7b26\u53f7\u6765\u95f4\u63a5\u63a7\u5236\u591a\u6001\u5bf9\u8c61\u7684\u521b\u5efa\u3002 \u5c01\u88c5\u591a\u53f0\u5bf9\u8c61\u7684\u9009\u62e9\u8fc7\u7a0b \u8bbe\u8ba1\u4e00\u4e2a\u7c7b\u5c01\u88c5\u591a\u6001\u5bf9\u8c61\u7684\u521b\u5efa\u8fc7\u7a0b \u7b80\u5355\u5de5\u5382\u6a21\u5f0f \u4e0b\u65b9\u5de5\u5382\u7c7b\u7684\u5b9a\u4e49\uff0c\u53ef\u4ee5\u6839\u636e\u7c7b\u4f53\u7cfb\u7684\u6269\u5145\u4e0d\u65ad\u589e\u52a0\u5206\u652f\u8bed\u53e5\uff0c\u4ee5\u4fbf\u6839\u636e\u9700\u8981\u8fd4\u56de\u6307\u5b9a\u7684\u5177\u4f53\u4ea7\u54c1\uff0c\u662f\u7ecf\u5e38\u53d8\u52a8\u7684\u7c7b\u3002 class Factory { public : static ProductBase * Create ( ProductID id ) { if ( id == A_ID ) return new ProductA ; if ( id == B_ID ) return new ProductB ; // \u5f53\u4ea7\u54c1\u7c7b\u4f53\u7cfb\u6269\u5145\u65f6\uff0c\u5728\u6b64\u589e\u52a0\u4ee3\u7801 return nullptr ; } }; \u4e0a\u8ff0 Factory \u7684\u4f5c\u7528\u53ea\u662f\u5305\u88c5\u4e00\u4e0b\u9759\u6001\u6784\u9020\u51fd\u6570 Create \uff0c\u5f53\u7136\u4e5f\u53ef\u4ee5\u5c06 Factory \u5f53\u505a\u4e00\u4e2a\u666e\u901a\u7684\u7c7b\u53bb\u4f7f\u7528 class Factory { public : ProductBase * Create ( ProductID id ) { if ( id == A_ID ) return new ProductA ; if ( id == B_ID ) return new ProductB ; return nullptr ; } }; \u6b64\u65f6\u63a5\u53e3\u5bf9\u8c61\u7684\u521b\u5efa\u7ec6\u8282\u88ab\u5b8c\u5168\u5265\u79bb int main () { ProductID id ; cin >> id ; ProductBase * ptr ; ptr = Factory :: Create ( id ); Use ( ptr ); } \u7b80\u5355\u5de5\u5382\u6a21\u5f0f \uff1a \u5c06\u591a\u6001\u5bf9\u8c61\u7684\u521b\u5efa\u8fc7\u7a0b\u5c01\u88c5\u8d77\u6765\uff0c\u4f7f\u201c\u7b56\u7565\u201d\u4e0e\u7b97\u6cd5\u7684\u9009\u62e9\u66f4\u76f4\u89c2\u3002 \u589e\u52a0\u62bd\u8c61\u5c42 - \u5de5\u5382\u65b9\u6cd5\u6a21\u5f0f \u5de5\u5382\u4e0d\u5177\u5907\u5177\u4f53\u4ea7\u54c1\u53c2\u6570 \u5bf9\u4e8e\u4e0a\u9762\u7684 \u7b80\u5355\u5de5\u5382 \u6a21\u5f0f\uff0c\u751f\u6210\u54ea\u79cd\u5bf9\u8c61\u662f\u7531 Factory \u7c7b\u7684\u63a5\u53e3\u6839\u636e\u4f20\u5165\u53c2\u6570\u6765\u51b3\u5b9a\u7684\u3002\u6b64\u65f6\uff0c\u751f\u6210\u5bf9\u8c61\u7684\u7c7b\u540d\u662f\u201c\u770b\u5f97\u89c1\u201d\u7684\uff08Hardcode\u5728\u6e90\u7801\u4e2d\uff09\u3002 \u4f46\u5982\u679c\u7f16\u5199\u5de5\u5382\u65f6\u5e76\u4e0d\u77e5\u9053\u53ef\u80fd\u7684\u5b50\u7c7b\u96c6\u5408\u600e\u4e48\u529e\uff1f\u6b64\u65f6\u53ef\u4ee5\u4f7f\u7528\u6d3e\u751f\u589e\u52a0\u62bd\u8c61\u5c42\u6765\u589e\u52a0\u4f7f\u7528\u7075\u6d3b\u6027\u3002 \u82e5\u65e0\u6cd5\u786e\u5b9a\u591a\u6001\u5bf9\u8c61\u7684\u5177\u4f53\u7c7b \u5728\u589e\u52a0\u4e00\u5c42\u201c\u62bd\u8c61\u5c42\u201d\uff1a\u4ece Factory \u6d3e\u751f\u4e00\u4e2a\u5b50\u7c7b\uff0c\u4e0d\u80fd\u786e\u5b9a\u7684\u95ee\u9898\uff08\u4f7f\u7528\u5177\u4f53\u7c7b\u540d\u521b\u5efa\u4ea7\u54c1\u5bf9\u8c61\uff09\u4ea4\u7ed9\u4ed6\u89e3\u51b3\uff01 \u5bf9\u8fd9\u4e2a\u5b50\u7c7b\u800c\u8a00\uff0c\u5b83\u7684\u201c\u5b9e\u73b0\u8005\u201d\uff08\u7a0b\u5e8f\u5458\u3001\u4ee3\u7801\u4e0a\u4e0b\u6587\u73af\u5883\uff09\u662f\u77e5\u9053\u5177\u4f53\u4ea7\u54c1\u7684\u7c7b\u540d\u7684\uff0c\u56e0\u6b64\u53ef\u4ee5\u521b\u5efa\u76f8\u5e94\u5bf9\uff01 \u901a\u8fc7\u6d3e\u751f\u5f15\u5165\u7684\u62bd\u8c61\u5c42\u589e\u52a0\u4e86\u4f7f\u7528\u7075\u6d3b\u6027 \u4e00\u65b9\u9762\u4f7f\u7528\u57fa\u7c7b\u80fd\u5c06\u65e0\u6cd5\u786e\u5b9a\u7684\u4e8b\u60c5\u4ea4\u7531\u5b50\u7c7b\u53bb\u786e\u5b9a\uff1b \u53e6\u4e00\u65b9\u9762\u4e5f\u4f7f\u79ef\u7d2f\u63d0\u4f9b\u7684\u63a5\u53e3\u4e0d\u6536\u67d0\u4e9b\u4fe1\u606f\u7684\u7ea6\u675f\u3002 class Factory { public : virtual ProductBase * Create ( ProductID ) = 0 ; }; class MyFactory : public Factory { public : ProductBase * Create ( ProductID id ) { if ( id == A_ID ) return new ProductA ; if ( id == B_ID ) return new ProductB ; // \u5f53\u4ea7\u54c1\u4f53\u7cfb\u6269\u5145\u65f6\uff0c\u5728\u6b64\u589e\u52a0\u4ee3\u7801 return nullptr ; } }; \u201c\u6401\u7f6e\u8d77\u6765\uff0c\u7559\u7ed9\u540e\u4ee3\u89e3\u51b3\u5427\u201d \u2014\u2014\u6bdb\u6cfd\u4e1c \u5bf9\u4e8e Factory \u7c7b\u7684\u7f16\u5199\u8005\uff0c\u638c\u63e1\u7684\u4fe1\u606f\u662f Create \u51fd\u6570\u7684\u58f0\u660e\u5f62\u5f0f\uff0c\u4f46\u5177\u4f53\u5bf9\u8c61\u7684\u7c7b\u578b\u96c6\u5408\u672a\u77e5\uff0c\u7559\u7ed9\u5de5\u5382\u5b50\u7c7b\u53bb\u89e3\u51b3\u3002 \u4e0b\u9762\u7684\u4ee3\u7801\u4e2d\u4f7f\u7528\u4e86\u5de5\u5382+\u4ea7\u54c1\u7684\u53cc\u91cd\u591a\u6001 int main () { ProductBase * ptr ; // \u4ea7\u54c1\u57fa\u7c7b\u6307\u9488 Factory * fact_ptr ; // \u5de5\u5382\u57fa\u7c7b\u6307\u9488 fact_ptr = new MyFactory ; ptr = fact_ptr -> Create ( A_ID ); Use ( ptr ); ptr = fact_ptr -> Create ( B_ID ); Use ( ptr ); fact_ptr -> Create ( C_ID ) -> Interface (); } \u5de5\u5382\u65b9\u6cd5\u6a21\u5f0f \u7ee7\u627f\u4f53\u7cfb\u7684UML\u56fe \u8fd9\u79cd\u8bbe\u8ba1\u88abErich Gamma\u7b49\u4eba\u6210\u4e3a \u5de5\u5382\u65b9\u6cd5 \u6a21\u5f0f \u76f8\u4e92\u5173\u8054\u5bf9\u8c61\u7684\u521b\u5efa - \u62bd\u8c61\u5de5\u5382\u6a21\u5f0f \u521b\u5efa\u63a5\u53e3\u96c6\u6210 \u62ff\u87ba\u4e1d\u9489\u548c\u87ba\u4e1d\u5200\u4e3e\u4f8b\uff0c\u87ba\u4e1d\u9489\u6709\u4e00\u5b57\u7eb9\u3001\u5341\u5b57\u82b1\u3001\u516d\u8fb9\u5f62\u7b49\uff0c\u76f8\u5e94\u5730\u87ba\u4e1d\u5200\u4e5f\u6709\u5bf9\u5e94\u7684\u5b9e\u73b0\u3002\u73b0\u5728\u5047\u8bbe\u6709\u87ba\u4e1d\u5200\u548c\u87ba\u4e1d\u9489\u5de5\u5382\uff0c\u5219\u4e8c\u8005\u751f\u4ea7\u7684\u4ea7\u54c1\u7c7b\u578b\u5e94\u8be5\u662f\u4e00\u4e00\u5bf9\u5e94\u7684\u3002 \u5bf9\u4e8e\u8fd9\u79cd\u6709\u201c\u5173\u8054\u201d\u7684\u591a\u6001\u5bf9\u8c61\uff0c\u600e\u6837\u8bbe\u8ba1\u5de5\u5382\u80fd\u591f\u4f53\u73b0\u8fd9\u79cd\u201c\u5173\u8054\u201d\u6027\u5462\uff1f \u65e2\u7136\u591a\u79cd\u5bf9\u8c61\u95f4\u5b58\u5728\u5173\u8054\u5173\u7cfb\uff0c\u90a3\u5c31\u5e94\u8be5\u5c06\u521b\u5efa\u5b83\u4eec\u7684\u63a5\u53e3\u96c6\u6210\u5230\u4e00\u8d77\uff0c\u5f62\u6210\u4e00\u4e2a\u521b\u5efa\u591a\u79cd\u5bf9\u8c61\u7684\u65b0\u63a5\u53e3\uff01 \u62bd\u8c61\u5de5\u5382\u6a21\u5f0f \u5c06\u5173\u8054\u5bf9\u8c61\u7684\u751f\u6210\u63a5\u53e3\u96c6\u6210\uff08\u5408\u5e76\uff09\u5230\u5355\u4e2a\u521b\u5efa\u7c7b\u4e2d\uff0c\u5728\u5b9e\u73b0\u8be5\u7c7b\u65f6\u4fdd\u8bc1\u5404\u4e2a\u5bf9\u8c61\u4e4b\u95f4\u7684\u5173\u8054\u6027\u7b26\u5408\u8981\u6c42\u3002 \u4e0a\u8ff0\u8bbe\u8ba1\u601d\u8def\u88abErich Gamma\u7b49\u4eba\u79f0\u4e3a \u62bd\u8c61\u5de5\u5382 \u6a21\u5f0f\u3002 \u603b\u7ed3 \u8bbe\u8ba1\u539f\u5219 \u5f00\u95ed\u539f\u5219 \u5355\u4e00\u8d23\u4efb\u539f\u5219 \u8bbe\u8ba1\u6a21\u5f0f \u7b56\u7565\u6a21\u5f0f \u59d4\u6258\u6a21\u5f0f \u6865\u63a5\u6a21\u5f0f \u9002\u914d\u5668\u6a21\u5f0f \u4ee3\u7406\u6a21\u5f0f \u88c5\u9970\u6a21\u5f0f \u8d23\u4efb\u94fe\u6a21\u5f0f \u7b80\u5355\u5de5\u5382\u6a21\u5f0f\u3001\u5de5\u5382\u65b9\u6cd5\u6a21\u5f0f\u3001\u62bd\u8c61\u5de5\u5382\u6a21\u5f0f \u672a\u6d89\u53ca\u7684\u6a21\u5f0f \u89e3\u91ca\u5668\u6a21\u5f0f \u547d\u4ee4\u6a21\u5f0f\uff08\u7528\u4e8e\u4ea4\u4e92\u5f0f\u7a0b\u5e8f\u3001\u72b6\u6001\u4fdd\u5b58\uff09 \u72b6\u6001\u6a21\u5f0f\uff08\u7c7b\u4f3c\u4e8e\u72b6\u6001\u673a\uff09","title":"\u589e\u52a0\u62bd\u8c61\u5c42\u7ea7"},{"location":"design_pattern/add_layers/#_1","text":"","title":"\u589e\u52a0\u62bd\u8c61\u5c42\u7ea7\uff0c\u9694\u79bb\u590d\u6742\u53d8\u5316"},{"location":"design_pattern/add_layers/#-","text":"\u5728\u9762\u5411\u63a5\u53e3\u7f16\u7a0b\u7684\u5b9e\u8df5\u4e2d\uff0c\u7ecf\u5e38\u505a\u7684\u64cd\u4f5c\u662f\u5c06\u57fa\u7c7b\u6307\u9488\u53ea\u4e0a\u4e00\u4e2a\u5b50\u7c7b\u5bf9\u8c61\uff0c\u76f8\u6bd4\u4e8e\u663e\u5f0f\u5730\u8c03\u7528\u6784\u9020\u51fd\u6570\uff0c\u53ef\u4ee5\u8bb2\u591a\u6001\u5bf9\u8c61\u7684\u9009\u62e9\u4e0e\u6784\u9020\u8fc7\u7a0b\u5c01\u88c5\u8d77\u6765\u3002","title":"\u5c01\u88c5\u591a\u6001\u521b\u5efa\u8fc7\u7a0b - \u7b80\u5355\u5de5\u5382\u6a21\u5f0f"},{"location":"design_pattern/add_layers/#_2","text":"\u5148\u9694\u79bb\u5f00\uff08\u501f\u52a9\u5c01\u88c5\uff09\uff0c\u518d\u5f90\u56fe\u4e4b\uff08\u589e\u52a0\u53d8\u5316\uff09 \u5c06\u521b\u5efa\u5bf9\u8c61\u4e2d\u7684\u201c\u9009\u62e9\u6027\u201d\u5265\u79bb\u51fa\u6765 \u4f5c\u4e3a\u63a7\u5236\u521b\u5efa\u8fc7\u7a0b\u7684\u53c2\u6570 \u4ece\u4f7f\u7528\u5177\u4f53\u7c7b\u7684\u7c7b\u578b\u540d\u79f0\u6765\u76f4\u63a5\u63a7\u5236\u591a\u6001\u5bf9\u8c61\u7684\u521b\u5efa\uff0c\u8f6c\u53d8\u6210\u4f7f\u7528\u53d8\u91cf\u548c\u7b26\u53f7\u6765\u95f4\u63a5\u63a7\u5236\u591a\u6001\u5bf9\u8c61\u7684\u521b\u5efa\u3002 \u5c01\u88c5\u591a\u53f0\u5bf9\u8c61\u7684\u9009\u62e9\u8fc7\u7a0b \u8bbe\u8ba1\u4e00\u4e2a\u7c7b\u5c01\u88c5\u591a\u6001\u5bf9\u8c61\u7684\u521b\u5efa\u8fc7\u7a0b","title":"\u5c01\u88c5\u591a\u6001\u5bf9\u8c61\u7684\u9009\u62e9\u4e0e\u521b\u5efa"},{"location":"design_pattern/add_layers/#_3","text":"\u4e0b\u65b9\u5de5\u5382\u7c7b\u7684\u5b9a\u4e49\uff0c\u53ef\u4ee5\u6839\u636e\u7c7b\u4f53\u7cfb\u7684\u6269\u5145\u4e0d\u65ad\u589e\u52a0\u5206\u652f\u8bed\u53e5\uff0c\u4ee5\u4fbf\u6839\u636e\u9700\u8981\u8fd4\u56de\u6307\u5b9a\u7684\u5177\u4f53\u4ea7\u54c1\uff0c\u662f\u7ecf\u5e38\u53d8\u52a8\u7684\u7c7b\u3002 class Factory { public : static ProductBase * Create ( ProductID id ) { if ( id == A_ID ) return new ProductA ; if ( id == B_ID ) return new ProductB ; // \u5f53\u4ea7\u54c1\u7c7b\u4f53\u7cfb\u6269\u5145\u65f6\uff0c\u5728\u6b64\u589e\u52a0\u4ee3\u7801 return nullptr ; } }; \u4e0a\u8ff0 Factory \u7684\u4f5c\u7528\u53ea\u662f\u5305\u88c5\u4e00\u4e0b\u9759\u6001\u6784\u9020\u51fd\u6570 Create \uff0c\u5f53\u7136\u4e5f\u53ef\u4ee5\u5c06 Factory \u5f53\u505a\u4e00\u4e2a\u666e\u901a\u7684\u7c7b\u53bb\u4f7f\u7528 class Factory { public : ProductBase * Create ( ProductID id ) { if ( id == A_ID ) return new ProductA ; if ( id == B_ID ) return new ProductB ; return nullptr ; } }; \u6b64\u65f6\u63a5\u53e3\u5bf9\u8c61\u7684\u521b\u5efa\u7ec6\u8282\u88ab\u5b8c\u5168\u5265\u79bb int main () { ProductID id ; cin >> id ; ProductBase * ptr ; ptr = Factory :: Create ( id ); Use ( ptr ); } \u7b80\u5355\u5de5\u5382\u6a21\u5f0f \uff1a \u5c06\u591a\u6001\u5bf9\u8c61\u7684\u521b\u5efa\u8fc7\u7a0b\u5c01\u88c5\u8d77\u6765\uff0c\u4f7f\u201c\u7b56\u7565\u201d\u4e0e\u7b97\u6cd5\u7684\u9009\u62e9\u66f4\u76f4\u89c2\u3002","title":"\u7b80\u5355\u5de5\u5382\u6a21\u5f0f"},{"location":"design_pattern/add_layers/#-_1","text":"","title":"\u589e\u52a0\u62bd\u8c61\u5c42 - \u5de5\u5382\u65b9\u6cd5\u6a21\u5f0f"},{"location":"design_pattern/add_layers/#_4","text":"\u5bf9\u4e8e\u4e0a\u9762\u7684 \u7b80\u5355\u5de5\u5382 \u6a21\u5f0f\uff0c\u751f\u6210\u54ea\u79cd\u5bf9\u8c61\u662f\u7531 Factory \u7c7b\u7684\u63a5\u53e3\u6839\u636e\u4f20\u5165\u53c2\u6570\u6765\u51b3\u5b9a\u7684\u3002\u6b64\u65f6\uff0c\u751f\u6210\u5bf9\u8c61\u7684\u7c7b\u540d\u662f\u201c\u770b\u5f97\u89c1\u201d\u7684\uff08Hardcode\u5728\u6e90\u7801\u4e2d\uff09\u3002 \u4f46\u5982\u679c\u7f16\u5199\u5de5\u5382\u65f6\u5e76\u4e0d\u77e5\u9053\u53ef\u80fd\u7684\u5b50\u7c7b\u96c6\u5408\u600e\u4e48\u529e\uff1f\u6b64\u65f6\u53ef\u4ee5\u4f7f\u7528\u6d3e\u751f\u589e\u52a0\u62bd\u8c61\u5c42\u6765\u589e\u52a0\u4f7f\u7528\u7075\u6d3b\u6027\u3002 \u82e5\u65e0\u6cd5\u786e\u5b9a\u591a\u6001\u5bf9\u8c61\u7684\u5177\u4f53\u7c7b \u5728\u589e\u52a0\u4e00\u5c42\u201c\u62bd\u8c61\u5c42\u201d\uff1a\u4ece Factory \u6d3e\u751f\u4e00\u4e2a\u5b50\u7c7b\uff0c\u4e0d\u80fd\u786e\u5b9a\u7684\u95ee\u9898\uff08\u4f7f\u7528\u5177\u4f53\u7c7b\u540d\u521b\u5efa\u4ea7\u54c1\u5bf9\u8c61\uff09\u4ea4\u7ed9\u4ed6\u89e3\u51b3\uff01 \u5bf9\u8fd9\u4e2a\u5b50\u7c7b\u800c\u8a00\uff0c\u5b83\u7684\u201c\u5b9e\u73b0\u8005\u201d\uff08\u7a0b\u5e8f\u5458\u3001\u4ee3\u7801\u4e0a\u4e0b\u6587\u73af\u5883\uff09\u662f\u77e5\u9053\u5177\u4f53\u4ea7\u54c1\u7684\u7c7b\u540d\u7684\uff0c\u56e0\u6b64\u53ef\u4ee5\u521b\u5efa\u76f8\u5e94\u5bf9\uff01 \u901a\u8fc7\u6d3e\u751f\u5f15\u5165\u7684\u62bd\u8c61\u5c42\u589e\u52a0\u4e86\u4f7f\u7528\u7075\u6d3b\u6027 \u4e00\u65b9\u9762\u4f7f\u7528\u57fa\u7c7b\u80fd\u5c06\u65e0\u6cd5\u786e\u5b9a\u7684\u4e8b\u60c5\u4ea4\u7531\u5b50\u7c7b\u53bb\u786e\u5b9a\uff1b \u53e6\u4e00\u65b9\u9762\u4e5f\u4f7f\u79ef\u7d2f\u63d0\u4f9b\u7684\u63a5\u53e3\u4e0d\u6536\u67d0\u4e9b\u4fe1\u606f\u7684\u7ea6\u675f\u3002 class Factory { public : virtual ProductBase * Create ( ProductID ) = 0 ; }; class MyFactory : public Factory { public : ProductBase * Create ( ProductID id ) { if ( id == A_ID ) return new ProductA ; if ( id == B_ID ) return new ProductB ; // \u5f53\u4ea7\u54c1\u4f53\u7cfb\u6269\u5145\u65f6\uff0c\u5728\u6b64\u589e\u52a0\u4ee3\u7801 return nullptr ; } }; \u201c\u6401\u7f6e\u8d77\u6765\uff0c\u7559\u7ed9\u540e\u4ee3\u89e3\u51b3\u5427\u201d \u2014\u2014\u6bdb\u6cfd\u4e1c \u5bf9\u4e8e Factory \u7c7b\u7684\u7f16\u5199\u8005\uff0c\u638c\u63e1\u7684\u4fe1\u606f\u662f Create \u51fd\u6570\u7684\u58f0\u660e\u5f62\u5f0f\uff0c\u4f46\u5177\u4f53\u5bf9\u8c61\u7684\u7c7b\u578b\u96c6\u5408\u672a\u77e5\uff0c\u7559\u7ed9\u5de5\u5382\u5b50\u7c7b\u53bb\u89e3\u51b3\u3002 \u4e0b\u9762\u7684\u4ee3\u7801\u4e2d\u4f7f\u7528\u4e86\u5de5\u5382+\u4ea7\u54c1\u7684\u53cc\u91cd\u591a\u6001 int main () { ProductBase * ptr ; // \u4ea7\u54c1\u57fa\u7c7b\u6307\u9488 Factory * fact_ptr ; // \u5de5\u5382\u57fa\u7c7b\u6307\u9488 fact_ptr = new MyFactory ; ptr = fact_ptr -> Create ( A_ID ); Use ( ptr ); ptr = fact_ptr -> Create ( B_ID ); Use ( ptr ); fact_ptr -> Create ( C_ID ) -> Interface (); }","title":"\u5de5\u5382\u4e0d\u5177\u5907\u5177\u4f53\u4ea7\u54c1\u53c2\u6570"},{"location":"design_pattern/add_layers/#_5","text":"\u7ee7\u627f\u4f53\u7cfb\u7684UML\u56fe \u8fd9\u79cd\u8bbe\u8ba1\u88abErich Gamma\u7b49\u4eba\u6210\u4e3a \u5de5\u5382\u65b9\u6cd5 \u6a21\u5f0f","title":"\u5de5\u5382\u65b9\u6cd5\u6a21\u5f0f"},{"location":"design_pattern/add_layers/#-_2","text":"","title":"\u76f8\u4e92\u5173\u8054\u5bf9\u8c61\u7684\u521b\u5efa - \u62bd\u8c61\u5de5\u5382\u6a21\u5f0f"},{"location":"design_pattern/add_layers/#_6","text":"\u62ff\u87ba\u4e1d\u9489\u548c\u87ba\u4e1d\u5200\u4e3e\u4f8b\uff0c\u87ba\u4e1d\u9489\u6709\u4e00\u5b57\u7eb9\u3001\u5341\u5b57\u82b1\u3001\u516d\u8fb9\u5f62\u7b49\uff0c\u76f8\u5e94\u5730\u87ba\u4e1d\u5200\u4e5f\u6709\u5bf9\u5e94\u7684\u5b9e\u73b0\u3002\u73b0\u5728\u5047\u8bbe\u6709\u87ba\u4e1d\u5200\u548c\u87ba\u4e1d\u9489\u5de5\u5382\uff0c\u5219\u4e8c\u8005\u751f\u4ea7\u7684\u4ea7\u54c1\u7c7b\u578b\u5e94\u8be5\u662f\u4e00\u4e00\u5bf9\u5e94\u7684\u3002 \u5bf9\u4e8e\u8fd9\u79cd\u6709\u201c\u5173\u8054\u201d\u7684\u591a\u6001\u5bf9\u8c61\uff0c\u600e\u6837\u8bbe\u8ba1\u5de5\u5382\u80fd\u591f\u4f53\u73b0\u8fd9\u79cd\u201c\u5173\u8054\u201d\u6027\u5462\uff1f \u65e2\u7136\u591a\u79cd\u5bf9\u8c61\u95f4\u5b58\u5728\u5173\u8054\u5173\u7cfb\uff0c\u90a3\u5c31\u5e94\u8be5\u5c06\u521b\u5efa\u5b83\u4eec\u7684\u63a5\u53e3\u96c6\u6210\u5230\u4e00\u8d77\uff0c\u5f62\u6210\u4e00\u4e2a\u521b\u5efa\u591a\u79cd\u5bf9\u8c61\u7684\u65b0\u63a5\u53e3\uff01","title":"\u521b\u5efa\u63a5\u53e3\u96c6\u6210"},{"location":"design_pattern/add_layers/#_7","text":"\u5c06\u5173\u8054\u5bf9\u8c61\u7684\u751f\u6210\u63a5\u53e3\u96c6\u6210\uff08\u5408\u5e76\uff09\u5230\u5355\u4e2a\u521b\u5efa\u7c7b\u4e2d\uff0c\u5728\u5b9e\u73b0\u8be5\u7c7b\u65f6\u4fdd\u8bc1\u5404\u4e2a\u5bf9\u8c61\u4e4b\u95f4\u7684\u5173\u8054\u6027\u7b26\u5408\u8981\u6c42\u3002 \u4e0a\u8ff0\u8bbe\u8ba1\u601d\u8def\u88abErich Gamma\u7b49\u4eba\u79f0\u4e3a \u62bd\u8c61\u5de5\u5382 \u6a21\u5f0f\u3002","title":"\u62bd\u8c61\u5de5\u5382\u6a21\u5f0f"},{"location":"design_pattern/add_layers/#_8","text":"\u8bbe\u8ba1\u539f\u5219 \u5f00\u95ed\u539f\u5219 \u5355\u4e00\u8d23\u4efb\u539f\u5219 \u8bbe\u8ba1\u6a21\u5f0f \u7b56\u7565\u6a21\u5f0f \u59d4\u6258\u6a21\u5f0f \u6865\u63a5\u6a21\u5f0f \u9002\u914d\u5668\u6a21\u5f0f \u4ee3\u7406\u6a21\u5f0f \u88c5\u9970\u6a21\u5f0f \u8d23\u4efb\u94fe\u6a21\u5f0f \u7b80\u5355\u5de5\u5382\u6a21\u5f0f\u3001\u5de5\u5382\u65b9\u6cd5\u6a21\u5f0f\u3001\u62bd\u8c61\u5de5\u5382\u6a21\u5f0f \u672a\u6d89\u53ca\u7684\u6a21\u5f0f \u89e3\u91ca\u5668\u6a21\u5f0f \u547d\u4ee4\u6a21\u5f0f\uff08\u7528\u4e8e\u4ea4\u4e92\u5f0f\u7a0b\u5e8f\u3001\u72b6\u6001\u4fdd\u5b58\uff09 \u72b6\u6001\u6a21\u5f0f\uff08\u7c7b\u4f3c\u4e8e\u72b6\u6001\u673a\uff09","title":"\u603b\u7ed3"},{"location":"design_pattern/compose_interfaces/","text":"\u57fa\u4e8e\u63a5\u53e3\u7ec4\u5408\u5e94\u5bf9\u590d\u6742\u53d8\u5316 \u5df2\u6709\u8d44\u6e90\u7684\u7ec4\u5408 \u4f7f\u7528\u5df2\u6709\u8d44\u6e90\u7684\u5e38\u7528\u65b9\u5f0f \u7ee7\u627f\u3001\u7ec4\u5408\u3001\u6a21\u677f\u5b9e\u4f8b\u5316\uff08\u6cdb\u578b\u7f16\u7a0b\uff09 \u4f18\u5148\u4f7f\u7528 \u7ec4\u5408 \u800c\u4e0d\u662f \u7ee7\u627f \uff0c\u56e0\u4e3a\u7ec4\u5408\u6bd4\u8f83\u7075\u6d3b\uff0c\u4f46\u5982\u679c\u65b0\u4ee3\u7801\u91cc\u7684\u5bf9\u8c61\u548c\u539f\u6709\u4ee3\u7801\u7684\u5bf9\u8c61\u6709\u5929\u7136\u7684\u5305\u542b\u5173\u7cfb\uff0c\u5219\u5e94\u8be5\u4f7f\u7528\u7ee7\u627f\u6765\u590d\u7528\u4ee3\u7801\u3002 \u4ee5\u6808\u4e3a\u4f8b \u5b9e\u73b0\u6808\u7c7b\u578b\u2014\u2014FILO\u8868 \u5176\u5b9e\u4f8b\u80fd\u591f\u7ec4\u7ec7\u591a\u4e2a\u540c\u7c7b\u578b\u6570\u636e \u540e\u8fdb\u5148\u51fa \u63d0\u4f9b\u56db\u4e2a\u64cd\u4f5c\uff1a push , pop , top , empty \u5148\u5b9e\u73b0\u6574\u6570\u7684\u6808 \u4e00\u79cd\u65b9\u5f0f\u662f\u53ef\u4ee5\u901a\u8fc7\u7ef4\u62a4\u539f\u59cb\u6570\u7ec4\u7684\u65b9\u5f0f\u6784\u9020\u4e00\u4e2a\u6808\u7c7b\uff1b \u8be5\u6808\u7c7b\u7684\u9700\u6c42\u4e0e std::vector \u7684 push_back , pop_back , back , empty \u63d0\u4f9b\u7684\u529f\u80fd\u7c7b\u4f3c\uff0c\u5728\u5b9e\u73b0\u4e0a\u53ea\u9700\u5728 std::vector \u7684\u57fa\u7840\u4e0a\u5c01\u88c5\u4e00\u5c42\u63a5\u53e3\u5373\u53ef\u3002 \u5f15\u5165\u63a5\u53e3 \u5c06\u63a5\u53e3\u4ee5\u7eaf\u865a\u51fd\u6570\u7684\u5f62\u5f0f\u5b9a\u4e49\u5728\u62bd\u8c61\u7c7b\u91cc\u9762\uff0c\u7531\u5b50\u7c7b\u53bb\u5b9e\u73b0\u3002 \u4f7f\u7528\u7684\u65f6\u5019\u8c03\u7528\u63a5\u53e3\u7c7b\uff0c\u4ee5\u6b64\u4fdd\u8bc1\u4f7f\u7528\u65b9\u5f0f\u4e0d\u53d8\u3002 \u5982\u6b64\u67d0\u4e2a\u7c7b\u7684\u4f7f\u7528\u8005\u548c\u5f00\u53d1\u8005\u7684\u5de5\u4f5c\u88ab\u5b8c\u5168\u9694\u79bb\u5f00\u3002 \u5047\u8bbe\u6309\u7167\u5982\u4e0bUML\u5b9e\u73b0\u57fa\u4e8e std::vector \u7684 Stack \uff1a \u8fd9\u91cc VectorStack \u7c7b\u662f\u4e00\u4e2a \u8f6c\u63a5\u7c7b \uff0c\u529f\u80fd\u7c7b\u4f3c\u4e8ethunder3\u8f6cUSB\u7684\u8f6c\u6362\u5934\u3002 \u9002\u914d\u5668\u6a21\u5f0f \u9002\u914d\u5668\u6a21\u5f0f \uff1a\u5bf9\u4e8e\u529f\u80fd\u6ee1\u8db3\u9700\u6c42\uff0c\u4f46\u63a5\u53e3\u4e0d\u4e00\u81f4\u7684\u60c5\u51b5\uff0c\u5b9a\u4e49\u4e00\u4e2aAdapter\u7c7b\u4f7f\u7528\u7ec4\u5408\u5b9e\u73b0\u9002\u914d\u3002 \u8fd9\u91cc\u7684\u9002\u914d\u5668\u4f7f\u7528\u201c\u7ec4\u5408\u201d\u5b9e\u73b0\uff0c\u4e5f\u53ef\u4ee5\u7528\u201c\u7ee7\u627f\u201d\u5b9e\u73b0\u3002 \u591a\u91cd\u7ee7\u627f \u9664\u4e86\u201c\u7ec4\u5408\u201d\u4e4b\u5916\uff0c\u8fd8\u53ef\u4ee5\u4f7f\u7528\u201c\u591a\u91cd\u7ee7\u627f\u201d\u5b9e\u73b0 VectorStack class VectorStack : public Stack , private vector < int > { public : VectorStack () : vector < int > () {} bool empty () { return vector < int >:: empty (); } void push ( int i ) { push_back ( i ); } void pop () { pop_back (); } int top () { return back (); } }; \u7531\u4e8e\u591a\u91cd\u7ee7\u627f\u662f\u5426\u5408\u7406\u5c1a\u5b58\u4e89\u8bba\uff0c\u5b9e\u9645\u4e2d\u4e0d\u5b58\u5728\u6b64\u5b9e\u73b0\u3002 C++\u5047\u8bbe\u7a0b\u5e8f\u5458\u77e5\u9053\u81ea\u5df1\u5728\u5e72\u4ec0\u4e48\uff0c\u6240\u4ee5\u5728\u529f\u80fd\u4e0a\u63d0\u4f9b\u4e86\u591a\u91cd\u7ee7\u627f \u4f7f\u7528\u7ee7\u627f\u5b9e\u73b0\u9002\u914d\uff0c\u79f0\u4f5c \u7c7bAdaapter \uff0cUML\u5982\u4e0b \u63a5\u53e3\u4e0d\u53d8\u65f6\u7684\u529f\u80fd\u53d8\u5316 \u667a\u80fd\u6307\u9488\u4e0e\u4ee3\u7406\u6a21\u5f0f \u8003\u8651\u591a\u4e2a\u6307\u9488\u6307\u5411\u76f8\u540c\u7684\u7269\u7406\u5730\u5740\uff0c\u5f53\u5176\u4e2d\u4e00\u4e2a\u6307\u9488\u91ca\u653e\u7684\u65f6\u5019\uff0c\u5176\u4ed6\u7684\u6307\u9488\u53d8\u6210\u4e86\u91ce\u6307\u9488\u3002\u8fd9\u91cc\u51fa\u73b0\u7684\u6839\u672c\u95ee\u9898\u662f\u6307\u9488\u4e4b\u95f4\u4e92\u76f8\u4e0d\u77e5\u9053\u5bf9\u65b9\u7684\u5b58\u5728\u3002 \u5f15\u7528\u8ba1\u6570 \u95ee\u9898\u4e0a\u8ff0\u95ee\u9898\uff0c\u9700\u8981\u8ddf\u8e2a\u57fa\u7840\u5bf9\u8c61\u88ab\u591a\u5c11\u6307\u9488\u6240\u5171\u4eab\uff0c\u76f4\u5230\u5f15\u7528\u8ba1\u6570\u4e3a 0 0 \u65f6\u624d\u771f\u6b63\u91ca\u653e\u57fa\u7840\u5bf9\u8c61\u3002 \u201c\u667a\u80fd\u6307\u9488\u201d\u6a21\u677f #include <bits/stdc++.h> using namespace std ; template < typename T > class SmartPtr ; template < typename T > class UPtr { // \u8bbe\u8ba1\u4e00\u4e2a\u8f85\u52a9\u7c7b\u7528\u4f5cSmartPtr\u5b9e\u4f53\u7684\u5171\u4eab\u8ba1\u6570 private : friend class SmartPtr < T > ; UPtr ( T * ptr ) : p ( ptr ), count ( 1 ) {} ~ UPtr () { delete p ; } int count ; T * p ; }; template < typename T > class SmartPtr { public : SmartPtr ( T * ptr ) : rp ( new UPtr < T > ( ptr )) {} SmartPtr ( const SmartPtr < T >& sp ) : rp ( sp . rp ) { // \u62f7\u8d1d\u6784\u9020\uff0c\u5f15\u7528\u8ba1\u6570++ ++ rp -> count ; } SmartPtr & operator = ( const SmartPtr < T >& rhs ) { ++ rhs . rp -> count ; // \u5c06rhs\u7684\u5f15\u7528\u8ba1\u6570++ if ( -- rp -> count == 0 ) delete rp ; // \u539f\u6765\u6307\u5411\u5bf9\u8c61\u7684\u5f15\u7528\u8ba1\u6570--\uff0c\u4e3a\u96f6\u5219\u91ca\u653e\u57fa\u7840\u5bf9\u8c61 rp = this . rp ; // \u6267\u884c\u5b9e\u9645\u8d4b\u503c\u64cd\u4f5c return * this ; } ~ SmartPtr () { if ( -- rp -> count == 0 ) delete rp ; // \u6790\u6784\u51fd\u6570\uff0c\u5f15\u7528\u8ba1\u6570--\uff0c\u4e3a\u96f6\u5219\u91ca\u653e\u57fa\u7840\u5bf9\u8c61 } // \u91cd\u8f7d\u6307\u9488\u64cd\u4f5c\u7b26 * \u548c -> T & operator * () { return * ( rp -> p ); } T * operator -> () { return rp -> p ; } private : UPtr < T >* rp ; }; // \u4f7f\u7528\u667a\u80fd\u6307\u9488\uff0c\u65e0\u9700\u8003\u8651\u91ca\u653e\u95ee\u9898 int main ( int argc , char * argv []) { SmartPtr < int > ptr1 ( new int ( 2 )); SmartPtr < int > ptr2 ( ptr1 ); SmartPtr < int > ptr3 = ptr2 ; cout << * ptr1 << endl ; * ptr1 = 20 ; cout << * ptr2 << endl ; } \u8f93\u51fa 2 20 \u667a\u80fd\u6307\u9488\u5206\u6790 SmartPtr<int> \u548c int* \u6709\u76f8\u540c\u7684\u63a5\u53e3 \u64cd\u4f5c\u7b26\uff1a * \u548c -> \u8d4b\u503c\u64cd\u4f5c\u7b26\u4e0e\u521d\u59cb\u5316\uff08\u62f7\u8d1d\u6784\u9020\uff09 \u91ca\u653e\uff08\u6790\u6784\uff09 SmartPtr<int> \u6bd4 int* \u589e\u52a0\u4e86\u4e00\u4e9b\u63a7\u5236\u64cd\u4f5c \u62f7\u8d1d\u6784\u9020\u65f6\u5f15\u7528\u8ba1\u6570 ++ \u6790\u6784\u65f6\u5f15\u7528\u8ba1\u6570 -- \uff0c\u76f4\u5230\u5f15\u7528\u8ba1\u6570\u4e3a\u96f6\u65f6\u91ca\u653e \u8d4b\u503c\u65f6\u5bf9\u5f53\u524d\u5f15\u7528\u8ba1\u6570\u548c\u53c2\u6570\u5f15\u7528\u8ba1\u6570\u5206\u522b\u5904\u7406 \u8fd9\u79cd\u65b9\u5f0f\u88ab\u79f0\u4e3a \u4ee3\u7406\u6a21\u5f0f \u4ee5 SmartPtr \u7684\u8d4b\u503c\u64cd\u4f5c\u7b26 = \u4e3a\u4f8b \u9996\u5148\u505a\u4e00\u4e9b\"\u5176\u4ed6\u64cd\u4f5c\" \u7136\u540e\u6267\u884c\u4e86 int* \u7684\u8d4b\u503c\u64cd\u4f5c \u5728 int* \u7684\u8d4b\u503c\u64cd\u4f5c\u57fa\u7840\u4e0a\u589e\u52a0\u4e86\u66f4\u591a\u529f\u80fd \u63a5\u53e3\u4e0d\u53d8\uff0c\u529f\u80fd\u53d8\u5316 \u5e38\u88ab\u79f0\u4e3a \u4ee3\u7406\u6a21\u5f0f \u7528\u4e8e\u5bf9\u88ab\u4ee3\u7406\u5bf9\u8c61\u8fdb\u884c\u63a7\u5236\uff0c\u5982\u5f15\u7528\u8ba1\u6570\u63a7\u5236\u3001\u6743\u9650\u63a7\u5236\uff08\u88ab\u4ee3\u7406\u5bf9\u8c61\u662f\u5426\u53ef\u4ee5\u88ab\u8bbf\u95ee\uff09\u3001\u8fdc\u7a0b\u4ee3\u7406\uff08\u5c06\u5bf9\u8fdc\u7a0b\u5bf9\u8c61\u7684\u64cd\u4f5c\u4ee3\u7406\u5230\u672c\u5730\u5bf9\u8c61\uff09\u3001\u5ef6\u8fdf\u521d\u59cb\u5316\u7b49\u7b49\u3002 \u5ef6\u8fdf\u521d\u59cb\u5316 \u6709\u4e9b\u5bf9\u8c61\u7684\u521d\u59cb\u5316\u65f6\u95f4\u8f83\u957f\uff0c\u6bd4\u5982\u9700\u8981\u505a\u6570\u636e\u5e93\u8fde\u63a5\u7b49\u3002\u5bf9\u4e8e\u8fd9\u79cd\u60c5\u51b5\u53ef\u4ee5\u7b49\u5230\u5b9e\u9645\u4f7f\u7528\u7684\u65f6\u5019\u518d\u521d\u59cb\u5316\u3002 \u5ef6\u8fdf\u521d\u59cb\u5316\u7ecf\u5e38\u4e0e\u5f15\u7528\u8ba1\u6570\u7ed3\u5408\u4f7f\u7528\uff0c\u51cf\u5c11\u521d\u59cb\u5316\u7684\u6b21\u6570\u3002 class Proxy : public Object { public : Proxy () : object_ ( nullptr ) {} // \u4ee3\u7406\u7c7b\u5bf9\u8c61\u521d\u59cb\u5316\u65f6\u4e0d\u521d\u59cb\u5316\u5b9e\u9645\u5bf9\u8c61 ~ Proxy () { if ( object_ != nullptr ) delete object_ ; } void run () { // \u5b9e\u9645\u5bf9\u8c61\u521d\u59cb\u5316\u88ab\u5ef6\u8fdf\u5230\u8c03\u7528run\u51fd\u6570\u65f6\u8fdb\u884c if ( object_ == nullptr ) object_ = new RealObject (); object_ -> run (); // run\u51fd\u6570\u672c\u6765\u7684\u529f\u80fd } private : RealObject * object_ ; }; int main ( int argc , char * argv []) { Proxy proxy ; proxy . run (); } Lazy load\u7684\u597d\u5904\uff1a \u51cf\u5c11\u521d\u59cb\u5316\u65f6\u95f4 \u5f53\u548c\u5f15\u7528\u8ba1\u6570\u7ed3\u5408\u7684\u65f6\u5019\u80fd\u591f\u8282\u7701\u4e0d\u5fc5\u8981\u7684\u521d\u59cb\u5316\u8fc7\u7a0b\u3002\uff08\u5c06\u591a\u4e2aProxy\u6307\u5411\u540c\u4e00\u4e2a\u5b9e\u9645\u5bf9\u8c61\uff09 \u6709\u4e9b\u5bf9\u8c61\u521d\u59cb\u5316\u4e4b\u540e\u4e0d\u4e00\u5b9a\u88ab\u4f7f\u7528\uff0c\u91c7\u7528lazy load\u7684\u65b9\u5f0f\u53ef\u4ee5\u51cf\u5c11\u8fd9\u79cd\u60c5\u51b5\u4e0b\u7684\u8d44\u6e90\u6d6a\u8d39 \u88c5\u9970 \u4ece\u5b9e\u73b0\u4e00\u4e2aTextViewer\u5f00\u59cb \u5047\u8bbe\u73b0\u6709\u4e00\u4e2a TextView \u5bf9\u8c61\uff0c\u80fd\u591f\u5728\u7a97\u53e3\u4e2d\u663e\u793a\u6587\u5b57\u3002\u73b0\u5728\u5e0c\u671b\u63a5\u53e3\u4e0d\u53d8\uff0c\u589e\u52a0\u6eda\u52a8\u6761\u3001\u8fb9\u6846\u3001... \u4f7f\u7528\u7ee7\u627f\u5b9e\u73b0 \u5229\u7528C++\u4e2d\u7684\u7ee7\u627f\uff0c\u4f9d\u9760\u591a\u6001\u5b9e\u73b0\u529f\u80fd\u591a\u6837\u5316\uff1a \u5f0a\u7aef\uff1a\u591a\u79cd TextView \u4e4b\u95f4\u6ca1\u6709\u5c42\u6b21\u5173\u7cfb\uff0c\u4e0d\u7528\u7684View\u4e4b\u95f4\u76f8\u4e92\u72ec\u7acb\u3002\u7531\u6b64\u5f53\u9700\u8981\u7684\u9644\u4ef6\u589e\u591a\u7684\u65f6\u5019\u4f1a\u5bfc\u81f4 TextView \u7c7b\u4f53\u7cfb\u81a8\u80c0 \u3001\u4ee3\u7801\u5927\u91cf\u5197\u4f59\u3002 \u4f7f\u7528\u7b56\u7565\u6a21\u5f0f \u7528\u7ec4\u5408\u66ff\u4ee3\u7ee7\u627f\uff0c\u4f7f\u7528\u7ec4\u5408\u52a8\u6001\u6539\u53d8\u7b56\u7565\u4ee5\u5b9e\u73b0\u591a\u53d8\u7684\u529f\u80fd \u7b56\u7565\u9009\u9879\u4e4b\u95f4\u76f8\u4e92\u72ec\u7acb\u4f7f\u5f97\u7ec4\u5408\u66f4\u52a0\u7075\u6d3b\uff0c\u6709\u6548\u6291\u5236\u4e86 \u7c7b\u81a8\u80c0 \u95ee\u9898\u3002 \u4f46\u662f\uff0c\u7b56\u7565\u9009\u9879\u9700\u8981\u9884\u5148\u5b9a\u4e49\uff0c\u65e0\u6cd5\u589e\u52a0\u3002\u4f8b\u5982\uff0c\u5f53\u6211\u4eec\u9700\u8981\u589e\u52a0\u4e00\u4e2a\u201c\u5de5\u5177\u680f\u201d\u7684\u65f6\u5019\uff0c\u9700\u8981\u5728 TextView \u5927\u7c7b\u8fdb\u884c\u4fee\u6539\uff0c\u8fd9\u79cd\u64cd\u4f5c\u5e94\u8be5\u88ab\u907f\u514d\u3002 \u88c5\u9970\u6a21\u5f0f \u5728\u8fd9\u4e2a\u95ee\u9898\u4e2d\uff0c TextView \u662f\u4e3b\u4f53\uff0c Border \u548c ScrollBar \u90fd\u662f\u7ed9 TextView \u589e\u52a0\u529f\u80fd\u7684\uff0c\u662f\u9644\u52a0\u7684\u3002\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u5728 TextView \u4e0a\u201c\u6dfb\u52a0\u88c5\u9970\u201d\u6765\u5b9e\u73b0 Border \u548c ScrollBar \u800c\u65e0\u9700\u4fee\u6539 TextView \u3002 \u4ee3\u7801\u5b9e\u73b0 \u589e\u52a0\u4e00\u4e2a Component \u4f5c\u4e3a\u53ef\u663e\u793a\u5185\u5bb9\u7684\u57fa\u7c7b\uff0c TextView \u4f5c\u4e3a\u5176\u5b50\u7c7b\u3002\u800c\u6240\u6709\u7684 \u88c5\u9970\u7c7b \u90fd\u662f\u53ef\u663e\u793a\u7684\uff0c\u4e5f\u5c31\u90fd\u662f Component \u7684\u5b50\u7c7b\u3002 \u5bf9\u4e8e\u4e0d\u540c\u7684\u88c5\u9970\u7c7b\uff0c\u5b9e\u73b0\u4e0d\u540c\u7684\u88c5\u9970\u80fd\u529b\u3002 class Component { public : virtual ~ Component () {} virtual void Draw () = 0 ; }; class TextView : public Component { public : void Draw () { cout << \"TextView.\" << endl ; } }; class Decorator : public Component { public : Decorator ( Component * component ) : component_ ( component ) {} virtual void Addon () = 0 ; void Draw () { Addon (); component_ -> Draw (); } private : Component * component_ ; }; class Border : public Decorator { public : Border ( Component * component ) : Decorator ( component ) {} void Addon () { cout << \"Bordered \" ; } }; class HScroll : public Decorator { public : HScroll ( Component * component ) : Decorator ( component ) {} void Addon () { cout << \"HScrolled \" ; } }; class VScroll : public Decorator { public : VScroll ( Component * component ) : Decorator ( component ) {} void Addon () { cout << \"VScrolled \" ; } }; \u4f7f\u7528\u65f6\u5bf9 TextView \u8fdb\u884c\u9010\u5c42\u88c5\u9970\uff0c\u53ef\u4ee5\u7075\u6d3b\u5f97\u5230\u4e0d\u540c\u7684\u663e\u793a\u6548\u679c int main ( int argc , char ** argv ) { TextView text_view ; VScroll vs_text_view ( & text_view ); HScroll hs_vs_text_view ( & vs_text_view ); Border b_hs_vs_text_view ( & hs_vs_text_view ); b_hs_vs_text_view . Draw (); } \u8f93\u51fa\uff1a Bordered HScrolled VScrolled TextView. \u88c5\u9970\u6a21\u5f0f\u4e0e\u7b56\u7565\u6a21\u5f0f \u88c5\u9970\u6a21\u5f0f \u548c \u7b56\u7565\u6a21\u5f0f \u90fd\u901a\u8fc7\u5bf9\u8c61\u7684\u7ec4\u5408\u4fee\u6539\u5bf9\u8c61\u7684\u529f\u80fd\uff08\u8868\u73b0\uff09\uff0c\u4ee5\u7ec4\u5408\u7684\u65b9\u5f0f\u4ee3\u66ff\u7ee7\u627f\u4f7f\u7528\u66f4\u7075\u6d3b\u3002 \u4e0d\u540c\u70b9 \u7b56\u7565 \u88c5\u9970 \u4fee\u6539\u5bf9\u8c61\u529f\u80fd\u7684\u5185\u6838 \u4fee\u6539\u5bf9\u8c61\u529f\u80fd\u7684\u5916\u58f3 \u7ec4\u5efa\u5fc5\u987b\u4e86\u89e3\u6709\u54ea\u4e9b\u9700\u8981\u9009\u62e9\u7684\u7b56\u7565 \u7ec4\u5efa\u65e0\u9700\u4e86\u89e3\u6709\u54ea\u4e9b\u53ef\u4ee5\u88c5\u9970\u7684\u5185\u5bb9 \u88c5\u9970\u6a21\u5f0f\u4e0e\u4ee3\u7406\u6a21\u5f0f \u88c5\u9970\u6a21\u5f0f \u548c \u4ee3\u7406\u6a21\u5f0f \u90fd\u7528\u6765\u6539\u53d8\u5bf9\u8c61\u7684\u884c\u4e3a\u3002 \u53ef\u4ee5\u628a \u88c5\u9970 \u770b\u505a\u4e00\u8fde\u4e32\u7684 \u4ee3\u7406 \u88c5\u9970 \u4e3a\u88ab\u88c5\u9970\u5bf9\u8c61\u589e\u52a0\u989d\u5916\u884c\u4e3a \u4e0d\u5f71\u54cd\u88ab\u88c5\u9970\u5bf9\u8c61\u7684\u539f\u6709\u529f\u80fd \u4e0d\u521b\u5efa\u88ab\u88c5\u9970\u5bf9\u8c61\uff0c\u53ea\u662f\u5c06\u65b0\u529f\u80fd\u6dfb\u52a0\u5230\u5df2\u6709\u5bf9\u8c61\u4e0a \u7ecf\u5e38\u591a\u5d4c\u5957\u88c5\u9970 \u4ee3\u7406 \u5e38\u7528\u6765\u5bf9\u88ab\u4ee3\u7406\u5bf9\u8c61\u8fdb\u884c\u66f4\u7cbe\u7ec6\u7684\u63a7\u5236 \u88ab\u4ee3\u7406\u5bf9\u8c61\u4e0d\u5b58\u5728\u65f6\u521b\u5efa\u88ab\u4ee3\u7406\u5bf9\u8c61 \u5c11\u89c1\u591a\u91cd\u5d4c\u5957 \u8d23\u4efb\u7684\u4f20\u9012\u4e0e\u8d23\u4efb\u94fe \u88c5\u9970\u5668\u7684\u4f7f\u7528\u6210\u4e00\u79cd\u94fe\u5f0f\u8c03\u7528\u5173\u7cfb\uff0c\u6bcf\u5c42\u5bf9\u8c61\u65e0\u9700\u4e86\u89e3\u6574\u4e2a\u94fe\u7684\u5168\u8c8c\uff0c\u53ea\u9700\u77e5\u9053\u201c\u4e0b\u4e00\u4e2a\u201d\u5bf9\u8c61\u662f\u8c01\u5373\u53ef\u3002 \u8d23\u4efb\u94fe \u5c06\u4e00\u7cfb\u5217\u7684\u5904\u7406\u8005\u8fde\u57ce\u4e00\u6761\u94fe\uff0c\u5c06\u8bf7\u6c42\u6cbf\u7740\u8fd9\u4e2a\u94fe\u4f20\u9012\u5e76\u7531\u94fe\u4e0a\u7684\u5904\u7406\u7740\u4e88\u4ee5\u5904\u7406 \u4e00\u4e2a\u90ae\u4ef6\u8fc7\u6ee4\u5668 \u8bbe\u7f6e\u8fc7\u6ee4\u5668\uff1a\u6839\u636e\u53d1\u4ef6\u4eba\u3001\u6839\u636e\u4e3b\u9898\u3001\u6839\u636e\u5173\u952e\u5b57\u7b49 \u5b9e\u73b0 \u5b9a\u4e49\u8bf7\u6c42 class MailRequest { //... public : string GetSender (); string GetTitle (); string GetBody (); string GetAll (); void Accept () { reject_ = false ; } void Reject () { reject_ = true ; } bool IsReject () { return reject_ ; } private : bool reject_ ; }; \u5b9a\u4e49\u201c\u5904\u7406\u8005\u201d\uff0c\u201c\u5904\u7406\u8005\u201d\u7528 DoHandle() \u505a\u201c\u5206\u5185\u4e4b\u4e8b\u201d\uff0c\u5982\u4e0d\u6210\u529f\u518d\u5c06\u8f7b\u8f68\u53bb\u4f20\u9012\u7ed9\u540e\u7eed\u7684\u5904\u7406\u8005 class Handler { public : Handler ( Handler * successor ) : successor_ ( successor ) {} virtual ~ Handler () {} virtual bool DoHandle ( MailRequest * request ) = 0 ; void Handle ( MailRequest * request ) { if ( ! DoHandle ( request )) { if ( successor_ != nullptr ) successor_ -> Handle ( request ); } } private : Handler * successor_ ; }; \u5b9e\u73b0\u5404\u79cd\u8fc7\u6ee4\u5668\u903b\u8f91 class SenderFilter : public Handler { public : SenderFilter ( Handler * successor ) : Handler ( successor ); bool DoHandle ( MailRequest * request ) { if ( IsWhite ( request -> GetSender ())) { request -> Accept (); return true ; } if ( IsBlack ( request -> GetSender ())) { request -> Reject (); return true ; } return false ; } }; class TitleFilter : public Handler { public : TitleFilter ( Handler * successor ) : Handler ( successor ) {} bool DoHandle ( MailRequest * request ) { if ( ! IsValid ( request -> GetTitle ())) { request -> Reject (); return true ; } return false ; } }; class BodyFilter : public Handler { public : BodyFilter ( Handler * successor ) : Handler ( successor ) {} bool DoHandle ( MailRequest * request ) { for ( auto s : invalid_texts ) { if ( request -> GetBody (). find ( s ) != string :: npos ) { request -> Reject (); return true ; } } return false ; } private : vector < string > invalid_texts = { \"text1\" , \"text2\" /*, .....*/ }; }; \u4e00\u822c\u5728\u8d23\u4efb\u94fe\u672b\u7aef\u6709\u4e00\u4e2a\u7f3a\u7701\u7684\u5904\u7406\u8005 class DefaultFilter : public Handler { public : DefaultFilter ( Handler * successor ) : Handler ( successor ) {} bool DoHandle ( MailRequest * request ) { request -> Accept (); return true ; } }; \u8d23\u4efb\u94fe\u7684\u4ea7\u751f\u4ece\u94fe\u5c3e\u5230\u94fe\u5934\u53cd\u5411\u58f0\u660e\uff0c\u4f7f\u7528\u8d23\u4efb\u94fe\u65f6\u53ea\u8981\u628a\u5904\u7406\u8bf7\u6c42\u4ea4\u7ed9\u8d23\u4efb\u94fe\u5f00\u59cb\u7684\u5904\u7406\u8005\u5373\u53ef\u3002 int main ( int argc , char * argv []) { DefaultFilter f1 ( nullptr ); BodyFilter f2 ( & f1 ); TitleFilter f3 ( & f2 ); SenderFilter f4 ( & f3 ); MailRequest * request = GetRequest (); f4 . Handle ( request ); if ( request -> IsReject ()) { cout << \"Rejected.\" << endl ; } else { cout << \"Accepted.\" << endl ; } } \u4e0e\u88c5\u9970\u3001\u4ee3\u7406\u5bf9\u6bd4 \u8d23\u4efb\u94fe\u4e0e\u88c5\u9970 \u4e24\u8005\u90fd\u6709\u201c\u8c03\u7528\u94fe\u201d\uff0c\u8d23\u4efb\u94fe\u5f3a\u8c03\u7684\u662f\u94fe\u6574\u4f53\u7684\u884c\u4e3a\uff0c\u800c\u88c5\u9970\u5219\u66f4\u5f3a\u8c03\u8c03\u7528\u94fe\u5e26\u6765\u7684\u7ec4\u7ec7\u7ed3\u679c\u3002 \u5177\u4f53\u800c\u8a00\uff0c\u8d23\u4efb\u94fe\u4e0d\u4e00\u5b9a\u8c03\u7528\u5230\u5e95\uff0c\u53ef\u80fd\u5728\u67d0\u4e00\u73af\u5f97\u5230\u7ed3\u679c\uff1b\u4f46\u88c5\u9970\u94fe\u4e00\u5b9a\u8c03\u7528\u5230\u5e95\uff0c\u6bcf\u4e00\u73af\u90fd\u4f1a\u8d77\u4f5c\u7528\u3002 \u8d23\u4efb\u94fe\u4e0e\u4ee3\u7406 \u8d23\u4efb\u94fe\u4e5f\u53ef\u4ee5\u770b\u4f5c\u4e00\u8fde\u4e32\u4ee3\u7406\u3002 \u4ee3\u7406\u5f3a\u8c03\u63a7\u5236\u88ab\u4ee3\u7406\u5bf9\u8c61\uff0c\u6539\u53d8\u5bf9\u8c61\u7684\u884c\u4e3a\uff1b\u8d23\u4efb\u94fe\u5219\u7ec4\u7ec7\u591a\u4e2a\u5bf9\u8c61\u7684\u884c\u4e3a\u3002 \u5c0f\u7ed3 \u672c\u90e8\u5206\u8003\u8651\u5982\u4f55\u5c06\u5c0f\u7684\u7a0b\u5e8f\u6a21\u5757\u7ec4\u5408\u6210\u4e00\u4e2a\u5b8c\u6574\u7684\u9879\u76ee\u3002 \u9002\u914d\u5668\u6a21\u5f0f - \u529f\u80fd\u6ee1\u8db3\uff0c\u63a5\u53e3\u6539\u53d8\u3002 - \u5e94\u7528\u4e3e\u4f8b\uff1a \u7528 std::vector \u5b9e\u73b0\u7684 Stack \u7c7b\u3002 \u4ee3\u7406\u6a21\u5f0f - \u63a5\u53e3\u4e0d\u53d8\uff0c\u529f\u80fd\u589e\u52a0\uff08\u63a7\u5236\u903b\u8f91\uff09 - \u5e94\u7528\u4e3e\u4f8b\uff1a\u667a\u80fd\u6307\u9488\u3002 \u4ee3\u7406\u6a21\u5f0f \u548c \u59d4\u6258\u6a21\u5f0f \u7684\u5173\u7cfb\uff1a \u59d4\u6258 \u5f3a\u8c03\u4e3b\u7c7b\u628a\u529f\u80fd\u4ea4\u51fa\u53bb\uff0c \u4ee3\u7406 \u5219\u5f3a\u8c03\u5728\u4e3b\u7c7b\u6267\u884c\u524d\u6267\u884c\u4e00\u4e9b\u7279\u522b\u64cd\u4f5c\u3002 \u88c5\u9970\u5668\u6a21\u5f0f - \u5728\u53ef\u65b0\u6a21\u5757\u4e0a\u53e0\u52a0\u4e00\u7cfb\u5217\u9644\u52a0\u529f\u80fd\u3002 - \u5e94\u7528\u4e3e\u4f8b\uff1a TextViewer \u52a0\u6eda\u52a8\u6761\u548c\u5de5\u5177\u680f \u8d23\u4efb\u94fe\u6a21\u5f0f - \u5bf9\u5bf9\u8c61\u6267\u884c\u4e00\u7cfb\u5217\u7684\u4efb\u52a1\uff0c\u53ef\u80fd\u7ec8\u6b62\u4e8e\u4efb\u4f55\u4e00\u73af\u3002 - \u5e94\u7528\u4e3e\u4f8b\uff1a\u90ae\u4ef6\u8fc7\u6ee4\u5668 \u53e6\u5916\u6ce8\u610f\u6807\u51c6\u5e93\u548c\u5f00\u6e90\u4ee3\u7801\u7684\u4f7f\u7528\u3002","title":"\u63a5\u53e3\u7ec4\u5408"},{"location":"design_pattern/compose_interfaces/#_1","text":"","title":"\u57fa\u4e8e\u63a5\u53e3\u7ec4\u5408\u5e94\u5bf9\u590d\u6742\u53d8\u5316"},{"location":"design_pattern/compose_interfaces/#_2","text":"\u4f7f\u7528\u5df2\u6709\u8d44\u6e90\u7684\u5e38\u7528\u65b9\u5f0f \u7ee7\u627f\u3001\u7ec4\u5408\u3001\u6a21\u677f\u5b9e\u4f8b\u5316\uff08\u6cdb\u578b\u7f16\u7a0b\uff09 \u4f18\u5148\u4f7f\u7528 \u7ec4\u5408 \u800c\u4e0d\u662f \u7ee7\u627f \uff0c\u56e0\u4e3a\u7ec4\u5408\u6bd4\u8f83\u7075\u6d3b\uff0c\u4f46\u5982\u679c\u65b0\u4ee3\u7801\u91cc\u7684\u5bf9\u8c61\u548c\u539f\u6709\u4ee3\u7801\u7684\u5bf9\u8c61\u6709\u5929\u7136\u7684\u5305\u542b\u5173\u7cfb\uff0c\u5219\u5e94\u8be5\u4f7f\u7528\u7ee7\u627f\u6765\u590d\u7528\u4ee3\u7801\u3002","title":"\u5df2\u6709\u8d44\u6e90\u7684\u7ec4\u5408"},{"location":"design_pattern/compose_interfaces/#_3","text":"\u5b9e\u73b0\u6808\u7c7b\u578b\u2014\u2014FILO\u8868 \u5176\u5b9e\u4f8b\u80fd\u591f\u7ec4\u7ec7\u591a\u4e2a\u540c\u7c7b\u578b\u6570\u636e \u540e\u8fdb\u5148\u51fa \u63d0\u4f9b\u56db\u4e2a\u64cd\u4f5c\uff1a push , pop , top , empty \u5148\u5b9e\u73b0\u6574\u6570\u7684\u6808 \u4e00\u79cd\u65b9\u5f0f\u662f\u53ef\u4ee5\u901a\u8fc7\u7ef4\u62a4\u539f\u59cb\u6570\u7ec4\u7684\u65b9\u5f0f\u6784\u9020\u4e00\u4e2a\u6808\u7c7b\uff1b \u8be5\u6808\u7c7b\u7684\u9700\u6c42\u4e0e std::vector \u7684 push_back , pop_back , back , empty \u63d0\u4f9b\u7684\u529f\u80fd\u7c7b\u4f3c\uff0c\u5728\u5b9e\u73b0\u4e0a\u53ea\u9700\u5728 std::vector \u7684\u57fa\u7840\u4e0a\u5c01\u88c5\u4e00\u5c42\u63a5\u53e3\u5373\u53ef\u3002","title":"\u4ee5\u6808\u4e3a\u4f8b"},{"location":"design_pattern/compose_interfaces/#_4","text":"\u5c06\u63a5\u53e3\u4ee5\u7eaf\u865a\u51fd\u6570\u7684\u5f62\u5f0f\u5b9a\u4e49\u5728\u62bd\u8c61\u7c7b\u91cc\u9762\uff0c\u7531\u5b50\u7c7b\u53bb\u5b9e\u73b0\u3002 \u4f7f\u7528\u7684\u65f6\u5019\u8c03\u7528\u63a5\u53e3\u7c7b\uff0c\u4ee5\u6b64\u4fdd\u8bc1\u4f7f\u7528\u65b9\u5f0f\u4e0d\u53d8\u3002 \u5982\u6b64\u67d0\u4e2a\u7c7b\u7684\u4f7f\u7528\u8005\u548c\u5f00\u53d1\u8005\u7684\u5de5\u4f5c\u88ab\u5b8c\u5168\u9694\u79bb\u5f00\u3002 \u5047\u8bbe\u6309\u7167\u5982\u4e0bUML\u5b9e\u73b0\u57fa\u4e8e std::vector \u7684 Stack \uff1a \u8fd9\u91cc VectorStack \u7c7b\u662f\u4e00\u4e2a \u8f6c\u63a5\u7c7b \uff0c\u529f\u80fd\u7c7b\u4f3c\u4e8ethunder3\u8f6cUSB\u7684\u8f6c\u6362\u5934\u3002","title":"\u5f15\u5165\u63a5\u53e3"},{"location":"design_pattern/compose_interfaces/#_5","text":"\u9002\u914d\u5668\u6a21\u5f0f \uff1a\u5bf9\u4e8e\u529f\u80fd\u6ee1\u8db3\u9700\u6c42\uff0c\u4f46\u63a5\u53e3\u4e0d\u4e00\u81f4\u7684\u60c5\u51b5\uff0c\u5b9a\u4e49\u4e00\u4e2aAdapter\u7c7b\u4f7f\u7528\u7ec4\u5408\u5b9e\u73b0\u9002\u914d\u3002 \u8fd9\u91cc\u7684\u9002\u914d\u5668\u4f7f\u7528\u201c\u7ec4\u5408\u201d\u5b9e\u73b0\uff0c\u4e5f\u53ef\u4ee5\u7528\u201c\u7ee7\u627f\u201d\u5b9e\u73b0\u3002","title":"\u9002\u914d\u5668\u6a21\u5f0f"},{"location":"design_pattern/compose_interfaces/#_6","text":"\u9664\u4e86\u201c\u7ec4\u5408\u201d\u4e4b\u5916\uff0c\u8fd8\u53ef\u4ee5\u4f7f\u7528\u201c\u591a\u91cd\u7ee7\u627f\u201d\u5b9e\u73b0 VectorStack class VectorStack : public Stack , private vector < int > { public : VectorStack () : vector < int > () {} bool empty () { return vector < int >:: empty (); } void push ( int i ) { push_back ( i ); } void pop () { pop_back (); } int top () { return back (); } }; \u7531\u4e8e\u591a\u91cd\u7ee7\u627f\u662f\u5426\u5408\u7406\u5c1a\u5b58\u4e89\u8bba\uff0c\u5b9e\u9645\u4e2d\u4e0d\u5b58\u5728\u6b64\u5b9e\u73b0\u3002 C++\u5047\u8bbe\u7a0b\u5e8f\u5458\u77e5\u9053\u81ea\u5df1\u5728\u5e72\u4ec0\u4e48\uff0c\u6240\u4ee5\u5728\u529f\u80fd\u4e0a\u63d0\u4f9b\u4e86\u591a\u91cd\u7ee7\u627f \u4f7f\u7528\u7ee7\u627f\u5b9e\u73b0\u9002\u914d\uff0c\u79f0\u4f5c \u7c7bAdaapter \uff0cUML\u5982\u4e0b","title":"\u591a\u91cd\u7ee7\u627f"},{"location":"design_pattern/compose_interfaces/#_7","text":"","title":"\u63a5\u53e3\u4e0d\u53d8\u65f6\u7684\u529f\u80fd\u53d8\u5316"},{"location":"design_pattern/compose_interfaces/#_8","text":"\u8003\u8651\u591a\u4e2a\u6307\u9488\u6307\u5411\u76f8\u540c\u7684\u7269\u7406\u5730\u5740\uff0c\u5f53\u5176\u4e2d\u4e00\u4e2a\u6307\u9488\u91ca\u653e\u7684\u65f6\u5019\uff0c\u5176\u4ed6\u7684\u6307\u9488\u53d8\u6210\u4e86\u91ce\u6307\u9488\u3002\u8fd9\u91cc\u51fa\u73b0\u7684\u6839\u672c\u95ee\u9898\u662f\u6307\u9488\u4e4b\u95f4\u4e92\u76f8\u4e0d\u77e5\u9053\u5bf9\u65b9\u7684\u5b58\u5728\u3002","title":"\u667a\u80fd\u6307\u9488\u4e0e\u4ee3\u7406\u6a21\u5f0f"},{"location":"design_pattern/compose_interfaces/#_9","text":"\u95ee\u9898\u4e0a\u8ff0\u95ee\u9898\uff0c\u9700\u8981\u8ddf\u8e2a\u57fa\u7840\u5bf9\u8c61\u88ab\u591a\u5c11\u6307\u9488\u6240\u5171\u4eab\uff0c\u76f4\u5230\u5f15\u7528\u8ba1\u6570\u4e3a 0 0 \u65f6\u624d\u771f\u6b63\u91ca\u653e\u57fa\u7840\u5bf9\u8c61\u3002 \u201c\u667a\u80fd\u6307\u9488\u201d\u6a21\u677f #include <bits/stdc++.h> using namespace std ; template < typename T > class SmartPtr ; template < typename T > class UPtr { // \u8bbe\u8ba1\u4e00\u4e2a\u8f85\u52a9\u7c7b\u7528\u4f5cSmartPtr\u5b9e\u4f53\u7684\u5171\u4eab\u8ba1\u6570 private : friend class SmartPtr < T > ; UPtr ( T * ptr ) : p ( ptr ), count ( 1 ) {} ~ UPtr () { delete p ; } int count ; T * p ; }; template < typename T > class SmartPtr { public : SmartPtr ( T * ptr ) : rp ( new UPtr < T > ( ptr )) {} SmartPtr ( const SmartPtr < T >& sp ) : rp ( sp . rp ) { // \u62f7\u8d1d\u6784\u9020\uff0c\u5f15\u7528\u8ba1\u6570++ ++ rp -> count ; } SmartPtr & operator = ( const SmartPtr < T >& rhs ) { ++ rhs . rp -> count ; // \u5c06rhs\u7684\u5f15\u7528\u8ba1\u6570++ if ( -- rp -> count == 0 ) delete rp ; // \u539f\u6765\u6307\u5411\u5bf9\u8c61\u7684\u5f15\u7528\u8ba1\u6570--\uff0c\u4e3a\u96f6\u5219\u91ca\u653e\u57fa\u7840\u5bf9\u8c61 rp = this . rp ; // \u6267\u884c\u5b9e\u9645\u8d4b\u503c\u64cd\u4f5c return * this ; } ~ SmartPtr () { if ( -- rp -> count == 0 ) delete rp ; // \u6790\u6784\u51fd\u6570\uff0c\u5f15\u7528\u8ba1\u6570--\uff0c\u4e3a\u96f6\u5219\u91ca\u653e\u57fa\u7840\u5bf9\u8c61 } // \u91cd\u8f7d\u6307\u9488\u64cd\u4f5c\u7b26 * \u548c -> T & operator * () { return * ( rp -> p ); } T * operator -> () { return rp -> p ; } private : UPtr < T >* rp ; }; // \u4f7f\u7528\u667a\u80fd\u6307\u9488\uff0c\u65e0\u9700\u8003\u8651\u91ca\u653e\u95ee\u9898 int main ( int argc , char * argv []) { SmartPtr < int > ptr1 ( new int ( 2 )); SmartPtr < int > ptr2 ( ptr1 ); SmartPtr < int > ptr3 = ptr2 ; cout << * ptr1 << endl ; * ptr1 = 20 ; cout << * ptr2 << endl ; } \u8f93\u51fa 2 20","title":"\u5f15\u7528\u8ba1\u6570"},{"location":"design_pattern/compose_interfaces/#_10","text":"SmartPtr<int> \u548c int* \u6709\u76f8\u540c\u7684\u63a5\u53e3 \u64cd\u4f5c\u7b26\uff1a * \u548c -> \u8d4b\u503c\u64cd\u4f5c\u7b26\u4e0e\u521d\u59cb\u5316\uff08\u62f7\u8d1d\u6784\u9020\uff09 \u91ca\u653e\uff08\u6790\u6784\uff09 SmartPtr<int> \u6bd4 int* \u589e\u52a0\u4e86\u4e00\u4e9b\u63a7\u5236\u64cd\u4f5c \u62f7\u8d1d\u6784\u9020\u65f6\u5f15\u7528\u8ba1\u6570 ++ \u6790\u6784\u65f6\u5f15\u7528\u8ba1\u6570 -- \uff0c\u76f4\u5230\u5f15\u7528\u8ba1\u6570\u4e3a\u96f6\u65f6\u91ca\u653e \u8d4b\u503c\u65f6\u5bf9\u5f53\u524d\u5f15\u7528\u8ba1\u6570\u548c\u53c2\u6570\u5f15\u7528\u8ba1\u6570\u5206\u522b\u5904\u7406 \u8fd9\u79cd\u65b9\u5f0f\u88ab\u79f0\u4e3a \u4ee3\u7406\u6a21\u5f0f \u4ee5 SmartPtr \u7684\u8d4b\u503c\u64cd\u4f5c\u7b26 = \u4e3a\u4f8b \u9996\u5148\u505a\u4e00\u4e9b\"\u5176\u4ed6\u64cd\u4f5c\" \u7136\u540e\u6267\u884c\u4e86 int* \u7684\u8d4b\u503c\u64cd\u4f5c \u5728 int* \u7684\u8d4b\u503c\u64cd\u4f5c\u57fa\u7840\u4e0a\u589e\u52a0\u4e86\u66f4\u591a\u529f\u80fd \u63a5\u53e3\u4e0d\u53d8\uff0c\u529f\u80fd\u53d8\u5316 \u5e38\u88ab\u79f0\u4e3a \u4ee3\u7406\u6a21\u5f0f \u7528\u4e8e\u5bf9\u88ab\u4ee3\u7406\u5bf9\u8c61\u8fdb\u884c\u63a7\u5236\uff0c\u5982\u5f15\u7528\u8ba1\u6570\u63a7\u5236\u3001\u6743\u9650\u63a7\u5236\uff08\u88ab\u4ee3\u7406\u5bf9\u8c61\u662f\u5426\u53ef\u4ee5\u88ab\u8bbf\u95ee\uff09\u3001\u8fdc\u7a0b\u4ee3\u7406\uff08\u5c06\u5bf9\u8fdc\u7a0b\u5bf9\u8c61\u7684\u64cd\u4f5c\u4ee3\u7406\u5230\u672c\u5730\u5bf9\u8c61\uff09\u3001\u5ef6\u8fdf\u521d\u59cb\u5316\u7b49\u7b49\u3002","title":"\u667a\u80fd\u6307\u9488\u5206\u6790"},{"location":"design_pattern/compose_interfaces/#_11","text":"\u6709\u4e9b\u5bf9\u8c61\u7684\u521d\u59cb\u5316\u65f6\u95f4\u8f83\u957f\uff0c\u6bd4\u5982\u9700\u8981\u505a\u6570\u636e\u5e93\u8fde\u63a5\u7b49\u3002\u5bf9\u4e8e\u8fd9\u79cd\u60c5\u51b5\u53ef\u4ee5\u7b49\u5230\u5b9e\u9645\u4f7f\u7528\u7684\u65f6\u5019\u518d\u521d\u59cb\u5316\u3002 \u5ef6\u8fdf\u521d\u59cb\u5316\u7ecf\u5e38\u4e0e\u5f15\u7528\u8ba1\u6570\u7ed3\u5408\u4f7f\u7528\uff0c\u51cf\u5c11\u521d\u59cb\u5316\u7684\u6b21\u6570\u3002 class Proxy : public Object { public : Proxy () : object_ ( nullptr ) {} // \u4ee3\u7406\u7c7b\u5bf9\u8c61\u521d\u59cb\u5316\u65f6\u4e0d\u521d\u59cb\u5316\u5b9e\u9645\u5bf9\u8c61 ~ Proxy () { if ( object_ != nullptr ) delete object_ ; } void run () { // \u5b9e\u9645\u5bf9\u8c61\u521d\u59cb\u5316\u88ab\u5ef6\u8fdf\u5230\u8c03\u7528run\u51fd\u6570\u65f6\u8fdb\u884c if ( object_ == nullptr ) object_ = new RealObject (); object_ -> run (); // run\u51fd\u6570\u672c\u6765\u7684\u529f\u80fd } private : RealObject * object_ ; }; int main ( int argc , char * argv []) { Proxy proxy ; proxy . run (); } Lazy load\u7684\u597d\u5904\uff1a \u51cf\u5c11\u521d\u59cb\u5316\u65f6\u95f4 \u5f53\u548c\u5f15\u7528\u8ba1\u6570\u7ed3\u5408\u7684\u65f6\u5019\u80fd\u591f\u8282\u7701\u4e0d\u5fc5\u8981\u7684\u521d\u59cb\u5316\u8fc7\u7a0b\u3002\uff08\u5c06\u591a\u4e2aProxy\u6307\u5411\u540c\u4e00\u4e2a\u5b9e\u9645\u5bf9\u8c61\uff09 \u6709\u4e9b\u5bf9\u8c61\u521d\u59cb\u5316\u4e4b\u540e\u4e0d\u4e00\u5b9a\u88ab\u4f7f\u7528\uff0c\u91c7\u7528lazy load\u7684\u65b9\u5f0f\u53ef\u4ee5\u51cf\u5c11\u8fd9\u79cd\u60c5\u51b5\u4e0b\u7684\u8d44\u6e90\u6d6a\u8d39","title":"\u5ef6\u8fdf\u521d\u59cb\u5316"},{"location":"design_pattern/compose_interfaces/#_12","text":"","title":"\u88c5\u9970"},{"location":"design_pattern/compose_interfaces/#textviewer","text":"\u5047\u8bbe\u73b0\u6709\u4e00\u4e2a TextView \u5bf9\u8c61\uff0c\u80fd\u591f\u5728\u7a97\u53e3\u4e2d\u663e\u793a\u6587\u5b57\u3002\u73b0\u5728\u5e0c\u671b\u63a5\u53e3\u4e0d\u53d8\uff0c\u589e\u52a0\u6eda\u52a8\u6761\u3001\u8fb9\u6846\u3001...","title":"\u4ece\u5b9e\u73b0\u4e00\u4e2aTextViewer\u5f00\u59cb"},{"location":"design_pattern/compose_interfaces/#_13","text":"\u5229\u7528C++\u4e2d\u7684\u7ee7\u627f\uff0c\u4f9d\u9760\u591a\u6001\u5b9e\u73b0\u529f\u80fd\u591a\u6837\u5316\uff1a \u5f0a\u7aef\uff1a\u591a\u79cd TextView \u4e4b\u95f4\u6ca1\u6709\u5c42\u6b21\u5173\u7cfb\uff0c\u4e0d\u7528\u7684View\u4e4b\u95f4\u76f8\u4e92\u72ec\u7acb\u3002\u7531\u6b64\u5f53\u9700\u8981\u7684\u9644\u4ef6\u589e\u591a\u7684\u65f6\u5019\u4f1a\u5bfc\u81f4 TextView \u7c7b\u4f53\u7cfb\u81a8\u80c0 \u3001\u4ee3\u7801\u5927\u91cf\u5197\u4f59\u3002","title":"\u4f7f\u7528\u7ee7\u627f\u5b9e\u73b0"},{"location":"design_pattern/compose_interfaces/#_14","text":"\u7528\u7ec4\u5408\u66ff\u4ee3\u7ee7\u627f\uff0c\u4f7f\u7528\u7ec4\u5408\u52a8\u6001\u6539\u53d8\u7b56\u7565\u4ee5\u5b9e\u73b0\u591a\u53d8\u7684\u529f\u80fd \u7b56\u7565\u9009\u9879\u4e4b\u95f4\u76f8\u4e92\u72ec\u7acb\u4f7f\u5f97\u7ec4\u5408\u66f4\u52a0\u7075\u6d3b\uff0c\u6709\u6548\u6291\u5236\u4e86 \u7c7b\u81a8\u80c0 \u95ee\u9898\u3002 \u4f46\u662f\uff0c\u7b56\u7565\u9009\u9879\u9700\u8981\u9884\u5148\u5b9a\u4e49\uff0c\u65e0\u6cd5\u589e\u52a0\u3002\u4f8b\u5982\uff0c\u5f53\u6211\u4eec\u9700\u8981\u589e\u52a0\u4e00\u4e2a\u201c\u5de5\u5177\u680f\u201d\u7684\u65f6\u5019\uff0c\u9700\u8981\u5728 TextView \u5927\u7c7b\u8fdb\u884c\u4fee\u6539\uff0c\u8fd9\u79cd\u64cd\u4f5c\u5e94\u8be5\u88ab\u907f\u514d\u3002","title":"\u4f7f\u7528\u7b56\u7565\u6a21\u5f0f"},{"location":"design_pattern/compose_interfaces/#_15","text":"\u5728\u8fd9\u4e2a\u95ee\u9898\u4e2d\uff0c TextView \u662f\u4e3b\u4f53\uff0c Border \u548c ScrollBar \u90fd\u662f\u7ed9 TextView \u589e\u52a0\u529f\u80fd\u7684\uff0c\u662f\u9644\u52a0\u7684\u3002\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u5728 TextView \u4e0a\u201c\u6dfb\u52a0\u88c5\u9970\u201d\u6765\u5b9e\u73b0 Border \u548c ScrollBar \u800c\u65e0\u9700\u4fee\u6539 TextView \u3002","title":"\u88c5\u9970\u6a21\u5f0f"},{"location":"design_pattern/compose_interfaces/#_16","text":"\u589e\u52a0\u4e00\u4e2a Component \u4f5c\u4e3a\u53ef\u663e\u793a\u5185\u5bb9\u7684\u57fa\u7c7b\uff0c TextView \u4f5c\u4e3a\u5176\u5b50\u7c7b\u3002\u800c\u6240\u6709\u7684 \u88c5\u9970\u7c7b \u90fd\u662f\u53ef\u663e\u793a\u7684\uff0c\u4e5f\u5c31\u90fd\u662f Component \u7684\u5b50\u7c7b\u3002 \u5bf9\u4e8e\u4e0d\u540c\u7684\u88c5\u9970\u7c7b\uff0c\u5b9e\u73b0\u4e0d\u540c\u7684\u88c5\u9970\u80fd\u529b\u3002 class Component { public : virtual ~ Component () {} virtual void Draw () = 0 ; }; class TextView : public Component { public : void Draw () { cout << \"TextView.\" << endl ; } }; class Decorator : public Component { public : Decorator ( Component * component ) : component_ ( component ) {} virtual void Addon () = 0 ; void Draw () { Addon (); component_ -> Draw (); } private : Component * component_ ; }; class Border : public Decorator { public : Border ( Component * component ) : Decorator ( component ) {} void Addon () { cout << \"Bordered \" ; } }; class HScroll : public Decorator { public : HScroll ( Component * component ) : Decorator ( component ) {} void Addon () { cout << \"HScrolled \" ; } }; class VScroll : public Decorator { public : VScroll ( Component * component ) : Decorator ( component ) {} void Addon () { cout << \"VScrolled \" ; } }; \u4f7f\u7528\u65f6\u5bf9 TextView \u8fdb\u884c\u9010\u5c42\u88c5\u9970\uff0c\u53ef\u4ee5\u7075\u6d3b\u5f97\u5230\u4e0d\u540c\u7684\u663e\u793a\u6548\u679c int main ( int argc , char ** argv ) { TextView text_view ; VScroll vs_text_view ( & text_view ); HScroll hs_vs_text_view ( & vs_text_view ); Border b_hs_vs_text_view ( & hs_vs_text_view ); b_hs_vs_text_view . Draw (); } \u8f93\u51fa\uff1a Bordered HScrolled VScrolled TextView.","title":"\u4ee3\u7801\u5b9e\u73b0"},{"location":"design_pattern/compose_interfaces/#_17","text":"\u88c5\u9970\u6a21\u5f0f \u548c \u7b56\u7565\u6a21\u5f0f \u90fd\u901a\u8fc7\u5bf9\u8c61\u7684\u7ec4\u5408\u4fee\u6539\u5bf9\u8c61\u7684\u529f\u80fd\uff08\u8868\u73b0\uff09\uff0c\u4ee5\u7ec4\u5408\u7684\u65b9\u5f0f\u4ee3\u66ff\u7ee7\u627f\u4f7f\u7528\u66f4\u7075\u6d3b\u3002 \u4e0d\u540c\u70b9 \u7b56\u7565 \u88c5\u9970 \u4fee\u6539\u5bf9\u8c61\u529f\u80fd\u7684\u5185\u6838 \u4fee\u6539\u5bf9\u8c61\u529f\u80fd\u7684\u5916\u58f3 \u7ec4\u5efa\u5fc5\u987b\u4e86\u89e3\u6709\u54ea\u4e9b\u9700\u8981\u9009\u62e9\u7684\u7b56\u7565 \u7ec4\u5efa\u65e0\u9700\u4e86\u89e3\u6709\u54ea\u4e9b\u53ef\u4ee5\u88c5\u9970\u7684\u5185\u5bb9","title":"\u88c5\u9970\u6a21\u5f0f\u4e0e\u7b56\u7565\u6a21\u5f0f"},{"location":"design_pattern/compose_interfaces/#_18","text":"\u88c5\u9970\u6a21\u5f0f \u548c \u4ee3\u7406\u6a21\u5f0f \u90fd\u7528\u6765\u6539\u53d8\u5bf9\u8c61\u7684\u884c\u4e3a\u3002 \u53ef\u4ee5\u628a \u88c5\u9970 \u770b\u505a\u4e00\u8fde\u4e32\u7684 \u4ee3\u7406 \u88c5\u9970 \u4e3a\u88ab\u88c5\u9970\u5bf9\u8c61\u589e\u52a0\u989d\u5916\u884c\u4e3a \u4e0d\u5f71\u54cd\u88ab\u88c5\u9970\u5bf9\u8c61\u7684\u539f\u6709\u529f\u80fd \u4e0d\u521b\u5efa\u88ab\u88c5\u9970\u5bf9\u8c61\uff0c\u53ea\u662f\u5c06\u65b0\u529f\u80fd\u6dfb\u52a0\u5230\u5df2\u6709\u5bf9\u8c61\u4e0a \u7ecf\u5e38\u591a\u5d4c\u5957\u88c5\u9970 \u4ee3\u7406 \u5e38\u7528\u6765\u5bf9\u88ab\u4ee3\u7406\u5bf9\u8c61\u8fdb\u884c\u66f4\u7cbe\u7ec6\u7684\u63a7\u5236 \u88ab\u4ee3\u7406\u5bf9\u8c61\u4e0d\u5b58\u5728\u65f6\u521b\u5efa\u88ab\u4ee3\u7406\u5bf9\u8c61 \u5c11\u89c1\u591a\u91cd\u5d4c\u5957","title":"\u88c5\u9970\u6a21\u5f0f\u4e0e\u4ee3\u7406\u6a21\u5f0f"},{"location":"design_pattern/compose_interfaces/#_19","text":"\u88c5\u9970\u5668\u7684\u4f7f\u7528\u6210\u4e00\u79cd\u94fe\u5f0f\u8c03\u7528\u5173\u7cfb\uff0c\u6bcf\u5c42\u5bf9\u8c61\u65e0\u9700\u4e86\u89e3\u6574\u4e2a\u94fe\u7684\u5168\u8c8c\uff0c\u53ea\u9700\u77e5\u9053\u201c\u4e0b\u4e00\u4e2a\u201d\u5bf9\u8c61\u662f\u8c01\u5373\u53ef\u3002","title":"\u8d23\u4efb\u7684\u4f20\u9012\u4e0e\u8d23\u4efb\u94fe"},{"location":"design_pattern/compose_interfaces/#_20","text":"\u5c06\u4e00\u7cfb\u5217\u7684\u5904\u7406\u8005\u8fde\u57ce\u4e00\u6761\u94fe\uff0c\u5c06\u8bf7\u6c42\u6cbf\u7740\u8fd9\u4e2a\u94fe\u4f20\u9012\u5e76\u7531\u94fe\u4e0a\u7684\u5904\u7406\u7740\u4e88\u4ee5\u5904\u7406","title":"\u8d23\u4efb\u94fe"},{"location":"design_pattern/compose_interfaces/#_21","text":"\u8bbe\u7f6e\u8fc7\u6ee4\u5668\uff1a\u6839\u636e\u53d1\u4ef6\u4eba\u3001\u6839\u636e\u4e3b\u9898\u3001\u6839\u636e\u5173\u952e\u5b57\u7b49","title":"\u4e00\u4e2a\u90ae\u4ef6\u8fc7\u6ee4\u5668"},{"location":"design_pattern/compose_interfaces/#_22","text":"\u5b9a\u4e49\u8bf7\u6c42 class MailRequest { //... public : string GetSender (); string GetTitle (); string GetBody (); string GetAll (); void Accept () { reject_ = false ; } void Reject () { reject_ = true ; } bool IsReject () { return reject_ ; } private : bool reject_ ; }; \u5b9a\u4e49\u201c\u5904\u7406\u8005\u201d\uff0c\u201c\u5904\u7406\u8005\u201d\u7528 DoHandle() \u505a\u201c\u5206\u5185\u4e4b\u4e8b\u201d\uff0c\u5982\u4e0d\u6210\u529f\u518d\u5c06\u8f7b\u8f68\u53bb\u4f20\u9012\u7ed9\u540e\u7eed\u7684\u5904\u7406\u8005 class Handler { public : Handler ( Handler * successor ) : successor_ ( successor ) {} virtual ~ Handler () {} virtual bool DoHandle ( MailRequest * request ) = 0 ; void Handle ( MailRequest * request ) { if ( ! DoHandle ( request )) { if ( successor_ != nullptr ) successor_ -> Handle ( request ); } } private : Handler * successor_ ; }; \u5b9e\u73b0\u5404\u79cd\u8fc7\u6ee4\u5668\u903b\u8f91 class SenderFilter : public Handler { public : SenderFilter ( Handler * successor ) : Handler ( successor ); bool DoHandle ( MailRequest * request ) { if ( IsWhite ( request -> GetSender ())) { request -> Accept (); return true ; } if ( IsBlack ( request -> GetSender ())) { request -> Reject (); return true ; } return false ; } }; class TitleFilter : public Handler { public : TitleFilter ( Handler * successor ) : Handler ( successor ) {} bool DoHandle ( MailRequest * request ) { if ( ! IsValid ( request -> GetTitle ())) { request -> Reject (); return true ; } return false ; } }; class BodyFilter : public Handler { public : BodyFilter ( Handler * successor ) : Handler ( successor ) {} bool DoHandle ( MailRequest * request ) { for ( auto s : invalid_texts ) { if ( request -> GetBody (). find ( s ) != string :: npos ) { request -> Reject (); return true ; } } return false ; } private : vector < string > invalid_texts = { \"text1\" , \"text2\" /*, .....*/ }; }; \u4e00\u822c\u5728\u8d23\u4efb\u94fe\u672b\u7aef\u6709\u4e00\u4e2a\u7f3a\u7701\u7684\u5904\u7406\u8005 class DefaultFilter : public Handler { public : DefaultFilter ( Handler * successor ) : Handler ( successor ) {} bool DoHandle ( MailRequest * request ) { request -> Accept (); return true ; } }; \u8d23\u4efb\u94fe\u7684\u4ea7\u751f\u4ece\u94fe\u5c3e\u5230\u94fe\u5934\u53cd\u5411\u58f0\u660e\uff0c\u4f7f\u7528\u8d23\u4efb\u94fe\u65f6\u53ea\u8981\u628a\u5904\u7406\u8bf7\u6c42\u4ea4\u7ed9\u8d23\u4efb\u94fe\u5f00\u59cb\u7684\u5904\u7406\u8005\u5373\u53ef\u3002 int main ( int argc , char * argv []) { DefaultFilter f1 ( nullptr ); BodyFilter f2 ( & f1 ); TitleFilter f3 ( & f2 ); SenderFilter f4 ( & f3 ); MailRequest * request = GetRequest (); f4 . Handle ( request ); if ( request -> IsReject ()) { cout << \"Rejected.\" << endl ; } else { cout << \"Accepted.\" << endl ; } }","title":"\u5b9e\u73b0"},{"location":"design_pattern/compose_interfaces/#_23","text":"","title":"\u4e0e\u88c5\u9970\u3001\u4ee3\u7406\u5bf9\u6bd4"},{"location":"design_pattern/compose_interfaces/#_24","text":"\u4e24\u8005\u90fd\u6709\u201c\u8c03\u7528\u94fe\u201d\uff0c\u8d23\u4efb\u94fe\u5f3a\u8c03\u7684\u662f\u94fe\u6574\u4f53\u7684\u884c\u4e3a\uff0c\u800c\u88c5\u9970\u5219\u66f4\u5f3a\u8c03\u8c03\u7528\u94fe\u5e26\u6765\u7684\u7ec4\u7ec7\u7ed3\u679c\u3002 \u5177\u4f53\u800c\u8a00\uff0c\u8d23\u4efb\u94fe\u4e0d\u4e00\u5b9a\u8c03\u7528\u5230\u5e95\uff0c\u53ef\u80fd\u5728\u67d0\u4e00\u73af\u5f97\u5230\u7ed3\u679c\uff1b\u4f46\u88c5\u9970\u94fe\u4e00\u5b9a\u8c03\u7528\u5230\u5e95\uff0c\u6bcf\u4e00\u73af\u90fd\u4f1a\u8d77\u4f5c\u7528\u3002","title":"\u8d23\u4efb\u94fe\u4e0e\u88c5\u9970"},{"location":"design_pattern/compose_interfaces/#_25","text":"\u8d23\u4efb\u94fe\u4e5f\u53ef\u4ee5\u770b\u4f5c\u4e00\u8fde\u4e32\u4ee3\u7406\u3002 \u4ee3\u7406\u5f3a\u8c03\u63a7\u5236\u88ab\u4ee3\u7406\u5bf9\u8c61\uff0c\u6539\u53d8\u5bf9\u8c61\u7684\u884c\u4e3a\uff1b\u8d23\u4efb\u94fe\u5219\u7ec4\u7ec7\u591a\u4e2a\u5bf9\u8c61\u7684\u884c\u4e3a\u3002","title":"\u8d23\u4efb\u94fe\u4e0e\u4ee3\u7406"},{"location":"design_pattern/compose_interfaces/#_26","text":"\u672c\u90e8\u5206\u8003\u8651\u5982\u4f55\u5c06\u5c0f\u7684\u7a0b\u5e8f\u6a21\u5757\u7ec4\u5408\u6210\u4e00\u4e2a\u5b8c\u6574\u7684\u9879\u76ee\u3002 \u9002\u914d\u5668\u6a21\u5f0f - \u529f\u80fd\u6ee1\u8db3\uff0c\u63a5\u53e3\u6539\u53d8\u3002 - \u5e94\u7528\u4e3e\u4f8b\uff1a \u7528 std::vector \u5b9e\u73b0\u7684 Stack \u7c7b\u3002 \u4ee3\u7406\u6a21\u5f0f - \u63a5\u53e3\u4e0d\u53d8\uff0c\u529f\u80fd\u589e\u52a0\uff08\u63a7\u5236\u903b\u8f91\uff09 - \u5e94\u7528\u4e3e\u4f8b\uff1a\u667a\u80fd\u6307\u9488\u3002 \u4ee3\u7406\u6a21\u5f0f \u548c \u59d4\u6258\u6a21\u5f0f \u7684\u5173\u7cfb\uff1a \u59d4\u6258 \u5f3a\u8c03\u4e3b\u7c7b\u628a\u529f\u80fd\u4ea4\u51fa\u53bb\uff0c \u4ee3\u7406 \u5219\u5f3a\u8c03\u5728\u4e3b\u7c7b\u6267\u884c\u524d\u6267\u884c\u4e00\u4e9b\u7279\u522b\u64cd\u4f5c\u3002 \u88c5\u9970\u5668\u6a21\u5f0f - \u5728\u53ef\u65b0\u6a21\u5757\u4e0a\u53e0\u52a0\u4e00\u7cfb\u5217\u9644\u52a0\u529f\u80fd\u3002 - \u5e94\u7528\u4e3e\u4f8b\uff1a TextViewer \u52a0\u6eda\u52a8\u6761\u548c\u5de5\u5177\u680f \u8d23\u4efb\u94fe\u6a21\u5f0f - \u5bf9\u5bf9\u8c61\u6267\u884c\u4e00\u7cfb\u5217\u7684\u4efb\u52a1\uff0c\u53ef\u80fd\u7ec8\u6b62\u4e8e\u4efb\u4f55\u4e00\u73af\u3002 - \u5e94\u7528\u4e3e\u4f8b\uff1a\u90ae\u4ef6\u8fc7\u6ee4\u5668 \u53e6\u5916\u6ce8\u610f\u6807\u51c6\u5e93\u548c\u5f00\u6e90\u4ee3\u7801\u7684\u4f7f\u7528\u3002","title":"\u5c0f\u7ed3"},{"location":"design_pattern/object_and_interface/","text":"\u5bf9\u8c61\u4e0e\u63a5\u53e3 \u4eceFOP\u5230OOP FOP - Functional oriented programming OOP - Object oriented programming \u76ee\u6807\uff1a\u5f15\u51fa\u5bf9\u8c61 \u601d\u8003\uff1a\u5982\u4f55\u786e\u5b9a\u5bf9\u8c61\u8fb9\u754c\u3001\u5c01\u88c5\u4ec0\u4e48\u3001\u66b4\u9732\u4ec0\u4e48\u3001\u9690\u85cf\u4ec0\u4e48 \u4ee5\u201d\u7535\u5b50\u8ba1\u4ef7\u5668\u4e3a\u4f8b\u201c \u5b9e\u73b0\u4e00\u4e2a\u7535\u5b50\u8ba1\u4ef7\u5668\uff0c\u6839\u636e\u591a\u4e2a\u5546\u54c1\u7684\u5355\u4ef7\u548c\u91cd\u91cf\u8ba1\u7b97\u603b\u4ef7\u3002 FOP\u7248\u672c #include <iostream> using namespace std ; int main () { float apple_price = 5.5 ; float banana_price = 3.4 ; float apple_weight = 0.0 ; float banana_weight = 0.0 ; float total = 0.0 ; cout << \"Weight of apple: \" << endl ; cin >> apple_weight ; cout << \"Weight of banana: \" << endl ; cin >> banana_weight ; total = apple_price * apple_weight + banana_price * banana_weight ; cout << \"Payment: \" << total << endl ; } \u53d8\u5316\u5206\u5c42 \u5bf9\u4e8e\u6bcf\u6b21\u90fd\u8981\u53d8\u5316\u7684\u201c\u91cd\u91cf\u201d\uff0c\u201c\u5355\u4ef7\u201d\u662f\u76f8\u5bf9\u4e0d\u53d8\u7684\u3002 \u4e3a\u533a\u5206\u4e24\u79cd\u4e0d\u540c\u5c42\u6b21\u7684\u201c\u53d8\u5316\u201d\uff0c\u201c\u5355\u4ef7\u201d\u5e94\u8be5\u88ab\u5c01\u5728\u8ba1\u4ef7\u5668\u91cc OOP\u7248\u672c #include <iostream> using namespace std ; class Calculator { public : Calculator ( float _apple_price , float _banana_price ) : apple_price ( _apple_price ), banana_price ( _banana_price ) {} float CalTotal ( float apple_weight , float banana_weight ); private : float apple_price , banana_price ; }; float Calculator :: CalTotal ( float apple_weight , float banana_weight ) { return apple_price * apple_weight + banana_price * banana_weight ; } int main () { Calculator c ( 5.5 , 3.4 ); float apple_weight = 0.0 ; float banana_weight = 0.0 ; cout << \"Weight of apple: \" << endl ; cin >> apple_weight ; cout << \"Weight of banana: \" << endl ; cin >> banana_weight ; cout << \"Payment: \" << c . CalTotal ( apple_weight , banana_weight ) << endl ; } \u5c01\u88c5 \u628a\u4e0d\u5e38\u53d8\u5316\u7684 apple_price \u548c banana_price \u5c01\u88c5\u8d77\u6765\uff0c\u5f62\u6210 Calculator \u6982\u5ff5\uff0c\u4f7f\u7528 Calculator \u65f6\u628a\u7ecf\u5e38\u53d8\u5316\u7684\u91cd\u91cf\u4f5c\u4e3a\u53c2\u6570\u3002 \u63a5\u53e3\uff1a\u7c7b\u66b4\u9732\u51fa\u6765\u7684\u90e8\u5206\uff0c\u662f\u7c7b\u6240\u63d0\u4f9b\u7684\u529f\u80fd\uff0c\u9690\u85cf\u5b9e\u73b0\u7ec6\u8282 UML\u7c7b\u56fe Calculator - apple_price: float - banana_price: float + CalTotal(in apple_weight: float, in banana_weight:float): float \u5982\u4f55\u62bd\u8c61\u51fa\u5bf9\u8c61 \u95ee\u9898 A, B, C, D A, B, C, D \u56db\u4e2a\u4eba\uff0c\u5176\u4e2d\u4e00\u4e2a\u4eba\u662f PyTorch \u7684\u4f5c\u8005\uff0c\u5bf9\u6b64\u56db\u4e2a\u4eba\u5206\u522b\u4f5c\u4e86\u9648\u8ff0\uff1a A A : \u4e0d\u662f\u6211 B B : \u4f5c\u8005\u662f C C C C : \u4f5c\u8005\u662f D D D D : C C \u8bf4\u5f97\u4e0d\u5bf9\u3000 \u5df2\u77e5\u5176\u4e2d\u6709\u4e09\u53e5\u771f\u8bdd\u3001\u4e00\u53e5\u5047\u8bdd\uff0c\u95ee\u4f5c\u8005\u662f\u8c01\uff1f FOP\u7248\u672c #include <iostream> using namespace std ; int main () { for ( char author = 'A' ; author <= 'D' ; author ++ ) { int count = 0 ; count += ( author != 'A' ); count += ( author == 'C' ); count += ( author == 'D' ); count += ( author != 'D' ); if ( count == 3 ) { cout << \"The author could be \" << author << endl ; break ; } } return 0 ; } OOP\u7248\u672c \u95ee\u9898\u4e2d\u53ef\u53d8\u7684\u90e8\u5206 \u63cf\u8ff0\u65b9\u6cd5 \u5019\u9009\u4eba\u6570\u91cf\u3000\u3000 \u6574\u578b\u53c2\u6570 n n \u771f\u5b9e\u9648\u8ff0\u7684\u6570\u91cf \u6574\u578b\u53c2\u6570\u3000 correct correct \u6bcf\u4e2a\u5019\u9009\u4eba\u7684\u9648\u8ff0\u7684\u771f\u5b9e\u6027 \u4e00\u7ec4\u4e0e\u5019\u9009\u4eba\u5bf9\u5e94\u7684\u8fd4\u56de\u5e03\u5c14\u578b\u7684\u51fd\u6570 \u6ce8\u610f\u5230\uff0c\u5bf9\u4e8e\u8fd4\u56de\u6bcf\u4e2a\u5019\u9009\u4eba\u7684\u9648\u8ff0\u771f\u5b9e\u6027\u7684\u51fd\u6570\uff0c\u51fd\u6570\u7684\u5185\u90e8\u903b\u8f91\u4f9d\u8d56\u4e8e\u9648\u8ff0\u672c\u8eab\u3002\u53e6\u4e00\u65b9\u9762\uff0c\u9648\u8ff0\u540c\u610f\u53ef\u4ee5\u8868\u8ff0\u4e3a\u4f5c\u8005\u3000\u662f/\u4e0d\u662f\u3000\u201c\u67d0\u4e2a\u4eba\u201d\u7684\u5f62\u5f0f\u3002 \u53ef\u4ee5\u91cd\u8f7d () \u8fd0\u7b97\u7b26\u6765\u5b9e\u73b0\u3002 #include <iostream> using namespace std ; class Candidate { public : Candidate ( bool _equal , char _author ) : equal ( _equal ), author ( _author ) {} bool operator ()( char suspect ); private : char author ; bool equal ; }; bool Candidate :: operator ()( char suspect ) { return equal ? ( suspect == author ) : ( suspect != author ); } char solve ( int number , int correct , Candidate * candidates ) { for ( int i = 0 ; i < number ; i ++ ) { int count = 0 ; char suspect = 'A' + i ; for ( int j = 0 ; j < number ; j ++ ) count += candidates [ j ]( suspect ); cout << count << endl ; if ( count == correct ) return suspect ; } return '\\0' ; } int main () { Candidate candidates [] = { Candidate ( false , 'A' ), Candidate ( true , 'C' ), Candidate ( true , 'D' ), Candidate ( false , 'D' )}; char suspect = solve ( 4 , 3 , candidates ); if ( suspect != '\\0' ) { cout << \"The author is \" << suspect << endl ; } else { cout << \"Nooooooooooooooop!\" << endl ; } } \u57fa\u4e8eOOP\u7248\u672c\u7684\u5b9e\u73b0\uff0c\u95ee\u9898\u53ef\u4ee5\u5f88\u5bb9\u6613\u5730\u6269\u5c55\u5230 n n \u4e2a\u5019\u9009\u4eba\uff0c\u4e14\u6709 m m \u4e2a\u5019\u9009\u4eba\u7684\u9648\u8ff0\u771f\u5b9e\u7684\u60c5\u51b5\u3002 \u5982\u4f55\u5b9a\u4e49\u63a5\u53e3 \u95ee\u9898\uff1a\u65cb\u8f6c\u77e9\u9635 \u8bbe\u8ba1\u4e00\u4e2a\u7c7b\uff0c\u5bf9\u4e8e\u7ed9\u5b9a\u6574\u6570 N N \uff0c\u8f93\u51fa\u65cb\u8f6c\u77e9\u9635\uff0c\u5f62\u5f0f\u5982\u4e0b\uff1a 1, 16, 15, 14, 13\\\\ 2, 17, 24, 23, 12\\\\ 3, 18, 25, 22, 11\\\\ 4, 19, 20, 21, 10\\\\ 5, 6, 7, 8, 9 1, 16, 15, 14, 13\\\\ 2, 17, 24, 23, 12\\\\ 3, 18, 25, 22, 11\\\\ 4, 19, 20, 21, 10\\\\ 5, 6, 7, 8, 9 \u8bbe\u8ba1\u601d\u8def\uff1a\u81ea\u9876\u5411\u4e0b \u8fd9\u4e2a\u7c7b\u5982\u4f55\u88ab\u4f7f\u7528\uff1f Matrix obj ( size ); obj . fill (); cout << obj ; \u6839\u636e\u4f7f\u7528\u65b9\u6cd5\u8bbe\u8ba1 Matrix \u7684\u63a5\u53e3 class matrix { public : Matrix ( int size ); void fill (); friend ostream & operator << ( ostream & out , const Matrix & m ); }; \u5b9e\u73b0\u7c7b\u7684\u63a5\u53e3 \u786e\u5b9a\u9700\u8981\u54ea\u4e9b\u6210\u5458\u53d8\u91cf class Matrix { public : Matrix ( int size ); ~ Matrix (); void fill (); friend ostream & operator << ( ostream & out , const Matrix & m ); private : int size_ ; int * data_ ; }; \u5b9e\u73b0\u6784\u9020\u51fd\u6570\u3001\u6790\u6784\u51fd\u6570\u548c\u8f93\u51fa\u6d41\u64cd\u4f5c\u7b26 Matrix :: Matrix ( int size ) : size_ ( size ) { data_ = new int [ size * size ]; memset ( data_ , 0 , sizeof ( int ) * size_ * size_ ); } Matrix ::~ Matrix () { delete [] data_ ; } ostream & operator << ( ostream & out , const Matrix & m ) { for ( int r = 0 ; r < m . size_ ; r ++ ) { for ( int c = 0 ; c < m . size_ ; c ++ ) cout << * ( m . data_ + r * m . size_ + c ) << '\\t' ; cout << endl ; } } \u5b9e\u73b0\u586b\u5145\u51fd\u6570 \u589e\u52a0\u4e00\u4e2a\u8f85\u52a9\u51fd\u6570\u8ba1\u7b97\u5e76\u586b\u5145 class Matrix { public : ... private : ... int FindPosition (); }; void Matrix :: fill () { for ( int num = 1 ; num <= size_ * size_ ; num ++ ) { int pos = FindPosition (); data_ [ pos ] = num ; } } \u5269\u4e0b\u7684\u4efb\u52a1\u5c31\u662f\u5b9e\u73b0 FindPosition() \u3002 \u5bf9\u4e8e\u4e0d\u540c\u7684\u77e9\u9635\u5f62\u5f0f\uff0c\u4e5f\u53ea\u9700\u6539\u53d8 FindPosition \u5373\u53ef\u3002 \u591a\u6001\u7684\u5e94\u7528 \u7a0b\u5e8f\u8bbe\u8ba1\u7684 \u5f00\u95ed\u539f\u5219 \uff0c\u7a0b\u5e8f\u5bf9\u53d8\u5316\u7684\u9700\u6c42\u5e94\u8be5\u662fopen\u7684\uff0c\u4f46\u5e94\u8be5\u5c3d\u91cf\u4e0d\u6539\u52a8\u539f\u6709\u4ee3\u7801 \u8fd9\u65f6\u53ef\u4ee5\u5c06 FindPostion \u5728 Matrix \u5b9a\u4e49\u4e3a\u7eaf\u865a\u51fd\u6570\u3002 \u6a21\u677f\u65b9\u6cd5 \u62bd\u8c61\u7c7b\uff08\u57fa\u7c7b\uff09\u5b9a\u4e49\u7b97\u6cd5\u4e0d\u53d8\u7684\u9aa8\u67b6\u3002 \u7b97\u6cd5\u7684\u9700\u8981\u6539\u53d8\u7684\u7ec6\u8282\u7531\u5b9e\u73b0\u7c7b\uff08\u5b50\u7c7b\uff09\u4ee5\u91cd\u5199\uff08override\uff09\u7684\u5b9e\u73b0\u3002 \u5728\u4f7f\u7528\u65f6\uff0c\u8c03\u7528\u62bd\u8c61\u7c7b\u7684\u7b97\u6cd5\u9aa8\u67b6\u65b9\u6cd5\uff0c\u518d\u7531\u8fd9\u4e2a\u65b9\u6cd5\u6839\u636e\u9700\u8981\u8c03\u7528\u7d2f\u7684\u7b97\u6cd5\u7ec6\u8282\u5b9e\u73b0\u3002 \u9488\u5bf9\u63a5\u53e3\u800c\u4e0d\u662f\u9488\u5bf9\u5b9e\u73b0 \u901a\u8fc7\u62bd\u8c61\u51fa\u201c\u62bd\u8c61\u6982\u5ff5\u201d\uff0c\u8bbe\u8ba1\u51fa\u63cf\u8ff0\u8fd9\u4e2a\u62bd\u8c61\u6982\u5ff5\u7684\u201c\u62bd\u8c61\u7c7b\u201d\uff0c\u6216\u79f0\u4e3a\u201c\u63a5\u53e3\u7c7b\u201d\uff0c\u8fd9\u4e2a\u7c7b\u6709\u4e00\u7cfb\u5217\uff08\u7eaf\uff09\u865a\u51fd\u6570\uff0c\u63cf\u8ff0\u4e86\u8fd9\u4e2a\u7c7b\u7684\u201c\u63a5\u53e3\u201d \u5bf9\u8fd9\u4e2a\u63a5\u53e3\u7c7b\u8fdb\u884c\u7ee7\u627f\u5e76\u5b9e\u73b0\u8fd9\u4e9b\uff08\u7eaf\uff09\u865a\u51fd\u6570\uff0c\u4ece\u800c\u5f62\u6210\u8fd9\u4e2a\u62bd\u8c61\u6982\u5ff5\u7684\u201c\u5b9e\u73b0\u7c7b\u201d \u2014\u2014 \u5b9e\u73b0\u53ef\u4ee5\u6709\u5f88\u591a\u79cd\u4ee5\u9002\u5e94\u53d8\u5316 \u5728\u4f7f\u7528\u8fd9\u4e2a\u6982\u5ff5\u7684\u65f6\u5019\uff0c\u6211\u4eec\u4f7f\u7528\u63a5\u53e3\u7c7b\u6765\u5f15\u7528\u8fd9\u4e2a\u6982\u5ff5\uff0c\u800c\u4e0d\u76f4\u63a5\u4f7f\u7528\u5b9e\u73b0\u7c7b\uff0c\u4ece\u800c\u907f\u514d\u5b9e\u73b0\u7c7b\u7684\u6539\u53d8\u9020\u6210\u6574\u4e2a\u7a0b\u5e8f\u7684\u5927\u89c4\u6a21\u4fee\u6539","title":"\u5bf9\u8c61\u4e0e\u63a5\u53e3"},{"location":"design_pattern/object_and_interface/#_1","text":"","title":"\u5bf9\u8c61\u4e0e\u63a5\u53e3"},{"location":"design_pattern/object_and_interface/#fopoop","text":"FOP - Functional oriented programming OOP - Object oriented programming \u76ee\u6807\uff1a\u5f15\u51fa\u5bf9\u8c61 \u601d\u8003\uff1a\u5982\u4f55\u786e\u5b9a\u5bf9\u8c61\u8fb9\u754c\u3001\u5c01\u88c5\u4ec0\u4e48\u3001\u66b4\u9732\u4ec0\u4e48\u3001\u9690\u85cf\u4ec0\u4e48","title":"\u4eceFOP\u5230OOP"},{"location":"design_pattern/object_and_interface/#_2","text":"\u5b9e\u73b0\u4e00\u4e2a\u7535\u5b50\u8ba1\u4ef7\u5668\uff0c\u6839\u636e\u591a\u4e2a\u5546\u54c1\u7684\u5355\u4ef7\u548c\u91cd\u91cf\u8ba1\u7b97\u603b\u4ef7\u3002 FOP\u7248\u672c #include <iostream> using namespace std ; int main () { float apple_price = 5.5 ; float banana_price = 3.4 ; float apple_weight = 0.0 ; float banana_weight = 0.0 ; float total = 0.0 ; cout << \"Weight of apple: \" << endl ; cin >> apple_weight ; cout << \"Weight of banana: \" << endl ; cin >> banana_weight ; total = apple_price * apple_weight + banana_price * banana_weight ; cout << \"Payment: \" << total << endl ; }","title":"\u4ee5\u201d\u7535\u5b50\u8ba1\u4ef7\u5668\u4e3a\u4f8b\u201c"},{"location":"design_pattern/object_and_interface/#_3","text":"\u5bf9\u4e8e\u6bcf\u6b21\u90fd\u8981\u53d8\u5316\u7684\u201c\u91cd\u91cf\u201d\uff0c\u201c\u5355\u4ef7\u201d\u662f\u76f8\u5bf9\u4e0d\u53d8\u7684\u3002 \u4e3a\u533a\u5206\u4e24\u79cd\u4e0d\u540c\u5c42\u6b21\u7684\u201c\u53d8\u5316\u201d\uff0c\u201c\u5355\u4ef7\u201d\u5e94\u8be5\u88ab\u5c01\u5728\u8ba1\u4ef7\u5668\u91cc OOP\u7248\u672c #include <iostream> using namespace std ; class Calculator { public : Calculator ( float _apple_price , float _banana_price ) : apple_price ( _apple_price ), banana_price ( _banana_price ) {} float CalTotal ( float apple_weight , float banana_weight ); private : float apple_price , banana_price ; }; float Calculator :: CalTotal ( float apple_weight , float banana_weight ) { return apple_price * apple_weight + banana_price * banana_weight ; } int main () { Calculator c ( 5.5 , 3.4 ); float apple_weight = 0.0 ; float banana_weight = 0.0 ; cout << \"Weight of apple: \" << endl ; cin >> apple_weight ; cout << \"Weight of banana: \" << endl ; cin >> banana_weight ; cout << \"Payment: \" << c . CalTotal ( apple_weight , banana_weight ) << endl ; }","title":"\u53d8\u5316\u5206\u5c42"},{"location":"design_pattern/object_and_interface/#_4","text":"\u628a\u4e0d\u5e38\u53d8\u5316\u7684 apple_price \u548c banana_price \u5c01\u88c5\u8d77\u6765\uff0c\u5f62\u6210 Calculator \u6982\u5ff5\uff0c\u4f7f\u7528 Calculator \u65f6\u628a\u7ecf\u5e38\u53d8\u5316\u7684\u91cd\u91cf\u4f5c\u4e3a\u53c2\u6570\u3002 \u63a5\u53e3\uff1a\u7c7b\u66b4\u9732\u51fa\u6765\u7684\u90e8\u5206\uff0c\u662f\u7c7b\u6240\u63d0\u4f9b\u7684\u529f\u80fd\uff0c\u9690\u85cf\u5b9e\u73b0\u7ec6\u8282 UML\u7c7b\u56fe Calculator - apple_price: float - banana_price: float + CalTotal(in apple_weight: float, in banana_weight:float): float","title":"\u5c01\u88c5"},{"location":"design_pattern/object_and_interface/#_5","text":"","title":"\u5982\u4f55\u62bd\u8c61\u51fa\u5bf9\u8c61"},{"location":"design_pattern/object_and_interface/#_6","text":"A, B, C, D A, B, C, D \u56db\u4e2a\u4eba\uff0c\u5176\u4e2d\u4e00\u4e2a\u4eba\u662f PyTorch \u7684\u4f5c\u8005\uff0c\u5bf9\u6b64\u56db\u4e2a\u4eba\u5206\u522b\u4f5c\u4e86\u9648\u8ff0\uff1a A A : \u4e0d\u662f\u6211 B B : \u4f5c\u8005\u662f C C C C : \u4f5c\u8005\u662f D D D D : C C \u8bf4\u5f97\u4e0d\u5bf9\u3000 \u5df2\u77e5\u5176\u4e2d\u6709\u4e09\u53e5\u771f\u8bdd\u3001\u4e00\u53e5\u5047\u8bdd\uff0c\u95ee\u4f5c\u8005\u662f\u8c01\uff1f","title":"\u95ee\u9898"},{"location":"design_pattern/object_and_interface/#fop","text":"#include <iostream> using namespace std ; int main () { for ( char author = 'A' ; author <= 'D' ; author ++ ) { int count = 0 ; count += ( author != 'A' ); count += ( author == 'C' ); count += ( author == 'D' ); count += ( author != 'D' ); if ( count == 3 ) { cout << \"The author could be \" << author << endl ; break ; } } return 0 ; }","title":"FOP\u7248\u672c"},{"location":"design_pattern/object_and_interface/#oop","text":"\u95ee\u9898\u4e2d\u53ef\u53d8\u7684\u90e8\u5206 \u63cf\u8ff0\u65b9\u6cd5 \u5019\u9009\u4eba\u6570\u91cf\u3000\u3000 \u6574\u578b\u53c2\u6570 n n \u771f\u5b9e\u9648\u8ff0\u7684\u6570\u91cf \u6574\u578b\u53c2\u6570\u3000 correct correct \u6bcf\u4e2a\u5019\u9009\u4eba\u7684\u9648\u8ff0\u7684\u771f\u5b9e\u6027 \u4e00\u7ec4\u4e0e\u5019\u9009\u4eba\u5bf9\u5e94\u7684\u8fd4\u56de\u5e03\u5c14\u578b\u7684\u51fd\u6570 \u6ce8\u610f\u5230\uff0c\u5bf9\u4e8e\u8fd4\u56de\u6bcf\u4e2a\u5019\u9009\u4eba\u7684\u9648\u8ff0\u771f\u5b9e\u6027\u7684\u51fd\u6570\uff0c\u51fd\u6570\u7684\u5185\u90e8\u903b\u8f91\u4f9d\u8d56\u4e8e\u9648\u8ff0\u672c\u8eab\u3002\u53e6\u4e00\u65b9\u9762\uff0c\u9648\u8ff0\u540c\u610f\u53ef\u4ee5\u8868\u8ff0\u4e3a\u4f5c\u8005\u3000\u662f/\u4e0d\u662f\u3000\u201c\u67d0\u4e2a\u4eba\u201d\u7684\u5f62\u5f0f\u3002 \u53ef\u4ee5\u91cd\u8f7d () \u8fd0\u7b97\u7b26\u6765\u5b9e\u73b0\u3002 #include <iostream> using namespace std ; class Candidate { public : Candidate ( bool _equal , char _author ) : equal ( _equal ), author ( _author ) {} bool operator ()( char suspect ); private : char author ; bool equal ; }; bool Candidate :: operator ()( char suspect ) { return equal ? ( suspect == author ) : ( suspect != author ); } char solve ( int number , int correct , Candidate * candidates ) { for ( int i = 0 ; i < number ; i ++ ) { int count = 0 ; char suspect = 'A' + i ; for ( int j = 0 ; j < number ; j ++ ) count += candidates [ j ]( suspect ); cout << count << endl ; if ( count == correct ) return suspect ; } return '\\0' ; } int main () { Candidate candidates [] = { Candidate ( false , 'A' ), Candidate ( true , 'C' ), Candidate ( true , 'D' ), Candidate ( false , 'D' )}; char suspect = solve ( 4 , 3 , candidates ); if ( suspect != '\\0' ) { cout << \"The author is \" << suspect << endl ; } else { cout << \"Nooooooooooooooop!\" << endl ; } } \u57fa\u4e8eOOP\u7248\u672c\u7684\u5b9e\u73b0\uff0c\u95ee\u9898\u53ef\u4ee5\u5f88\u5bb9\u6613\u5730\u6269\u5c55\u5230 n n \u4e2a\u5019\u9009\u4eba\uff0c\u4e14\u6709 m m \u4e2a\u5019\u9009\u4eba\u7684\u9648\u8ff0\u771f\u5b9e\u7684\u60c5\u51b5\u3002","title":"OOP\u7248\u672c"},{"location":"design_pattern/object_and_interface/#_7","text":"","title":"\u5982\u4f55\u5b9a\u4e49\u63a5\u53e3"},{"location":"design_pattern/object_and_interface/#_8","text":"\u8bbe\u8ba1\u4e00\u4e2a\u7c7b\uff0c\u5bf9\u4e8e\u7ed9\u5b9a\u6574\u6570 N N \uff0c\u8f93\u51fa\u65cb\u8f6c\u77e9\u9635\uff0c\u5f62\u5f0f\u5982\u4e0b\uff1a 1, 16, 15, 14, 13\\\\ 2, 17, 24, 23, 12\\\\ 3, 18, 25, 22, 11\\\\ 4, 19, 20, 21, 10\\\\ 5, 6, 7, 8, 9 1, 16, 15, 14, 13\\\\ 2, 17, 24, 23, 12\\\\ 3, 18, 25, 22, 11\\\\ 4, 19, 20, 21, 10\\\\ 5, 6, 7, 8, 9","title":"\u95ee\u9898\uff1a\u65cb\u8f6c\u77e9\u9635"},{"location":"design_pattern/object_and_interface/#_9","text":"\u8fd9\u4e2a\u7c7b\u5982\u4f55\u88ab\u4f7f\u7528\uff1f Matrix obj ( size ); obj . fill (); cout << obj ; \u6839\u636e\u4f7f\u7528\u65b9\u6cd5\u8bbe\u8ba1 Matrix \u7684\u63a5\u53e3 class matrix { public : Matrix ( int size ); void fill (); friend ostream & operator << ( ostream & out , const Matrix & m ); }; \u5b9e\u73b0\u7c7b\u7684\u63a5\u53e3 \u786e\u5b9a\u9700\u8981\u54ea\u4e9b\u6210\u5458\u53d8\u91cf class Matrix { public : Matrix ( int size ); ~ Matrix (); void fill (); friend ostream & operator << ( ostream & out , const Matrix & m ); private : int size_ ; int * data_ ; }; \u5b9e\u73b0\u6784\u9020\u51fd\u6570\u3001\u6790\u6784\u51fd\u6570\u548c\u8f93\u51fa\u6d41\u64cd\u4f5c\u7b26 Matrix :: Matrix ( int size ) : size_ ( size ) { data_ = new int [ size * size ]; memset ( data_ , 0 , sizeof ( int ) * size_ * size_ ); } Matrix ::~ Matrix () { delete [] data_ ; } ostream & operator << ( ostream & out , const Matrix & m ) { for ( int r = 0 ; r < m . size_ ; r ++ ) { for ( int c = 0 ; c < m . size_ ; c ++ ) cout << * ( m . data_ + r * m . size_ + c ) << '\\t' ; cout << endl ; } } \u5b9e\u73b0\u586b\u5145\u51fd\u6570 \u589e\u52a0\u4e00\u4e2a\u8f85\u52a9\u51fd\u6570\u8ba1\u7b97\u5e76\u586b\u5145 class Matrix { public : ... private : ... int FindPosition (); }; void Matrix :: fill () { for ( int num = 1 ; num <= size_ * size_ ; num ++ ) { int pos = FindPosition (); data_ [ pos ] = num ; } } \u5269\u4e0b\u7684\u4efb\u52a1\u5c31\u662f\u5b9e\u73b0 FindPosition() \u3002 \u5bf9\u4e8e\u4e0d\u540c\u7684\u77e9\u9635\u5f62\u5f0f\uff0c\u4e5f\u53ea\u9700\u6539\u53d8 FindPosition \u5373\u53ef\u3002","title":"\u8bbe\u8ba1\u601d\u8def\uff1a\u81ea\u9876\u5411\u4e0b"},{"location":"design_pattern/object_and_interface/#_10","text":"\u7a0b\u5e8f\u8bbe\u8ba1\u7684 \u5f00\u95ed\u539f\u5219 \uff0c\u7a0b\u5e8f\u5bf9\u53d8\u5316\u7684\u9700\u6c42\u5e94\u8be5\u662fopen\u7684\uff0c\u4f46\u5e94\u8be5\u5c3d\u91cf\u4e0d\u6539\u52a8\u539f\u6709\u4ee3\u7801 \u8fd9\u65f6\u53ef\u4ee5\u5c06 FindPostion \u5728 Matrix \u5b9a\u4e49\u4e3a\u7eaf\u865a\u51fd\u6570\u3002","title":"\u591a\u6001\u7684\u5e94\u7528"},{"location":"design_pattern/object_and_interface/#_11","text":"\u62bd\u8c61\u7c7b\uff08\u57fa\u7c7b\uff09\u5b9a\u4e49\u7b97\u6cd5\u4e0d\u53d8\u7684\u9aa8\u67b6\u3002 \u7b97\u6cd5\u7684\u9700\u8981\u6539\u53d8\u7684\u7ec6\u8282\u7531\u5b9e\u73b0\u7c7b\uff08\u5b50\u7c7b\uff09\u4ee5\u91cd\u5199\uff08override\uff09\u7684\u5b9e\u73b0\u3002 \u5728\u4f7f\u7528\u65f6\uff0c\u8c03\u7528\u62bd\u8c61\u7c7b\u7684\u7b97\u6cd5\u9aa8\u67b6\u65b9\u6cd5\uff0c\u518d\u7531\u8fd9\u4e2a\u65b9\u6cd5\u6839\u636e\u9700\u8981\u8c03\u7528\u7d2f\u7684\u7b97\u6cd5\u7ec6\u8282\u5b9e\u73b0\u3002","title":"\u6a21\u677f\u65b9\u6cd5"},{"location":"design_pattern/object_and_interface/#_12","text":"\u901a\u8fc7\u62bd\u8c61\u51fa\u201c\u62bd\u8c61\u6982\u5ff5\u201d\uff0c\u8bbe\u8ba1\u51fa\u63cf\u8ff0\u8fd9\u4e2a\u62bd\u8c61\u6982\u5ff5\u7684\u201c\u62bd\u8c61\u7c7b\u201d\uff0c\u6216\u79f0\u4e3a\u201c\u63a5\u53e3\u7c7b\u201d\uff0c\u8fd9\u4e2a\u7c7b\u6709\u4e00\u7cfb\u5217\uff08\u7eaf\uff09\u865a\u51fd\u6570\uff0c\u63cf\u8ff0\u4e86\u8fd9\u4e2a\u7c7b\u7684\u201c\u63a5\u53e3\u201d \u5bf9\u8fd9\u4e2a\u63a5\u53e3\u7c7b\u8fdb\u884c\u7ee7\u627f\u5e76\u5b9e\u73b0\u8fd9\u4e9b\uff08\u7eaf\uff09\u865a\u51fd\u6570\uff0c\u4ece\u800c\u5f62\u6210\u8fd9\u4e2a\u62bd\u8c61\u6982\u5ff5\u7684\u201c\u5b9e\u73b0\u7c7b\u201d \u2014\u2014 \u5b9e\u73b0\u53ef\u4ee5\u6709\u5f88\u591a\u79cd\u4ee5\u9002\u5e94\u53d8\u5316 \u5728\u4f7f\u7528\u8fd9\u4e2a\u6982\u5ff5\u7684\u65f6\u5019\uff0c\u6211\u4eec\u4f7f\u7528\u63a5\u53e3\u7c7b\u6765\u5f15\u7528\u8fd9\u4e2a\u6982\u5ff5\uff0c\u800c\u4e0d\u76f4\u63a5\u4f7f\u7528\u5b9e\u73b0\u7c7b\uff0c\u4ece\u800c\u907f\u514d\u5b9e\u73b0\u7c7b\u7684\u6539\u53d8\u9020\u6210\u6574\u4e2a\u7a0b\u5e8f\u7684\u5927\u89c4\u6a21\u4fee\u6539","title":"\u9488\u5bf9\u63a5\u53e3\u800c\u4e0d\u662f\u9488\u5bf9\u5b9e\u73b0"},{"location":"design_pattern/split_representation/","text":"\u7b97\u6cd5\u7eb5\u5411\u62c6\u5206 - \u5206\u79bb\u8868\u793a \u5c1d\u8bd5\u5c06\u7b97\u6cd5\u548c\u6570\u636e\u5206\u79bb\u3002 \u903b\u8f91\u3001\u6570\u636e\u5982\u4f55\u8868\u793a\u3001\u7b97\u6cd5\u7ec6\u8282\u4e1a\u52a1\u6d41\u7a0b\u7684\u7ec6\u8282\u76f8\u5173\u7684\u90e8\u5206 \u5206\u79bb\u3001\u89e3\u8026\u8fd9\u4e09\u8005 \u6cdb\u578b\u7f16\u7a0b\uff1a\u5148\u5b9e\u73b0\u7b97\u6cd5\u3001\u4f7f\u7528\u65f6\u518d\u8003\u8651\u6570\u636e\u7c7b\u578b \u6570\u636e\u7c7b\u578b\uff0c\u5bf9\u8ba1\u7b97\u673a\u5e95\u5c42\u662f\u4e00\u79cd\u8868\u793a\uff0c\u5bf9\u7b97\u6cd5\u662f\u4e00\u79cd\u675f\u7f1a \u8fed\u4ee3\u5668 \u4ece\u95ee\u9898\u5f00\u59cb \u7f16\u7a0b\u7edf\u8ba1\u8003\u8bd5\u53ca\u683c\u7387 int main ( int argc , char * argv []) { float scores [ STUDENT_COUNT ]; int passed = 0 ; // initialize scores here. for ( int i = 0 ; i != STUDENT_COUNT ; i ++ ) { if ( scores [ i ] >= 60 ) passed ++ ; } cout << \"passing rate = \" << ( float ) passed / STUDENT_COUNT << endl ; return EXIT_SUCCESS ; } \u6ce8\uff1a\u8fd9\u91cc\u7528 != \u800c\u4e0d\u7528 < \u7684\u539f\u56e0\u662f != \u7684\u6267\u884c\u66f4\u9ad8\u6548\u3002 \u8d23\u4efb\u5206\u89e3 \u628a\u201c\u5206\u6790\u201d\u5355\u72ec\u4f5c\u4e3a\u4e00\u4e2a\u529f\u80fd void Analyze ( float * scores , int student_count ) { int passed = 0 ; for ( int i = 0 ; i != student_count ; i ++ ) { if ( scores [ i ] >= 60 ) passed ++ ; } cout << \"passing rate = \" << ( float ) passed / student_count << endl ; } \u5982\u679c\u6210\u7ee9\u4f7f\u7528\u5355\u5411\u94fe\u8868\u5b58\u50a8 struct Student { float score ; Student * next ; }; //... Student * head ; \u5219\u5148\u524d\u7684 Analyze \u5931\u6548\u3002 \u91cd\u65b0\u5b9e\u73b0 Analyze \uff1a void Analyze ( Student * scores ) { int passed = 0 , count = 0 ; for ( Student * p = scores ; p != nullptr ; p = p -> next ) { if ( p -> score >= 60 ) passed ++ ; count ++ ; } cout << \"passing rate = \" << ( float ) passed / count << endl ; } \u201c\u904d\u5386\u201d\u7684\u9700\u6c42 \u4e0d\u53d8\u7684\u9700\u6c42\uff1a\u904d\u5386\u6240\u6709\u5b66\u751f\u7684\u6210\u7ee9 \u53d8\u5316\u7684\u5b58\u50a8\u65b9\u5f0f\uff1a\u64cd\u4f5c\u4e0d\u5e0c\u671b\u88ab\u67d0\u79cd\u5b58\u50a8\u65b9\u5f0f\u7ed1\u5b9a \u5206\u79bb\u201c\u53d8\u201d\u4e0e\u201c\u4e0d\u53d8\u201d \u628a\u201c\u8bbf\u95ee\u201d\u8bbe\u8ba1\u6210\u4e00\u4e2a\u63a5\u53e3 \u9488\u5bf9\u4e0d\u540c\u7684\u201c\u5b58\u50a8\u201d\u5b8c\u6210\u8fd9\u4e2a\u63a5\u53e3\u7684\u4e0d\u540c\u5b9e\u73b0 \u8fed\u4ee3\u5668 \u628a\u201c\u8bbf\u95ee\u201d\u8bbe\u8ba1\u4e3a\u4e00\u4e2a\u63a5\u53e3 class Iterator { public : virtual ~ Iterator () {} virtual bool operator != ( const Iterator & other ) const = 0 ; virtual const Iterator & operator ++ () = 0 ; virtual const Iterator * operator ++ ( int ) = 0 ; virtual float & operator * () const = 0 ; virtual float & operator -> () const = 0 ; bool operator == ( const Iterator & other ) const { return ! ( * this != other ); } }; \u4f7f\u7528\u8fed\u4ee3\u5668 void Analyze ( Iterator * begin , Iterator * end ) { int passed = 0 , count = 0 ; for ( Iterator * p = begin ; * p != * end ; ( * p ) ++ ) { if ( ** p >= 60 ) passed ; count ++ ; } cout << \"passing rate = \" << ( float ) passed / count << endl ; } \u9700\u8981\u7ed9\u201c\u5b58\u50a8\u201d\u5bf9\u8c61\u4e00\u4e2a\u7ea6\u675f \u80fd\u591f\u8fd4\u56de\u4ee3\u8868\u201c\u5934\u201d\u548c\u201c\u5c3e\u201d\u7684\u8fed\u4ee3\u5668 \u4f7f\u7528\u201c\u5de6\u95ed\u53f3\u5f00\u533a\u95f4\u201d\uff0c\u5373 [begin, end) [begin, end) - \u4ee5\u4fbf\u4e8e\u7528 != \u5224\u65ad\u7ed3\u675f class Collection { public : virtual ~ Collection () {} virtual Iterator * begin () const = 0 ; virtual Iterator * end () const = 0 ; virtual int size () = 0 ; }; int main ( int argc , char * argv []) { Collection * collection ; // initialize collection here... Analyze ( collection -> begin (), collection -> end ()); } \u8fed\u4ee3\u5668\u7684\u5b9e\u73b0 \u5b9e\u73b0\u57fa\u4e8e\u6570\u7ec4\u7684\u96c6\u5408 class ArrayCollection : public Collection { public : ArrayCollection () : size_ ( 10 ) { data_ = new float [ size_ ]; } ArrayCollection ( int size , float * data ) : size_ ( size ) { data_ = new float [ size_ ]; for ( int i = 0 ; i < size_ ; i ++ ) * ( data_ + i ) = * ( data + i ); } ~ ArrayCollection () { delete [] data_ ; } int size () { return size_ ; } Iterator * begin () const ; Iterator * end () const ; private : friend class ArrayIterator ; float * data_ ; int size_ \uff1b }; \u5176\u4e2d\u83b7\u53d6\u9996\u3001\u5c3e Iterator \u7684\u6210\u5458\u51fd\u6570\uff1a Iterator * ArrayCollection :: begin () const { return new ArrayIterator ( data_ , 0 ); } Iterator * ArrayCollection :: end () const { return new ArrayIterator ( data_ , size_ ); } \u5b9e\u73b0\u57fa\u4e8e\u6570\u7ec4\u7684\u8fed\u4ee3\u5668 class ArrayIterator : public Iterator { public : ArrayIterator ( float * data , int index ) : data_ ( data ), index_ ( index ) {} ArrayIterator ( const ArrayIterator & other ) : data_ ( other . data_ ), index_ ( other . index_ ) {} ~ ArrayIterator () {} const Iterator & operator ++ (); const Iterator & operator ++ ( int ); float & operator * () const ; float * operator -> () const ; bool operator != ( const Iterator & other ) const ; private : float * data_ ; int index_ ; }; const Iterator & ArrayIterator :: operator ++ () { index_ ++ ; return * this ; } const Iterator & ArrayIterator :: operator ++ ( int ) { index_ ++ ; return ArrayIterator ( data_ , index_ - 1 ); } float & ArrayIterator :: operator * () const { return * ( data_ + index_ ); } float * ArrayIterator :: operator -> () const { return ( data_ + index_ ); } bool ArrayIterator :: operator != ( const Iterator & other ) const { return data_ != (( ArrayIterator * )( & other )) -> data_ || index_ != (( ArrayIterator * )( & other )) -> index_ ; } \u91cd\u5199 Analyze \u548c main void Analyze ( Iterator * begin , Iterator * end ) { int passed = 0 , count = 0 ; for ( Iterator * p = begin ; * p != * end ; ( * p ) ++ ) { if ( ** p >= 60 ) passed ++ ; count ++ ; } cout << \"passing rate = \" << ( float ) passed / count << endl ; } int main () { float scores [] = { 90 , 20 , 40 , 40 , 30 , 60 , 70 , 30 , 90 , 100 }; Collection * collection = new ArrayCollection ( 10 , scores ); Analyze ( collection -> begin (), collection -> end ()); system ( \"PAUSE\" ); return EXIT_SUCCESS ; } \u8fed\u4ee3\u5668\u6a21\u5f0f \u8bbe\u8ba1\u6a21\u5f0f \u63d0\u4f9b\u4e00\u79cd\u65b9\u6cd5\u987a\u5e8f\u8bbf\u95ee\u4e00\u4e2a\u805a\u5408\u5bf9\u8c61\u4e2d\u7684\u5404\u4e2a\u5143\u7d20 \u4e0d\u66b4\u9732\u8be5\u5bf9\u8c61\u7684\u5185\u90e8\u8868\u793a\u2014\u2014\u4e0e\u5bf9\u8c61\u7684\u5185\u90e8\u8868\u793a\u65e0\u5173\uff08\u6570\u7ec4\u8fd8\u662f\u94fe\u8868\uff09 //... for ( Iterator p = begin ; p != end ; p ++ ) { // do something with object *p; } //... \u53e6\u4e00\u79cd\u5e38\u89c1\u7684\u8fed\u4ee3\u5668\u6a21\u5f0f \u5982Java\u7b49\u8bed\u8a00\u4e0d\u63d0\u4f9b ++ \u7b49\u8fd0\u7b97\u7b26\u91cd\u8f7d\uff0c\u4e0a\u8ff0\u8fed\u4ee3\u5668\u6a21\u5f0f\u63d0\u4f9b\u4e86\u5355\u5411\u8fed\u4ee3\uff1a //... Iterator it = Collection . iterator (); while ( it . HasNext ()) { Object object = it . next (); // do something with object; } //... \u8fed\u4ee3\u5668\u4e0e\u6a21\u677f \u56fa\u5b9a\u7684\u4e1c\u897f\uff1a \u4ea7\u751f\u8fed\u4ee3\u5668\u7684\u65b9\u6cd5 \u8fed\u4ee3\u5668\u904d\u5386\u96c6\u5408\u7684\u63a5\u53e3 \u53d8\u5316\u7684\u4e1c\u897f\uff1a \u96c6\u5408\u7684\u5b58\u50a8\u65b9\u5f0f \u8fed\u4ee3\u5668\u904d\u5386\u96c6\u5408\u7684\u5177\u4f53\u5b9e\u73b0 \u8fed\u4ee3\u5668\u5b9e\u73b0\u4e86 \u904d\u5386\u64cd\u4f5c \u4e0e \u5b58\u50a8\u65b9\u6cd5 \u7684\u9694\u79bb\u3002\u4f7f\u5f97\u5b9e\u73b0\u7b97\u6cd5\u903b\u8f91\u65f6\u65e0\u9700\u5173\u5fc3\u6570\u636e\u8868\u793a\uff0c\u800c\u5b9e\u73b0\u6570\u636e\u5b58\u50a8\u7684\u65f6\u5019\u53c8\u65e0\u9700\u5173\u5fc3\u7b97\u6cd5\u7684\u903b\u8f91\u3002 \u7b97\u6cd5\u7684\u901a\u7528\u5316 \u53ef\u4ee5\u8bbe\u8ba1\u4e00\u4e9b\u5217\u901a\u7528\u7b97\u6cd5\uff1a max , min , sort , count , count_if , find , ... int main () { float scores [] = { 90 , 20 , 40 , 40 , 30 , 60 , 70 , 30 , 90 , 100 }; Collection * c = new ArrayCollection ( 10 , scores ); cout << \"passing rate = \" << ( float ) count_if ( c -> begin (), c -> end (), passed ()) / c . size () << endl ; system ( \"PAUSE\" ); return EXIT_SUCCESS ; } \u6539\u8fdb\u76ee\u6807 \u95ee\u9898 1 \u5f53\u524d\u7684\u4f7f\u7528\u65b9\u5f0f void Analyze ( Iterator * begin , Iterator * end ) { for ( Iterator * p = begin ; * p != * end ; ( * p ) ++ ) { if ( ** p >= 60 ) //... } } \u671f\u5f85\u7684\u4f7f\u7528\u65b9\u5f0f void Analyze ( const Iterator & begin , const Iterator & end ) { for ( Iterator p = begin ; p != end ; p ++ ) { if ( * p >= 60 ) //... } } \u95ee\u9898 2 \u53ea\u652f\u6301 float \u7c7b\u578b\uff0c\u89c1\u5982\u4e0b * \u548c -> \u7684\u91cd\u8f7d class Iterator { public : virtual ~ Iterator () {} virtual bool operator != ( const Iterator & other ) const = 0 ; virtual const Iterator & operator ++ () = 0 ; virtual const Iterator * operator ++ ( int ) = 0 ; virtual float & operator * () const = 0 ; virtual float & operator -> () const = 0 ; bool operator == ( const Iterator & other ) const { return ! ( * this != other ); } }; \u5f15\u5165\u6a21\u677f \u6211\u4eec\u9700\u8981\u4e00\u79cd\u65b9\u6cd5\uff0c\u5728\u7f16\u5199\u4ee3\u7801\u65f6\u5c06\u7c7b\u578b\u4f5c\u4e3a\u53ef\u53d8\u90e8\u5206\uff0c\u8fd9\u4e9b\u90e8\u5206\u5728\u4f7f\u7528\u524d\u5fc5\u987b\u505a\u51fa\u6307\u660e\u3002\u5982\u6b64\u4e00\u6765\uff0c\u53ef\u4ee5\u5148\u8003\u8651\u901a\u7528\u7684\u7b97\u6cd5\u548c\u62bd\u8c61\u7684\u6570\u636e\u7ed3\u6784\uff0c\u7136\u540e\u518d\u5728\u4f7f\u7528\u65f6\u4e88\u4ee5\u5b9e\u4f8b\u5316 \u4f7f\u7528 \u6a21\u677f \u6280\u672f\u5b9e\u73b0 \u6cdb\u578b \u3002 \u901a\u7528\u7b97\u6cd5 template < class iterator_ > void Analysis ( iterator_ begin , iterator_ end ) { int passed = 0 , count = 0 ; for ( iterator_ p = begin ; p != end ; p ++ ) { if ( * p >= 60 ) passed ++ ; count ++ ; } cout << \"passing rate = \" << ( float ) passed / count << endl ; } \u8fd9\u91cc iterator_ \u7c7b\u578b\u7684\u53d8\u91cf\u9700\u8981\u5b9e\u73b0 = , != , ++ \u8fd0\u7b97\u7b26\u3002 template < class T > class ArrayCollection { public : ArrayCollection () : size_ ( 10 ) { data_ = new T [ size_ ]; } ArrayCollection ( int size ) : size ( size_ ) { data_ = new T [ size_ ]; } ArrayCollection ( int size , T * data ) : size_ ( size ) { data_ = new T [ size_ ]; for ( int i = 0 ; i < size_ ; i ++ ) * ( data_ + i ) = * ( data + i ); } ~ ArrayCollection () { delete [] data_ ; } T * begin (){ return data_ ; } T * end () { return data_ + size_ ; } private : T * data_ ; int size_ ; }; \u94fe\u8868\u8282\u70b9\u3001\u94fe\u8868\u8fed\u4ee3\u5668\u3001\u94fe\u8868\u5bb9\u5668 template < class T > struct LinkiedListNode { T data_ ; LinkedListNode * next ; LinkedListNode () : next ( nullptr ) {} LinkedListNode ( T data ) : data_ ( data ), next ( nullptr ) {} }; template < class T > struct LinkedListIterator { LinkedListNode < T >* pointer ; LinkedListIterator ( LinkiedListNode < T >* p ) : pointer ( p ) {} LinkedListIterator ( const LinkedListIterator < T >& it ) : pointer ( it . pointer ) {} LinkedListIterator < T >& operator ++ () { pointer = pointer -> next ; return * this ; } const LinkedListIterator < T > operator ++ ( int ) { LinkedListIterator < T > temp = * this ; pointer = pointer -> next ; return temp ; } T & operator * () const { return pointer -> data_ ; } T * operator -> () const { return & ( pointer -> data_ ); } bool operator != ( const LinkedListIterator < T >& other ) { return pointer != other . pointer ; } bool operator == ( const LinkedListIterator < T >& other ) { return pointer == other . pointer ; } }; template < class T > class LinkedListCollection { public : LinkedListCollection () : head_ ( nullptr ) {} LinkedListCollection ( int size , T * datq ) { //... } ~ LinkedListCollection () { //... } LinkedListIterator < T > begin () { return LinkedListIterator < T > ( head_ ); } LinkedListIterator < T > end () { return LinkedListIterator < T > ( nullptr ); } private : LinkedListNode < T >* head ; }; \u4f7f\u7528\u5982\u4e0b\uff1a int main () { float scores [] = { 90 , 20 , 40 , 40 , 30 , 60 , 70 , 30 , 90 , 100 }; ArrayCollection < float > collection2 ( 10 , scores ); LinkedListCollection < float > collection1 ( 10 , scores ); Analyze ( scores , scores + 10 ); Analyze ( collection1 . begin (), collection1 . end ()); Analyze ( collection2 . begin (), collection2 . end ()); system ( \"PAUSE\" ); return EXIT_SUCCESS ; } \u8fd9\u91cc\u6307\u9488\u7531\u4e8e\u652f\u6301 = , != , ++ \u64cd\u4f5c\uff0c\u5728\u8fd9\u91cc\u4e5f\u53ef\u4ee5\u4f5c\u4e3a\u8fed\u4ee3\u5668\u4f7f\u7528\u3002 \u4e8b\u5b9e\u4e0a\uff0c\u6307\u9488\u662f\u4e00\u79cd\u8fed\u4ee3\u5668\uff0c\u8fed\u4ee3\u5668\u4e5f\u662f\u4e00\u79cd\u6307\u9488\u3002 \u7b97\u6cd5\u4e0e\u6570\u636e\u89e3\u8026 \u5bb9\u5668\uff1a\u5b58\u50a8\u6570\u636e\uff0c\u6570\u636e\u7684\u8868\u793a \u7b97\u6cd5\uff1a\u5904\u7406\u6570\u636e\uff0c\u62bd\u8c61\u7684\u7b97\u6cd5\u5b9e\u73b0 \u8fed\u4ee3\u5668\uff1a\u6807\u51c6\u7684\u6570\u636e\u904d\u5386\u63a5\u53e3\uff0c\u9694\u79bb\u7b97\u6cd5\u4e0e\u5bb9\u5668\uff0c\u662f\u7b97\u6cd5\u4e0e\u6570\u636e\u7684\u8868\u793a\u65e0\u5173 \u5b9e\u73b0\u901a\u7528\u7684\u7b97\u6cd5\uff0c\u5c06\u7b97\u6cd5\u4e0e\u6570\u636e\u8868\u793a\u89e3\u8026\u3002 \u8003\u8bd5\u79d1\u76ee\u6570\u53d8\u62103 \u5982\u679c\u4e0a\u8ff0\u95ee\u9898\u8003\u8bd5\u79d1\u76ee\u53d8\u62103\u79d1\uff0c\u5219 float \u578b\u53d8\u91cf\u4e0d\u80fd\u8868\u793a\u5206\u6570\uff0c\u5b9a\u4e49 Score \u7c7b\u578b struct Score { float value [ 3 ]; Score () {} Score ( float f1 , float f2 , float f3 ) { value [ 0 ] = f1 ; value [ 1 ] = f2 ; value [ 2 ] = f3 ; } Score & operator = ( const Score & s ) { value [ 0 ] = s . value [ 0 ]; value [ 1 ] = s . value [ 1 ]; value [ 2 ] = s . value [ 2 ]; return * this ; } bool operator >= ( float pass ) { return value [ 0 ] >= pass && value [ 1 ] >= pass & value [ 2 ] >= pass ; } }; ostream & operator << ( ostream & out , const Score & s ) { cout << \"{\" << s . value [ 0 ] << \", \" << s . value [ 1 ] << \", \" << s . value [ 2 ] << \"}\" ; return out ; } \u76f8\u5e94\u5730\u4e3b\u51fd\u6570\u53d8\u4e3a int main ( int argc , char * argv []) { Score sarray [ 3 ]; sarray [ 0 ] = Score ( 60 , 60 , 60 ); sarray [ 1 ] = Score ( 70 , 70 , 70 ); sarray [ 2 ] = Score ( 50 , 80 , 80 ); ArrayCollection < Score > collection3 ( 3 , sarray ); LinkedListCollection < Score > collection4 ( 3 , sarray ); Analyze ( sarray , sarray + 3 ); Analyze ( collection3 . begin (), collection3 . end ()); Analyze ( collection4 . begin (), collection4 . end ()); system ( \"PAUSE\" ); return EXIT_SUCCESS ; } \u5982\u4f55\u5b9e\u73b0\u89e3\u8026 \u5bf9\u4e8e\u4e00\u4e2a\u6570\u636e\u7c7b\u578b\uff0c \u503c \u64cd\u4f5c \u62bd\u8c61\u63a5\u53e3 \u503c\u57df \u53ef\u7528\u7684\u64cd\u4f5c \u5177\u4f53\u5b9e\u73b0 \u5982\u4f55\u5b58\u50a8 \u5982\u4f55\u5b9e\u73b0\u64cd\u4f5c \u5bf9\u4e8e \u53ef\u7528\u7684\u64cd\u4f5c \u90e8\u5206\uff0c\u5bf9\u5982 = , != , ++ , * \u7684\u652f\u6301\u662f\u7b97\u6cd5\u6240\u5173\u5fc3\u7684\u3002\u7b97\u6cd5\u5b9e\u9645\u4e0a\u53ea\u4e0e \u53ef\u7528\u7684\u64cd\u4f5c \u76f8\u5173\uff0c\u4e0e\u5177\u4f53\u6570\u636e\u7c7b\u578b\u65e0\u5173\u3002 \u7b97\u6cd5\u3001\u8fd0\u7b97\u7b26\u3001\u8fd0\u7b97\u7b26\u91cd\u8f7d \u7b97\u6cd5\u4ec5\u4e0e\u201c\u53ef\u7528\u7684\u64cd\u4f5c\u201d\u76f8\u5173\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u629b\u5f00\u7c7b\u578b\u8003\u8651\u7b97\u6cd5\uff0c\u5b9e\u73b0\u62bd\u8c61\u8fd0\u7b97\uff0c\u5728\u7b97\u6cd5\u548c\u6570\u636e\u7c7b\u578b\uff08\u5b58\u50a8\uff09\u4e4b\u95f4\u5b9e\u73b0\u89e3\u8026\u3002 \u5728C++\u4e2d\uff0c\u201c\u53ef\u7528\u7684\u64cd\u4f5c\u201d\u65f6\u4f7f\u7528\u8fd0\u7b97\u7b26\u6765\u63cf\u8ff0\u7684\uff08\u5982 * , ++ , != , >= \uff09\uff0c\u4ed6\u4f5c\u7528\u5728\u6307\u5b9a\u6570\u91cf\u7684\u64cd\u4f5c\u6570\u4e0a\uff0c\u8fd4\u56de\u4e00\u4e2a\u7ed3\u679c\u3002 \u5982\u679c\u6211\u4eec\u9700\u8981\u67d0\u4e2a\u6570\u636e\u7c7b\u578b\u53ef\u4ee5\u4f7f\u7528\u5728\u67d0\u4e2a\u7b97\u6cd5\u4e2d\uff0c\u53ea\u8981\u5b9e\u73b0\u76f8\u5173\u7684\u64cd\u4f5c\u5c31\u53ef\u4ee5\u4e86\u3002 \u8fd9\u4f9d\u8d56\u4e8e\u8fd0\u7b97\u7b26\u91cd\u8f7d\uff0c\u4e5f\u53ef\u4ee5\u8ba4\u4e3a\u662f\u8fd0\u7b97\u7b26\u91cd\u8f7d\u7684\u672c\u6765\u76ee\u7684\uff1a \u8fd0\u7b97\u7b26\u91cd\u8f7d\u5c31\u662f\u5728\u65b0\u7684\u6570\u636e\u7c7b\u578b\u4e0a\u8fd8\u539f\u8fd0\u7b97\u7b26\u7684\u672c\u8d28 \u3002 \u6570\u636e\u7c7b\u578b\u4e0e\u64cd\u4f5c \u53ef\u7528\u7684\u64cd\u4f5c\u662f\u6570\u636e\u7c7b\u578b\u7684\u62bd\u8c61\u63a5\u53e3\u3002 \u6570\u636e\u7c7b\u578b\u4e5f\u53ef\u4ee5\u7528 \u53ef\u7528\u64cd\u4f5c\u7684\u96c6\u5408 \u6765\u754c\u5b9a\uff0c\u5177\u6709\u76f8\u540c\u201c\u53ef\u7528\u64cd\u4f5c\u96c6\u5408\u201d\u5c31\u662f\u76f8\u540c\u7684\u6570\u636e\u7c7b\u578b\u3002 \u5982\u679c\u628a\u201c\u64cd\u4f5c\u201d\u66f4\u52a0\u6cdb\u534e\uff0c\u5c06\u5176\u5b9a\u4e49\u5230\u4e00\u4e2a\u62bd\u8c61\u5b9e\u4f53\u4e0a\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5\u628a\u201c\u6570\u636e\u7c7b\u578b\u201d\u8fdb\u4e00\u6b65\u62bd\u8c61\u5316\u3002 \u62bd\u8c61\u7ed3\u6784\u4e0e\u7c7b\u6a21\u677f \u9664\u4e86\u201c\u62bd\u8c61\u7b97\u6cd5\u201d\u4e4b\u5916\uff0c\u8fd8\u6709\u201c\u62bd\u8c61\u7ed3\u6784\u201d Stack , LinkedList , Vector \u8fd9\u4e9b\u62bd\u8c61\u7ed3\u6784\uff0c\u4e0e\u5b58\u50a8\u4ec0\u4e48\u6570\u636e\u65e0\u5173\uff0c\u81f3\u4e8e\u6570\u636e\u7684\u5b58\u50a8\u65b9\u5f0f\u548c\u8bbf\u95ee\u65b9\u5f0f\u76f8\u5173\uff0c\u53ef\u4ee5\u501f\u52a9\u7c7b\u6a21\u677f\u5b9e\u73b0\u3002 \u5b9e\u73b0\u4e00\u4e2a\u94fe\u8868\u6a21\u677f \u4f8b\u5982\u4e0b\u65b9\u94fe\u8868 template < class T > struct LinkedListNode { T data_ ; LinkedListNode * next_ ; LinkedListNode () : next_ ( nullptr ) {} LinkedListNode ( T data ) : data_ ( data ), next_ ( nullptr ) {} LinkedListNode ( T data , LinkedListNode * next ) : data_ ( data ), next_ ( next ) {} }; template < class T > class LinkedListCollection { public : LinkedListCollection () : head_ ( nullptr ) {} ~ LinkedListCollection () { clear (); } bool empty () { return head_ == nullptr ; } void AddFirst ( const T & data ) { head_ = new LinkedListNode < T > )( data , head_ ); } bool RemoveFirst () { if ( head_ != nullptr ) { LinkedListNode < T >* p = head_ ; head_ = head_ -> next_ ; delete p ; return true ; } else { return false ; } } T * GetFirst () { return head_ != nullptr ? & ( head_ -> data_ ) : nullptr ; } bool RemoveLast () { if ( head_ != nullptr ) { if ( head_ -> next_ != nullptr ) { LinkedListNode < T >* p ; for ( p = head_ ; p -> next_ -> next_ != nullptr ; p = p -> next_ ) ; delete p -> next_ ; p -> next_ = nullptr ; return true ; } else { delete head_ ; head_ = nullptr ; return true ; } } else { return false ; } } clear () { while ( RemoveFirst ()) ; } LinkedListIterator < T > begin () { return LinkedListIterator < T > ( head_ ); } LinkedListIterator < T > end () { return LinkedListIterator < T > ( nullptr ); } private : LinkedListNode < T >* head_ ; }; \u5173\u4e8e \u5185\u8054\u51fd\u6570 \uff1a C++\u4e2d inline \u5173\u952e\u5b57\u4fee\u9970\u51fd\u6570\u5b9a\u4e49\uff08\u544a\u8bc9\u7f16\u8bd1\u5668\u8fd9\u4e2a\u51fd\u6570\u53ef\u80fd\u88ab\u9891\u7e41\u4f7f\u7528\uff0c\u5bf9\u6027\u80fd\u8981\u6c42\u654f\u611f\uff0c\u8c03\u7528\u65f6\u4f7f\u7528\u5185\u8054\u5c55\u5f00\uff0c\u907f\u514d\u5165\u6808\u51fa\u6808\u7684\u64cd\u4f5c\uff09 inline int max(int a, int b) { return a > b ? a : b; } \u4f5c\u7528\uff1a\u51fd\u6570\u5185\u8054\u5c55\u5f00\uff0c\u907f\u514d\u51fd\u6570\u8c03\u7528\u5f00\u9500\uff0c\u7528\u7a7a\u95f4\u6362\u65f6\u95f4\u3002 \u5728\u7c7b\u5b9a\u4e49\u4f53\u5185\u5b9a\u4e49\uff08\u5b9e\u73b0\uff09\u7684\u51fd\u6570\u7f3a\u7701\u4e3a\u5185\u8054\u51fd\u6570\u3002 \u5230\u6b64\u4e3a\u6b62 \u6211\u4eec\u4e3a\u4efb\u610f\u7c7b\u578b\u5143\u7d20\u5b9e\u73b0\u94fe\u8868\u7684\u65b9\u5f0f\u3002 \u7528\u94fe\u8868\u6a21\u677f\u7ec4\u7ec7\u5206\u6570 \u901a\u8fc7\u6a21\u677f\u5b9e\u4f8b\u5316\u4f7f\u7528Linked List\uff08\u62bd\u8c61\u7ed3\u6784\uff09 int main ( int argc , char * argv []) { //... LinkedListCollection < Score > collection4 ; for ( int i = 0 ; i < 3 ; i ++ ) collection4 . AddFirst ( sarray [ i ]); Analyze ( collection4 . begin (), collection4 . end ()); //... return EXIT_SUCCESS ; } \u5c0f\u7ed3 \u56fa\u5b9a\u7684\u4e1c\u897f\uff1a \u7b97\u6cd5/\u62bd\u8c61\u7ed3\u6784\u7684\u63a5\u53e3\u4e0e\u5b9e\u73b0 \u201c\u6570\u636e\u201d\u7684\u8bbf\u95ee\u63a5\u53e3\uff08\u8fed\u4ee3\u5668\uff09 \u201c\u6570\u636e\u201d\u7684\u53ef\u7528\u64cd\u4f5c\uff08\u8fd0\u7b97\u7b26\u91cd\u8f7d\uff09 \u53d8\u5316\u7684\u4e1c\u897f\uff1a \u201c\u6570\u636e\u201d\u7684\u7ec4\u7ec7\u5f62\u5f0f \u201c\u6570\u636e\u201d\u7684\u7c7b\u578b\uff08\u503c\u57df\u3001\u5b58\u50a8\u3001\u64cd\u4f5c\u5b9e\u73b0\uff09 \u7531\u6b64\u5b9e\u73b0\u201c\u7b97\u6cd5/\u62bd\u8c61\u7ed3\u6784\u201d\u4e0e\u201c\u6570\u636e\u8868\u793a\u201d\u4e4b\u95f4\u7684\u5206\u79bb \u6cdb\u578b\u7f16\u7a0b \uff1a\u5148\u5b9e\u73b0\u7b97\u6cd5\uff0c\u518d\u5145\u5b9e\u6570\u636e\u8868\u793a\uff08\u7c7b\u578b\uff09 \u51fd\u6570\u5bf9\u8c61\u4e0e\u7b97\u6cd5\u5206\u89e3 \u5f53\u201c\u53ca\u683c\u201d\u5224\u5b9a\u89c4\u5219\u53d1\u751f\u53d8\u5316 \u5982\u679c\u67d0\u4e9b\u79d1\u76ee\u7684\u53ca\u683c\u7ebf\u4e0d\u662f60\u5206 \u73b0\u6709\u7684 Analyze \u51fd\u6570 template < class iterator_ > void Analyze ( iterator_ begin , iterator_ end ) { int passsed = 0 , count = 0 ; for ( iterator_ p = begin ; p != end ; p ++ ) { if ( * p >= 60 ) passed ++ ; count ++ ; } cout << \"passing rate = \" << ( float ) passed / count << endl ; } \u5c06\u5224\u65ad\u53ca\u683c\u51fd\u6570 IsPass \u7684\u51fd\u6570\u6307\u9488\u4f5c\u4e3a\u53c2\u6570\u4f20\u7ed9 Analyze template < class iterator_ > void Analyze ( iterator_ begin , iterator_ end , bool ( * IsPass )( const iterator_ & )) { int passsed = 0 , count = 0 ; for ( iterator_ p = begin ; p != end ; p ++ ) { if ( IsPass ( p )) passed ++ ; count ++ ; } cout << \"passing rate = \" << ( float ) passed / count << endl ; } \u4f7f\u7528\u201c\u5224\u65ad\u53ca\u683c\u201d\u51fd\u6570\u6307\u9488 template < class iterator_ > bool IsPass ( const iterator_ & p ) { return p -> value [ 0 ] >= 70 && p -> value [ 1 ] >= 60 && p -> value [ 2 ] >= 60 ; } \u6ce8\uff1a\u8fd9\u91cc\u7684` IsPass `\u6709\u7f3a\u9677\uff1a\u53ea\u9002\u7528\u4e8e` Score `\u7c7b\u578b int main ( int argc , char * argv []) { //... Analyze ( sarray , sarray + 3 , IsPass < Score *> ); Analyze ( collection3 . begin (), collection3 . end (), IsPass < Score *> ); Analyze ( collection4 . begin (), collection4 . end (), IsPass < LinkedListIterator < Score >> ); //... } \u8fdb\u4e00\u6b65\u89e3\u8026 \u8fd9\u4e24\u4e2a\u51fd\u6570\u552f\u4e00\u7684\u4e0d\u540c\u5c31\u662f\u201c\u79d1\u4e00\u201d\u7684\u53ca\u683c\u5206\u6570 template < class iterator_ > bool IsPass ( const iterator_ & p ) { return p -> value [ 0 ] >= 70 && p -> value [ 1 ] >= 60 && p -> value [ 2 ] >= 60 ; } template < class iterator_ > bool IsPass ( const iterator_ & p ) { return p -> value [ 0 ] >= 60 && p -> value [ 1 ] >= 60 && p -> value [ 2 ] >= 60 ; } \u5982\u4f55\u62bd\u79bb\u51fa\u76f8\u540c\u7684\u5904\u7406\u903b\u8f91\uff0c\u5c06\u201c\u53ca\u683c\u7ebf\u201d\u8bb0\u5f55\u4e0b\u6765 \u4f7f\u7528 Score \u53d8\u91cf const Score pass ( 70 , 60 , 60 ); template < class iterator_ > bool IsPass ( const iterator_ & p ) { return p -> value [ 0 ] >= pass . value [ 0 ] && p -> value [ 1 ] >= pass . value [ 1 ] && p -> value [ 2 ] >= pass . value [ 2 ]; } \u4f7f\u7528\u6587\u4ef6 template < class iterator_ > bool IsPass ( const iterator_ & p ) { float pass1 , pass2 , pass3 ; ifstream is ( \"pass-score.txt\" ); is >> pass1 >> pass2 >> pass3 ; return p -> value [ 0 ] >= pass1 && p -> value [ 1 ] >= pass2 && p -> value [ 2 ] >= pass3 ; } \u53ef\u4ee5\u901a\u8fc7\u4fee\u6539 pass-score.txt \u7684\u5185\u5bb9\u6539\u53d8\u53ca\u683c\u5206\u6570\u7ebf\u7ec4\u5408\u3002 \u8fd9\u91cc \u5355\u4e00\u5b9e\u4f8b \u7684\u95ee\u9898\u4f9d\u7136\u5b58\u5728\uff0c\u95ee\u9898\u5728\u4e8e\u51fd\u6570\u662f\u56fa\u5b9a\u7684\u3002 \u51fd\u6570\u5bf9\u8c61 \u5b9a\u4e49 IsPass \u51fd\u6570\u5bf9\u8c61\u7c7b\u6a21\u677f template < class iterator_ , class T > class IsPass { public : IsPass ( const T & pass ) : pass_ ( pass ) {} bool operator ()( const iterator_ & p ) { return * p >= pass_ ; } private : T pass_ ; }; \u76f8\u5e94\u6539\u53d8\u7b97\u6cd5\u5b9a\u4e49 template < class iterator_ , class T > void Analyze ( iterator_ begin , iterator_ end , IsPass < iterator_ , T > is_pass ) { int passsed = 0 , count = 0 ; for ( iterator_ p = begin ; p != end ; p ++ ) { if ( is_pass ( p )) passed ++ ; count ++ ; } cout << \"passing rate = \" << ( float ) passed / count << endl ; } \u4f7f\u7528\u51fd\u6570\u5bf9\u8c61 int main ( int argc , char * argv []) { //... sarray [ 0 ] = Score ( 60 , 60 , 60 ); sarray [ 1 ] = Score ( 70 , 70 , 70 ); sarray [ 2 ] = Score ( 50 , 80 , 80 ); ArrayCollection < Score > collection3 ( 3 , sarray ); LinkedListCollection < Score > collection4 ; //... Analyze ( sarray , sarray + 3 , IsPass < Score * , Score > ( Score ( 70 , 60 , 60 ))); Analyze ( collection3 . begin (), collection4 . end (), IsPass < Score * , Score > ( Score ( 50 , 60 , 60 ))); Analyze ( collection4 . begin (), collection4 . end (), IsPass < LinkedListIterator < Score > , Score > ( Score ( 60 , 60 , 60 ))); } \u5224\u65ad\u53ca\u683c\u7684\u903b\u8f91\u6539\u53d8 \u65b0\u9700\u6c42\uff1a IsPass \u5982\u679c\u4e5f\u8981\u591a\u79cd\u5b9e\u73b0\uff0c\u6ca1\u8bfe\u90fd\u53ca\u683c\u548c\u603b\u5206\u53ca\u683c \u6b64\u65f6\u53ef\u4ee5\u628a IsPass \u51fd\u6570\u5bf9\u8c61\u4e0d\u4f5c\u4e3a Analyze \u7684 \u53c2\u6570 \u800c\u5c06\u5176\u7c7b\u578b\u4f5c\u4e3a Analyze \u7684 \u6a21\u677f\u53c2\u6570 \u4f20\u5165 template < class iterator_ , class IsPass_ > void Analyze ( iterator_ begin , iterator_ end , IsPass_ is_pass ) { int passsed = 0 , count = 0 ; for ( iterator_ p = begin ; p != end ; p ++ ) { if ( is_pass ( p )) passed ++ ; count ++ ; } cout << \"passing rate = \" << ( float ) passed / count << endl ; } \u8fd9\u6837\u5c31\u53ef\u4ee5\u662f\u5438\u7eb3\u4e0d\u540c\u7684 IsPass_ template < class iterator_ , class T > class IsPass_ForEach { public : IsPass_ForEach ( const T & pass ) : pass_ ( pass ) {} bool operator ()( const iteartor_ & p ) { return * p >= pass_ ; } private : T pass_ ; }; template < class iterator_ , class T > class IsPass_Total { public : IsPass_ForEach ( const T & pass ) : pass_ ( pass ) {} bool operator ()( const iteartor_ & p ) { return p -> GetTotal () >= pass . GetTotal (); } private : T pass_ ; }; \u5c0f\u7ed3 \u5bf9\u4e8e Analyze \u8fd9\u4e2a\u7b97\u6cd5 \u63cf\u8ff0 \u64cd\u4f5c \u53c2\u6570 \u9488\u904d\u5386\u96c6\u5408\u4e2d\u7684\u6240\u6709\u5143\u7d20 \u904d\u5386 iterator_ \u5224\u65ad\u662f\u5426\u53ca\u683c \u5224\u65ad IsPass_ \u7d2f\u52a0\u201c\u53ca\u683c\u201d\u6570\u91cf \u7d2f\u52a0 Analyze()\u672c\u8eab \u6709\u4e09\u4e2a\u65e0\u5173\uff08\u6b63\u4ea4\uff09\u7684\u53ef\u53d8\u90e8\u5206 \u57fa\u4e8e\u6a21\u677f\u7684\u7b56\u7565\u6a21\u5f0f \u7b56\u7565\u6a21\u5f0f\u7684\u6a21\u677f\u5b9e\u73b0 \u7528\u4e24\u4e2a\u7c7b\u53c2\u6570\u7ec4\u5408\u5f62\u6210\u4e00\u4e2a\u786e\u5b9a\u7684Analyze\u7b97\u6cd5\u5b9e\u4f8b\u3002 \u7b56\u7565\u6a21\u578b\u7684\u6a21\u677f\u5b9e\u73b0\uff1a \u8fd9\u91cc\u518d\u6b21\u4f53\u73b0\u4e86 \u7b56\u7565 \u6a21\u5f0f\u3002 \u518d\u770b\u8d1f\u8f7d\u76d1\u89c6\u5668 \u4f7f\u7528 \u6a21\u677f\u7b56\u7565 \u5b9e\u73b0\u8d1f\u8f7d\u76d1\u89c6\u5668 template < class load_ , class memory_ , class latency_ , class display_ > class Monitor : public load_ , public memory_ , public latency_ , public display_ { public : Monitor () {} void GetLoad () { load = load_ :: GetCPULoad (); } void GetTotalMemory () { total_memory = memory_ :: GetTotal (); } void GetUsedMemory () { used_memory = memory_ :: GetUsed (); } void GetNetworkLatency () { latency = latency_ :: GetLatency (); } void Show () { display_ :: Show ( load , total_memory , used_memory , latency ); } private : float load , latency ; long total_memory , used_memory ; }; \u8fd9\u91cc\u4e5f\u53ef\u4ee5\u4f7f\u7528\u7ec4\u5408\u4ee3\u66ff\u7ee7\u627f\u3002 \u76f8\u5e94\u4e3b\u7a0b\u5e8f int main ( int argc , char * argv []) { Monitor < Load , memory , Latency , Display > monitor ; while ( running ()) { monitor . GetLoad (); monitor . GetTotalMemory (); monitor . GetUsedMemory (); monitor . GetNetworkLatency (); monitor . Show (); sleep ( 1000 ); } } \u5b9a\u4e49\u7b56\u7565\u7c7b class Load { public : float GetCPULoqd (); }; class Memory { public : long GetTotal (); long GetUsed (); }; class Latency { public : float GetLatency (); }; \u663e\u793a\u7b56\u7565\u7c7b class Display { public : void Show ( float load , long total_memory , long used_memory , float latency ); }; STL Standard Template Library - \u6807\u51c6\u6a21\u677f\u5e93 \u4e00\u7ec4\u6700\u5e38\u7528\u7684\uff23++\u529f\u80fd\u7684\u6a21\u677f\u5b9e\u73b0 \u7b97\u6cd5 - min , max , for_each , find_if , copy , sort , stable_sort \u7b49 \u51fd\u6570\u5bf9\u8c61\u53ca\u5176\u64cd\u4f5c\uff1a\u7b97\u6cd5\u7684\u53ef\u53d8\u90e8\u5206 - greater , less , equal_to , logical_and , logical_or , no1 , not2 , bind1st , bind2nd , ptr_fun \u7b49 \u5bb9\u5668\u53ca\u5176\u8fed\u4ee3\u5668\uff1a\u7b97\u6cd5\u6240\u4f5c\u7528\u7684\u4e00\u7ec4\u6570\u636e\u53ca\u5bf9\u5176\u8fdb\u884c\u904d\u5386\u7684\u624b\u6bb5 - vector , dqueue , list , set , map , stack , queue \u53ca\u5176\u8fed\u4ee3\u5668, istream_oterator , ostream_iterator \u7b49 \u5176\u4ed6\uff1a\u5982 string \u7c7b","title":"\u7b97\u6cd5\u62c6\u5206 - \u5206\u79bb\u8868\u793a"},{"location":"design_pattern/split_representation/#-","text":"\u5c1d\u8bd5\u5c06\u7b97\u6cd5\u548c\u6570\u636e\u5206\u79bb\u3002 \u903b\u8f91\u3001\u6570\u636e\u5982\u4f55\u8868\u793a\u3001\u7b97\u6cd5\u7ec6\u8282\u4e1a\u52a1\u6d41\u7a0b\u7684\u7ec6\u8282\u76f8\u5173\u7684\u90e8\u5206 \u5206\u79bb\u3001\u89e3\u8026\u8fd9\u4e09\u8005 \u6cdb\u578b\u7f16\u7a0b\uff1a\u5148\u5b9e\u73b0\u7b97\u6cd5\u3001\u4f7f\u7528\u65f6\u518d\u8003\u8651\u6570\u636e\u7c7b\u578b \u6570\u636e\u7c7b\u578b\uff0c\u5bf9\u8ba1\u7b97\u673a\u5e95\u5c42\u662f\u4e00\u79cd\u8868\u793a\uff0c\u5bf9\u7b97\u6cd5\u662f\u4e00\u79cd\u675f\u7f1a","title":"\u7b97\u6cd5\u7eb5\u5411\u62c6\u5206 - \u5206\u79bb\u8868\u793a"},{"location":"design_pattern/split_representation/#_1","text":"","title":"\u8fed\u4ee3\u5668"},{"location":"design_pattern/split_representation/#_2","text":"\u7f16\u7a0b\u7edf\u8ba1\u8003\u8bd5\u53ca\u683c\u7387 int main ( int argc , char * argv []) { float scores [ STUDENT_COUNT ]; int passed = 0 ; // initialize scores here. for ( int i = 0 ; i != STUDENT_COUNT ; i ++ ) { if ( scores [ i ] >= 60 ) passed ++ ; } cout << \"passing rate = \" << ( float ) passed / STUDENT_COUNT << endl ; return EXIT_SUCCESS ; } \u6ce8\uff1a\u8fd9\u91cc\u7528 != \u800c\u4e0d\u7528 < \u7684\u539f\u56e0\u662f != \u7684\u6267\u884c\u66f4\u9ad8\u6548\u3002","title":"\u4ece\u95ee\u9898\u5f00\u59cb"},{"location":"design_pattern/split_representation/#_3","text":"\u628a\u201c\u5206\u6790\u201d\u5355\u72ec\u4f5c\u4e3a\u4e00\u4e2a\u529f\u80fd void Analyze ( float * scores , int student_count ) { int passed = 0 ; for ( int i = 0 ; i != student_count ; i ++ ) { if ( scores [ i ] >= 60 ) passed ++ ; } cout << \"passing rate = \" << ( float ) passed / student_count << endl ; } \u5982\u679c\u6210\u7ee9\u4f7f\u7528\u5355\u5411\u94fe\u8868\u5b58\u50a8 struct Student { float score ; Student * next ; }; //... Student * head ; \u5219\u5148\u524d\u7684 Analyze \u5931\u6548\u3002 \u91cd\u65b0\u5b9e\u73b0 Analyze \uff1a void Analyze ( Student * scores ) { int passed = 0 , count = 0 ; for ( Student * p = scores ; p != nullptr ; p = p -> next ) { if ( p -> score >= 60 ) passed ++ ; count ++ ; } cout << \"passing rate = \" << ( float ) passed / count << endl ; }","title":"\u8d23\u4efb\u5206\u89e3"},{"location":"design_pattern/split_representation/#_4","text":"\u4e0d\u53d8\u7684\u9700\u6c42\uff1a\u904d\u5386\u6240\u6709\u5b66\u751f\u7684\u6210\u7ee9 \u53d8\u5316\u7684\u5b58\u50a8\u65b9\u5f0f\uff1a\u64cd\u4f5c\u4e0d\u5e0c\u671b\u88ab\u67d0\u79cd\u5b58\u50a8\u65b9\u5f0f\u7ed1\u5b9a \u5206\u79bb\u201c\u53d8\u201d\u4e0e\u201c\u4e0d\u53d8\u201d \u628a\u201c\u8bbf\u95ee\u201d\u8bbe\u8ba1\u6210\u4e00\u4e2a\u63a5\u53e3 \u9488\u5bf9\u4e0d\u540c\u7684\u201c\u5b58\u50a8\u201d\u5b8c\u6210\u8fd9\u4e2a\u63a5\u53e3\u7684\u4e0d\u540c\u5b9e\u73b0","title":"\u201c\u904d\u5386\u201d\u7684\u9700\u6c42"},{"location":"design_pattern/split_representation/#_5","text":"\u628a\u201c\u8bbf\u95ee\u201d\u8bbe\u8ba1\u4e3a\u4e00\u4e2a\u63a5\u53e3 class Iterator { public : virtual ~ Iterator () {} virtual bool operator != ( const Iterator & other ) const = 0 ; virtual const Iterator & operator ++ () = 0 ; virtual const Iterator * operator ++ ( int ) = 0 ; virtual float & operator * () const = 0 ; virtual float & operator -> () const = 0 ; bool operator == ( const Iterator & other ) const { return ! ( * this != other ); } }; \u4f7f\u7528\u8fed\u4ee3\u5668 void Analyze ( Iterator * begin , Iterator * end ) { int passed = 0 , count = 0 ; for ( Iterator * p = begin ; * p != * end ; ( * p ) ++ ) { if ( ** p >= 60 ) passed ; count ++ ; } cout << \"passing rate = \" << ( float ) passed / count << endl ; } \u9700\u8981\u7ed9\u201c\u5b58\u50a8\u201d\u5bf9\u8c61\u4e00\u4e2a\u7ea6\u675f \u80fd\u591f\u8fd4\u56de\u4ee3\u8868\u201c\u5934\u201d\u548c\u201c\u5c3e\u201d\u7684\u8fed\u4ee3\u5668 \u4f7f\u7528\u201c\u5de6\u95ed\u53f3\u5f00\u533a\u95f4\u201d\uff0c\u5373 [begin, end) [begin, end) - \u4ee5\u4fbf\u4e8e\u7528 != \u5224\u65ad\u7ed3\u675f class Collection { public : virtual ~ Collection () {} virtual Iterator * begin () const = 0 ; virtual Iterator * end () const = 0 ; virtual int size () = 0 ; }; int main ( int argc , char * argv []) { Collection * collection ; // initialize collection here... Analyze ( collection -> begin (), collection -> end ()); }","title":"\u8fed\u4ee3\u5668"},{"location":"design_pattern/split_representation/#_6","text":"\u5b9e\u73b0\u57fa\u4e8e\u6570\u7ec4\u7684\u96c6\u5408 class ArrayCollection : public Collection { public : ArrayCollection () : size_ ( 10 ) { data_ = new float [ size_ ]; } ArrayCollection ( int size , float * data ) : size_ ( size ) { data_ = new float [ size_ ]; for ( int i = 0 ; i < size_ ; i ++ ) * ( data_ + i ) = * ( data + i ); } ~ ArrayCollection () { delete [] data_ ; } int size () { return size_ ; } Iterator * begin () const ; Iterator * end () const ; private : friend class ArrayIterator ; float * data_ ; int size_ \uff1b }; \u5176\u4e2d\u83b7\u53d6\u9996\u3001\u5c3e Iterator \u7684\u6210\u5458\u51fd\u6570\uff1a Iterator * ArrayCollection :: begin () const { return new ArrayIterator ( data_ , 0 ); } Iterator * ArrayCollection :: end () const { return new ArrayIterator ( data_ , size_ ); } \u5b9e\u73b0\u57fa\u4e8e\u6570\u7ec4\u7684\u8fed\u4ee3\u5668 class ArrayIterator : public Iterator { public : ArrayIterator ( float * data , int index ) : data_ ( data ), index_ ( index ) {} ArrayIterator ( const ArrayIterator & other ) : data_ ( other . data_ ), index_ ( other . index_ ) {} ~ ArrayIterator () {} const Iterator & operator ++ (); const Iterator & operator ++ ( int ); float & operator * () const ; float * operator -> () const ; bool operator != ( const Iterator & other ) const ; private : float * data_ ; int index_ ; }; const Iterator & ArrayIterator :: operator ++ () { index_ ++ ; return * this ; } const Iterator & ArrayIterator :: operator ++ ( int ) { index_ ++ ; return ArrayIterator ( data_ , index_ - 1 ); } float & ArrayIterator :: operator * () const { return * ( data_ + index_ ); } float * ArrayIterator :: operator -> () const { return ( data_ + index_ ); } bool ArrayIterator :: operator != ( const Iterator & other ) const { return data_ != (( ArrayIterator * )( & other )) -> data_ || index_ != (( ArrayIterator * )( & other )) -> index_ ; } \u91cd\u5199 Analyze \u548c main void Analyze ( Iterator * begin , Iterator * end ) { int passed = 0 , count = 0 ; for ( Iterator * p = begin ; * p != * end ; ( * p ) ++ ) { if ( ** p >= 60 ) passed ++ ; count ++ ; } cout << \"passing rate = \" << ( float ) passed / count << endl ; } int main () { float scores [] = { 90 , 20 , 40 , 40 , 30 , 60 , 70 , 30 , 90 , 100 }; Collection * collection = new ArrayCollection ( 10 , scores ); Analyze ( collection -> begin (), collection -> end ()); system ( \"PAUSE\" ); return EXIT_SUCCESS ; }","title":"\u8fed\u4ee3\u5668\u7684\u5b9e\u73b0"},{"location":"design_pattern/split_representation/#_7","text":"\u8bbe\u8ba1\u6a21\u5f0f \u63d0\u4f9b\u4e00\u79cd\u65b9\u6cd5\u987a\u5e8f\u8bbf\u95ee\u4e00\u4e2a\u805a\u5408\u5bf9\u8c61\u4e2d\u7684\u5404\u4e2a\u5143\u7d20 \u4e0d\u66b4\u9732\u8be5\u5bf9\u8c61\u7684\u5185\u90e8\u8868\u793a\u2014\u2014\u4e0e\u5bf9\u8c61\u7684\u5185\u90e8\u8868\u793a\u65e0\u5173\uff08\u6570\u7ec4\u8fd8\u662f\u94fe\u8868\uff09 //... for ( Iterator p = begin ; p != end ; p ++ ) { // do something with object *p; } //...","title":"\u8fed\u4ee3\u5668\u6a21\u5f0f"},{"location":"design_pattern/split_representation/#_8","text":"\u5982Java\u7b49\u8bed\u8a00\u4e0d\u63d0\u4f9b ++ \u7b49\u8fd0\u7b97\u7b26\u91cd\u8f7d\uff0c\u4e0a\u8ff0\u8fed\u4ee3\u5668\u6a21\u5f0f\u63d0\u4f9b\u4e86\u5355\u5411\u8fed\u4ee3\uff1a //... Iterator it = Collection . iterator (); while ( it . HasNext ()) { Object object = it . next (); // do something with object; } //...","title":"\u53e6\u4e00\u79cd\u5e38\u89c1\u7684\u8fed\u4ee3\u5668\u6a21\u5f0f"},{"location":"design_pattern/split_representation/#_9","text":"\u56fa\u5b9a\u7684\u4e1c\u897f\uff1a \u4ea7\u751f\u8fed\u4ee3\u5668\u7684\u65b9\u6cd5 \u8fed\u4ee3\u5668\u904d\u5386\u96c6\u5408\u7684\u63a5\u53e3 \u53d8\u5316\u7684\u4e1c\u897f\uff1a \u96c6\u5408\u7684\u5b58\u50a8\u65b9\u5f0f \u8fed\u4ee3\u5668\u904d\u5386\u96c6\u5408\u7684\u5177\u4f53\u5b9e\u73b0 \u8fed\u4ee3\u5668\u5b9e\u73b0\u4e86 \u904d\u5386\u64cd\u4f5c \u4e0e \u5b58\u50a8\u65b9\u6cd5 \u7684\u9694\u79bb\u3002\u4f7f\u5f97\u5b9e\u73b0\u7b97\u6cd5\u903b\u8f91\u65f6\u65e0\u9700\u5173\u5fc3\u6570\u636e\u8868\u793a\uff0c\u800c\u5b9e\u73b0\u6570\u636e\u5b58\u50a8\u7684\u65f6\u5019\u53c8\u65e0\u9700\u5173\u5fc3\u7b97\u6cd5\u7684\u903b\u8f91\u3002","title":"\u8fed\u4ee3\u5668\u4e0e\u6a21\u677f"},{"location":"design_pattern/split_representation/#_10","text":"\u53ef\u4ee5\u8bbe\u8ba1\u4e00\u4e9b\u5217\u901a\u7528\u7b97\u6cd5\uff1a max , min , sort , count , count_if , find , ... int main () { float scores [] = { 90 , 20 , 40 , 40 , 30 , 60 , 70 , 30 , 90 , 100 }; Collection * c = new ArrayCollection ( 10 , scores ); cout << \"passing rate = \" << ( float ) count_if ( c -> begin (), c -> end (), passed ()) / c . size () << endl ; system ( \"PAUSE\" ); return EXIT_SUCCESS ; }","title":"\u7b97\u6cd5\u7684\u901a\u7528\u5316"},{"location":"design_pattern/split_representation/#_11","text":"","title":"\u6539\u8fdb\u76ee\u6807"},{"location":"design_pattern/split_representation/#1","text":"\u5f53\u524d\u7684\u4f7f\u7528\u65b9\u5f0f void Analyze ( Iterator * begin , Iterator * end ) { for ( Iterator * p = begin ; * p != * end ; ( * p ) ++ ) { if ( ** p >= 60 ) //... } } \u671f\u5f85\u7684\u4f7f\u7528\u65b9\u5f0f void Analyze ( const Iterator & begin , const Iterator & end ) { for ( Iterator p = begin ; p != end ; p ++ ) { if ( * p >= 60 ) //... } }","title":"\u95ee\u9898 1"},{"location":"design_pattern/split_representation/#2","text":"\u53ea\u652f\u6301 float \u7c7b\u578b\uff0c\u89c1\u5982\u4e0b * \u548c -> \u7684\u91cd\u8f7d class Iterator { public : virtual ~ Iterator () {} virtual bool operator != ( const Iterator & other ) const = 0 ; virtual const Iterator & operator ++ () = 0 ; virtual const Iterator * operator ++ ( int ) = 0 ; virtual float & operator * () const = 0 ; virtual float & operator -> () const = 0 ; bool operator == ( const Iterator & other ) const { return ! ( * this != other ); } };","title":"\u95ee\u9898 2"},{"location":"design_pattern/split_representation/#_12","text":"\u6211\u4eec\u9700\u8981\u4e00\u79cd\u65b9\u6cd5\uff0c\u5728\u7f16\u5199\u4ee3\u7801\u65f6\u5c06\u7c7b\u578b\u4f5c\u4e3a\u53ef\u53d8\u90e8\u5206\uff0c\u8fd9\u4e9b\u90e8\u5206\u5728\u4f7f\u7528\u524d\u5fc5\u987b\u505a\u51fa\u6307\u660e\u3002\u5982\u6b64\u4e00\u6765\uff0c\u53ef\u4ee5\u5148\u8003\u8651\u901a\u7528\u7684\u7b97\u6cd5\u548c\u62bd\u8c61\u7684\u6570\u636e\u7ed3\u6784\uff0c\u7136\u540e\u518d\u5728\u4f7f\u7528\u65f6\u4e88\u4ee5\u5b9e\u4f8b\u5316 \u4f7f\u7528 \u6a21\u677f \u6280\u672f\u5b9e\u73b0 \u6cdb\u578b \u3002","title":"\u5f15\u5165\u6a21\u677f"},{"location":"design_pattern/split_representation/#_13","text":"template < class iterator_ > void Analysis ( iterator_ begin , iterator_ end ) { int passed = 0 , count = 0 ; for ( iterator_ p = begin ; p != end ; p ++ ) { if ( * p >= 60 ) passed ++ ; count ++ ; } cout << \"passing rate = \" << ( float ) passed / count << endl ; } \u8fd9\u91cc iterator_ \u7c7b\u578b\u7684\u53d8\u91cf\u9700\u8981\u5b9e\u73b0 = , != , ++ \u8fd0\u7b97\u7b26\u3002 template < class T > class ArrayCollection { public : ArrayCollection () : size_ ( 10 ) { data_ = new T [ size_ ]; } ArrayCollection ( int size ) : size ( size_ ) { data_ = new T [ size_ ]; } ArrayCollection ( int size , T * data ) : size_ ( size ) { data_ = new T [ size_ ]; for ( int i = 0 ; i < size_ ; i ++ ) * ( data_ + i ) = * ( data + i ); } ~ ArrayCollection () { delete [] data_ ; } T * begin (){ return data_ ; } T * end () { return data_ + size_ ; } private : T * data_ ; int size_ ; };","title":"\u901a\u7528\u7b97\u6cd5"},{"location":"design_pattern/split_representation/#_14","text":"template < class T > struct LinkiedListNode { T data_ ; LinkedListNode * next ; LinkedListNode () : next ( nullptr ) {} LinkedListNode ( T data ) : data_ ( data ), next ( nullptr ) {} }; template < class T > struct LinkedListIterator { LinkedListNode < T >* pointer ; LinkedListIterator ( LinkiedListNode < T >* p ) : pointer ( p ) {} LinkedListIterator ( const LinkedListIterator < T >& it ) : pointer ( it . pointer ) {} LinkedListIterator < T >& operator ++ () { pointer = pointer -> next ; return * this ; } const LinkedListIterator < T > operator ++ ( int ) { LinkedListIterator < T > temp = * this ; pointer = pointer -> next ; return temp ; } T & operator * () const { return pointer -> data_ ; } T * operator -> () const { return & ( pointer -> data_ ); } bool operator != ( const LinkedListIterator < T >& other ) { return pointer != other . pointer ; } bool operator == ( const LinkedListIterator < T >& other ) { return pointer == other . pointer ; } }; template < class T > class LinkedListCollection { public : LinkedListCollection () : head_ ( nullptr ) {} LinkedListCollection ( int size , T * datq ) { //... } ~ LinkedListCollection () { //... } LinkedListIterator < T > begin () { return LinkedListIterator < T > ( head_ ); } LinkedListIterator < T > end () { return LinkedListIterator < T > ( nullptr ); } private : LinkedListNode < T >* head ; }; \u4f7f\u7528\u5982\u4e0b\uff1a int main () { float scores [] = { 90 , 20 , 40 , 40 , 30 , 60 , 70 , 30 , 90 , 100 }; ArrayCollection < float > collection2 ( 10 , scores ); LinkedListCollection < float > collection1 ( 10 , scores ); Analyze ( scores , scores + 10 ); Analyze ( collection1 . begin (), collection1 . end ()); Analyze ( collection2 . begin (), collection2 . end ()); system ( \"PAUSE\" ); return EXIT_SUCCESS ; } \u8fd9\u91cc\u6307\u9488\u7531\u4e8e\u652f\u6301 = , != , ++ \u64cd\u4f5c\uff0c\u5728\u8fd9\u91cc\u4e5f\u53ef\u4ee5\u4f5c\u4e3a\u8fed\u4ee3\u5668\u4f7f\u7528\u3002 \u4e8b\u5b9e\u4e0a\uff0c\u6307\u9488\u662f\u4e00\u79cd\u8fed\u4ee3\u5668\uff0c\u8fed\u4ee3\u5668\u4e5f\u662f\u4e00\u79cd\u6307\u9488\u3002","title":"\u94fe\u8868\u8282\u70b9\u3001\u94fe\u8868\u8fed\u4ee3\u5668\u3001\u94fe\u8868\u5bb9\u5668"},{"location":"design_pattern/split_representation/#_15","text":"\u5bb9\u5668\uff1a\u5b58\u50a8\u6570\u636e\uff0c\u6570\u636e\u7684\u8868\u793a \u7b97\u6cd5\uff1a\u5904\u7406\u6570\u636e\uff0c\u62bd\u8c61\u7684\u7b97\u6cd5\u5b9e\u73b0 \u8fed\u4ee3\u5668\uff1a\u6807\u51c6\u7684\u6570\u636e\u904d\u5386\u63a5\u53e3\uff0c\u9694\u79bb\u7b97\u6cd5\u4e0e\u5bb9\u5668\uff0c\u662f\u7b97\u6cd5\u4e0e\u6570\u636e\u7684\u8868\u793a\u65e0\u5173 \u5b9e\u73b0\u901a\u7528\u7684\u7b97\u6cd5\uff0c\u5c06\u7b97\u6cd5\u4e0e\u6570\u636e\u8868\u793a\u89e3\u8026\u3002","title":"\u7b97\u6cd5\u4e0e\u6570\u636e\u89e3\u8026"},{"location":"design_pattern/split_representation/#3","text":"\u5982\u679c\u4e0a\u8ff0\u95ee\u9898\u8003\u8bd5\u79d1\u76ee\u53d8\u62103\u79d1\uff0c\u5219 float \u578b\u53d8\u91cf\u4e0d\u80fd\u8868\u793a\u5206\u6570\uff0c\u5b9a\u4e49 Score \u7c7b\u578b struct Score { float value [ 3 ]; Score () {} Score ( float f1 , float f2 , float f3 ) { value [ 0 ] = f1 ; value [ 1 ] = f2 ; value [ 2 ] = f3 ; } Score & operator = ( const Score & s ) { value [ 0 ] = s . value [ 0 ]; value [ 1 ] = s . value [ 1 ]; value [ 2 ] = s . value [ 2 ]; return * this ; } bool operator >= ( float pass ) { return value [ 0 ] >= pass && value [ 1 ] >= pass & value [ 2 ] >= pass ; } }; ostream & operator << ( ostream & out , const Score & s ) { cout << \"{\" << s . value [ 0 ] << \", \" << s . value [ 1 ] << \", \" << s . value [ 2 ] << \"}\" ; return out ; } \u76f8\u5e94\u5730\u4e3b\u51fd\u6570\u53d8\u4e3a int main ( int argc , char * argv []) { Score sarray [ 3 ]; sarray [ 0 ] = Score ( 60 , 60 , 60 ); sarray [ 1 ] = Score ( 70 , 70 , 70 ); sarray [ 2 ] = Score ( 50 , 80 , 80 ); ArrayCollection < Score > collection3 ( 3 , sarray ); LinkedListCollection < Score > collection4 ( 3 , sarray ); Analyze ( sarray , sarray + 3 ); Analyze ( collection3 . begin (), collection3 . end ()); Analyze ( collection4 . begin (), collection4 . end ()); system ( \"PAUSE\" ); return EXIT_SUCCESS ; }","title":"\u8003\u8bd5\u79d1\u76ee\u6570\u53d8\u62103"},{"location":"design_pattern/split_representation/#_16","text":"\u5bf9\u4e8e\u4e00\u4e2a\u6570\u636e\u7c7b\u578b\uff0c \u503c \u64cd\u4f5c \u62bd\u8c61\u63a5\u53e3 \u503c\u57df \u53ef\u7528\u7684\u64cd\u4f5c \u5177\u4f53\u5b9e\u73b0 \u5982\u4f55\u5b58\u50a8 \u5982\u4f55\u5b9e\u73b0\u64cd\u4f5c \u5bf9\u4e8e \u53ef\u7528\u7684\u64cd\u4f5c \u90e8\u5206\uff0c\u5bf9\u5982 = , != , ++ , * \u7684\u652f\u6301\u662f\u7b97\u6cd5\u6240\u5173\u5fc3\u7684\u3002\u7b97\u6cd5\u5b9e\u9645\u4e0a\u53ea\u4e0e \u53ef\u7528\u7684\u64cd\u4f5c \u76f8\u5173\uff0c\u4e0e\u5177\u4f53\u6570\u636e\u7c7b\u578b\u65e0\u5173\u3002","title":"\u5982\u4f55\u5b9e\u73b0\u89e3\u8026"},{"location":"design_pattern/split_representation/#_17","text":"\u7b97\u6cd5\u4ec5\u4e0e\u201c\u53ef\u7528\u7684\u64cd\u4f5c\u201d\u76f8\u5173\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u629b\u5f00\u7c7b\u578b\u8003\u8651\u7b97\u6cd5\uff0c\u5b9e\u73b0\u62bd\u8c61\u8fd0\u7b97\uff0c\u5728\u7b97\u6cd5\u548c\u6570\u636e\u7c7b\u578b\uff08\u5b58\u50a8\uff09\u4e4b\u95f4\u5b9e\u73b0\u89e3\u8026\u3002 \u5728C++\u4e2d\uff0c\u201c\u53ef\u7528\u7684\u64cd\u4f5c\u201d\u65f6\u4f7f\u7528\u8fd0\u7b97\u7b26\u6765\u63cf\u8ff0\u7684\uff08\u5982 * , ++ , != , >= \uff09\uff0c\u4ed6\u4f5c\u7528\u5728\u6307\u5b9a\u6570\u91cf\u7684\u64cd\u4f5c\u6570\u4e0a\uff0c\u8fd4\u56de\u4e00\u4e2a\u7ed3\u679c\u3002 \u5982\u679c\u6211\u4eec\u9700\u8981\u67d0\u4e2a\u6570\u636e\u7c7b\u578b\u53ef\u4ee5\u4f7f\u7528\u5728\u67d0\u4e2a\u7b97\u6cd5\u4e2d\uff0c\u53ea\u8981\u5b9e\u73b0\u76f8\u5173\u7684\u64cd\u4f5c\u5c31\u53ef\u4ee5\u4e86\u3002 \u8fd9\u4f9d\u8d56\u4e8e\u8fd0\u7b97\u7b26\u91cd\u8f7d\uff0c\u4e5f\u53ef\u4ee5\u8ba4\u4e3a\u662f\u8fd0\u7b97\u7b26\u91cd\u8f7d\u7684\u672c\u6765\u76ee\u7684\uff1a \u8fd0\u7b97\u7b26\u91cd\u8f7d\u5c31\u662f\u5728\u65b0\u7684\u6570\u636e\u7c7b\u578b\u4e0a\u8fd8\u539f\u8fd0\u7b97\u7b26\u7684\u672c\u8d28 \u3002","title":"\u7b97\u6cd5\u3001\u8fd0\u7b97\u7b26\u3001\u8fd0\u7b97\u7b26\u91cd\u8f7d"},{"location":"design_pattern/split_representation/#_18","text":"\u53ef\u7528\u7684\u64cd\u4f5c\u662f\u6570\u636e\u7c7b\u578b\u7684\u62bd\u8c61\u63a5\u53e3\u3002 \u6570\u636e\u7c7b\u578b\u4e5f\u53ef\u4ee5\u7528 \u53ef\u7528\u64cd\u4f5c\u7684\u96c6\u5408 \u6765\u754c\u5b9a\uff0c\u5177\u6709\u76f8\u540c\u201c\u53ef\u7528\u64cd\u4f5c\u96c6\u5408\u201d\u5c31\u662f\u76f8\u540c\u7684\u6570\u636e\u7c7b\u578b\u3002 \u5982\u679c\u628a\u201c\u64cd\u4f5c\u201d\u66f4\u52a0\u6cdb\u534e\uff0c\u5c06\u5176\u5b9a\u4e49\u5230\u4e00\u4e2a\u62bd\u8c61\u5b9e\u4f53\u4e0a\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5\u628a\u201c\u6570\u636e\u7c7b\u578b\u201d\u8fdb\u4e00\u6b65\u62bd\u8c61\u5316\u3002","title":"\u6570\u636e\u7c7b\u578b\u4e0e\u64cd\u4f5c"},{"location":"design_pattern/split_representation/#_19","text":"\u9664\u4e86\u201c\u62bd\u8c61\u7b97\u6cd5\u201d\u4e4b\u5916\uff0c\u8fd8\u6709\u201c\u62bd\u8c61\u7ed3\u6784\u201d Stack , LinkedList , Vector \u8fd9\u4e9b\u62bd\u8c61\u7ed3\u6784\uff0c\u4e0e\u5b58\u50a8\u4ec0\u4e48\u6570\u636e\u65e0\u5173\uff0c\u81f3\u4e8e\u6570\u636e\u7684\u5b58\u50a8\u65b9\u5f0f\u548c\u8bbf\u95ee\u65b9\u5f0f\u76f8\u5173\uff0c\u53ef\u4ee5\u501f\u52a9\u7c7b\u6a21\u677f\u5b9e\u73b0\u3002","title":"\u62bd\u8c61\u7ed3\u6784\u4e0e\u7c7b\u6a21\u677f"},{"location":"design_pattern/split_representation/#_20","text":"\u4f8b\u5982\u4e0b\u65b9\u94fe\u8868 template < class T > struct LinkedListNode { T data_ ; LinkedListNode * next_ ; LinkedListNode () : next_ ( nullptr ) {} LinkedListNode ( T data ) : data_ ( data ), next_ ( nullptr ) {} LinkedListNode ( T data , LinkedListNode * next ) : data_ ( data ), next_ ( next ) {} }; template < class T > class LinkedListCollection { public : LinkedListCollection () : head_ ( nullptr ) {} ~ LinkedListCollection () { clear (); } bool empty () { return head_ == nullptr ; } void AddFirst ( const T & data ) { head_ = new LinkedListNode < T > )( data , head_ ); } bool RemoveFirst () { if ( head_ != nullptr ) { LinkedListNode < T >* p = head_ ; head_ = head_ -> next_ ; delete p ; return true ; } else { return false ; } } T * GetFirst () { return head_ != nullptr ? & ( head_ -> data_ ) : nullptr ; } bool RemoveLast () { if ( head_ != nullptr ) { if ( head_ -> next_ != nullptr ) { LinkedListNode < T >* p ; for ( p = head_ ; p -> next_ -> next_ != nullptr ; p = p -> next_ ) ; delete p -> next_ ; p -> next_ = nullptr ; return true ; } else { delete head_ ; head_ = nullptr ; return true ; } } else { return false ; } } clear () { while ( RemoveFirst ()) ; } LinkedListIterator < T > begin () { return LinkedListIterator < T > ( head_ ); } LinkedListIterator < T > end () { return LinkedListIterator < T > ( nullptr ); } private : LinkedListNode < T >* head_ ; }; \u5173\u4e8e \u5185\u8054\u51fd\u6570 \uff1a C++\u4e2d inline \u5173\u952e\u5b57\u4fee\u9970\u51fd\u6570\u5b9a\u4e49\uff08\u544a\u8bc9\u7f16\u8bd1\u5668\u8fd9\u4e2a\u51fd\u6570\u53ef\u80fd\u88ab\u9891\u7e41\u4f7f\u7528\uff0c\u5bf9\u6027\u80fd\u8981\u6c42\u654f\u611f\uff0c\u8c03\u7528\u65f6\u4f7f\u7528\u5185\u8054\u5c55\u5f00\uff0c\u907f\u514d\u5165\u6808\u51fa\u6808\u7684\u64cd\u4f5c\uff09 inline int max(int a, int b) { return a > b ? a : b; } \u4f5c\u7528\uff1a\u51fd\u6570\u5185\u8054\u5c55\u5f00\uff0c\u907f\u514d\u51fd\u6570\u8c03\u7528\u5f00\u9500\uff0c\u7528\u7a7a\u95f4\u6362\u65f6\u95f4\u3002 \u5728\u7c7b\u5b9a\u4e49\u4f53\u5185\u5b9a\u4e49\uff08\u5b9e\u73b0\uff09\u7684\u51fd\u6570\u7f3a\u7701\u4e3a\u5185\u8054\u51fd\u6570\u3002 \u5230\u6b64\u4e3a\u6b62 \u6211\u4eec\u4e3a\u4efb\u610f\u7c7b\u578b\u5143\u7d20\u5b9e\u73b0\u94fe\u8868\u7684\u65b9\u5f0f\u3002","title":"\u5b9e\u73b0\u4e00\u4e2a\u94fe\u8868\u6a21\u677f"},{"location":"design_pattern/split_representation/#_21","text":"\u901a\u8fc7\u6a21\u677f\u5b9e\u4f8b\u5316\u4f7f\u7528Linked List\uff08\u62bd\u8c61\u7ed3\u6784\uff09 int main ( int argc , char * argv []) { //... LinkedListCollection < Score > collection4 ; for ( int i = 0 ; i < 3 ; i ++ ) collection4 . AddFirst ( sarray [ i ]); Analyze ( collection4 . begin (), collection4 . end ()); //... return EXIT_SUCCESS ; }","title":"\u7528\u94fe\u8868\u6a21\u677f\u7ec4\u7ec7\u5206\u6570"},{"location":"design_pattern/split_representation/#_22","text":"\u56fa\u5b9a\u7684\u4e1c\u897f\uff1a \u7b97\u6cd5/\u62bd\u8c61\u7ed3\u6784\u7684\u63a5\u53e3\u4e0e\u5b9e\u73b0 \u201c\u6570\u636e\u201d\u7684\u8bbf\u95ee\u63a5\u53e3\uff08\u8fed\u4ee3\u5668\uff09 \u201c\u6570\u636e\u201d\u7684\u53ef\u7528\u64cd\u4f5c\uff08\u8fd0\u7b97\u7b26\u91cd\u8f7d\uff09 \u53d8\u5316\u7684\u4e1c\u897f\uff1a \u201c\u6570\u636e\u201d\u7684\u7ec4\u7ec7\u5f62\u5f0f \u201c\u6570\u636e\u201d\u7684\u7c7b\u578b\uff08\u503c\u57df\u3001\u5b58\u50a8\u3001\u64cd\u4f5c\u5b9e\u73b0\uff09 \u7531\u6b64\u5b9e\u73b0\u201c\u7b97\u6cd5/\u62bd\u8c61\u7ed3\u6784\u201d\u4e0e\u201c\u6570\u636e\u8868\u793a\u201d\u4e4b\u95f4\u7684\u5206\u79bb \u6cdb\u578b\u7f16\u7a0b \uff1a\u5148\u5b9e\u73b0\u7b97\u6cd5\uff0c\u518d\u5145\u5b9e\u6570\u636e\u8868\u793a\uff08\u7c7b\u578b\uff09","title":"\u5c0f\u7ed3"},{"location":"design_pattern/split_representation/#_23","text":"","title":"\u51fd\u6570\u5bf9\u8c61\u4e0e\u7b97\u6cd5\u5206\u89e3"},{"location":"design_pattern/split_representation/#_24","text":"\u5982\u679c\u67d0\u4e9b\u79d1\u76ee\u7684\u53ca\u683c\u7ebf\u4e0d\u662f60\u5206 \u73b0\u6709\u7684 Analyze \u51fd\u6570 template < class iterator_ > void Analyze ( iterator_ begin , iterator_ end ) { int passsed = 0 , count = 0 ; for ( iterator_ p = begin ; p != end ; p ++ ) { if ( * p >= 60 ) passed ++ ; count ++ ; } cout << \"passing rate = \" << ( float ) passed / count << endl ; } \u5c06\u5224\u65ad\u53ca\u683c\u51fd\u6570 IsPass \u7684\u51fd\u6570\u6307\u9488\u4f5c\u4e3a\u53c2\u6570\u4f20\u7ed9 Analyze template < class iterator_ > void Analyze ( iterator_ begin , iterator_ end , bool ( * IsPass )( const iterator_ & )) { int passsed = 0 , count = 0 ; for ( iterator_ p = begin ; p != end ; p ++ ) { if ( IsPass ( p )) passed ++ ; count ++ ; } cout << \"passing rate = \" << ( float ) passed / count << endl ; } \u4f7f\u7528\u201c\u5224\u65ad\u53ca\u683c\u201d\u51fd\u6570\u6307\u9488 template < class iterator_ > bool IsPass ( const iterator_ & p ) { return p -> value [ 0 ] >= 70 && p -> value [ 1 ] >= 60 && p -> value [ 2 ] >= 60 ; } \u6ce8\uff1a\u8fd9\u91cc\u7684` IsPass `\u6709\u7f3a\u9677\uff1a\u53ea\u9002\u7528\u4e8e` Score `\u7c7b\u578b int main ( int argc , char * argv []) { //... Analyze ( sarray , sarray + 3 , IsPass < Score *> ); Analyze ( collection3 . begin (), collection3 . end (), IsPass < Score *> ); Analyze ( collection4 . begin (), collection4 . end (), IsPass < LinkedListIterator < Score >> ); //... }","title":"\u5f53\u201c\u53ca\u683c\u201d\u5224\u5b9a\u89c4\u5219\u53d1\u751f\u53d8\u5316"},{"location":"design_pattern/split_representation/#_25","text":"\u8fd9\u4e24\u4e2a\u51fd\u6570\u552f\u4e00\u7684\u4e0d\u540c\u5c31\u662f\u201c\u79d1\u4e00\u201d\u7684\u53ca\u683c\u5206\u6570 template < class iterator_ > bool IsPass ( const iterator_ & p ) { return p -> value [ 0 ] >= 70 && p -> value [ 1 ] >= 60 && p -> value [ 2 ] >= 60 ; } template < class iterator_ > bool IsPass ( const iterator_ & p ) { return p -> value [ 0 ] >= 60 && p -> value [ 1 ] >= 60 && p -> value [ 2 ] >= 60 ; } \u5982\u4f55\u62bd\u79bb\u51fa\u76f8\u540c\u7684\u5904\u7406\u903b\u8f91\uff0c\u5c06\u201c\u53ca\u683c\u7ebf\u201d\u8bb0\u5f55\u4e0b\u6765 \u4f7f\u7528 Score \u53d8\u91cf const Score pass ( 70 , 60 , 60 ); template < class iterator_ > bool IsPass ( const iterator_ & p ) { return p -> value [ 0 ] >= pass . value [ 0 ] && p -> value [ 1 ] >= pass . value [ 1 ] && p -> value [ 2 ] >= pass . value [ 2 ]; } \u4f7f\u7528\u6587\u4ef6 template < class iterator_ > bool IsPass ( const iterator_ & p ) { float pass1 , pass2 , pass3 ; ifstream is ( \"pass-score.txt\" ); is >> pass1 >> pass2 >> pass3 ; return p -> value [ 0 ] >= pass1 && p -> value [ 1 ] >= pass2 && p -> value [ 2 ] >= pass3 ; } \u53ef\u4ee5\u901a\u8fc7\u4fee\u6539 pass-score.txt \u7684\u5185\u5bb9\u6539\u53d8\u53ca\u683c\u5206\u6570\u7ebf\u7ec4\u5408\u3002 \u8fd9\u91cc \u5355\u4e00\u5b9e\u4f8b \u7684\u95ee\u9898\u4f9d\u7136\u5b58\u5728\uff0c\u95ee\u9898\u5728\u4e8e\u51fd\u6570\u662f\u56fa\u5b9a\u7684\u3002","title":"\u8fdb\u4e00\u6b65\u89e3\u8026"},{"location":"design_pattern/split_representation/#_26","text":"\u5b9a\u4e49 IsPass \u51fd\u6570\u5bf9\u8c61\u7c7b\u6a21\u677f template < class iterator_ , class T > class IsPass { public : IsPass ( const T & pass ) : pass_ ( pass ) {} bool operator ()( const iterator_ & p ) { return * p >= pass_ ; } private : T pass_ ; }; \u76f8\u5e94\u6539\u53d8\u7b97\u6cd5\u5b9a\u4e49 template < class iterator_ , class T > void Analyze ( iterator_ begin , iterator_ end , IsPass < iterator_ , T > is_pass ) { int passsed = 0 , count = 0 ; for ( iterator_ p = begin ; p != end ; p ++ ) { if ( is_pass ( p )) passed ++ ; count ++ ; } cout << \"passing rate = \" << ( float ) passed / count << endl ; } \u4f7f\u7528\u51fd\u6570\u5bf9\u8c61 int main ( int argc , char * argv []) { //... sarray [ 0 ] = Score ( 60 , 60 , 60 ); sarray [ 1 ] = Score ( 70 , 70 , 70 ); sarray [ 2 ] = Score ( 50 , 80 , 80 ); ArrayCollection < Score > collection3 ( 3 , sarray ); LinkedListCollection < Score > collection4 ; //... Analyze ( sarray , sarray + 3 , IsPass < Score * , Score > ( Score ( 70 , 60 , 60 ))); Analyze ( collection3 . begin (), collection4 . end (), IsPass < Score * , Score > ( Score ( 50 , 60 , 60 ))); Analyze ( collection4 . begin (), collection4 . end (), IsPass < LinkedListIterator < Score > , Score > ( Score ( 60 , 60 , 60 ))); }","title":"\u51fd\u6570\u5bf9\u8c61"},{"location":"design_pattern/split_representation/#_27","text":"\u65b0\u9700\u6c42\uff1a IsPass \u5982\u679c\u4e5f\u8981\u591a\u79cd\u5b9e\u73b0\uff0c\u6ca1\u8bfe\u90fd\u53ca\u683c\u548c\u603b\u5206\u53ca\u683c \u6b64\u65f6\u53ef\u4ee5\u628a IsPass \u51fd\u6570\u5bf9\u8c61\u4e0d\u4f5c\u4e3a Analyze \u7684 \u53c2\u6570 \u800c\u5c06\u5176\u7c7b\u578b\u4f5c\u4e3a Analyze \u7684 \u6a21\u677f\u53c2\u6570 \u4f20\u5165 template < class iterator_ , class IsPass_ > void Analyze ( iterator_ begin , iterator_ end , IsPass_ is_pass ) { int passsed = 0 , count = 0 ; for ( iterator_ p = begin ; p != end ; p ++ ) { if ( is_pass ( p )) passed ++ ; count ++ ; } cout << \"passing rate = \" << ( float ) passed / count << endl ; } \u8fd9\u6837\u5c31\u53ef\u4ee5\u662f\u5438\u7eb3\u4e0d\u540c\u7684 IsPass_ template < class iterator_ , class T > class IsPass_ForEach { public : IsPass_ForEach ( const T & pass ) : pass_ ( pass ) {} bool operator ()( const iteartor_ & p ) { return * p >= pass_ ; } private : T pass_ ; }; template < class iterator_ , class T > class IsPass_Total { public : IsPass_ForEach ( const T & pass ) : pass_ ( pass ) {} bool operator ()( const iteartor_ & p ) { return p -> GetTotal () >= pass . GetTotal (); } private : T pass_ ; };","title":"\u5224\u65ad\u53ca\u683c\u7684\u903b\u8f91\u6539\u53d8"},{"location":"design_pattern/split_representation/#_28","text":"\u5bf9\u4e8e Analyze \u8fd9\u4e2a\u7b97\u6cd5 \u63cf\u8ff0 \u64cd\u4f5c \u53c2\u6570 \u9488\u904d\u5386\u96c6\u5408\u4e2d\u7684\u6240\u6709\u5143\u7d20 \u904d\u5386 iterator_ \u5224\u65ad\u662f\u5426\u53ca\u683c \u5224\u65ad IsPass_ \u7d2f\u52a0\u201c\u53ca\u683c\u201d\u6570\u91cf \u7d2f\u52a0 Analyze()\u672c\u8eab \u6709\u4e09\u4e2a\u65e0\u5173\uff08\u6b63\u4ea4\uff09\u7684\u53ef\u53d8\u90e8\u5206","title":"\u5c0f\u7ed3"},{"location":"design_pattern/split_representation/#_29","text":"","title":"\u57fa\u4e8e\u6a21\u677f\u7684\u7b56\u7565\u6a21\u5f0f"},{"location":"design_pattern/split_representation/#_30","text":"\u7528\u4e24\u4e2a\u7c7b\u53c2\u6570\u7ec4\u5408\u5f62\u6210\u4e00\u4e2a\u786e\u5b9a\u7684Analyze\u7b97\u6cd5\u5b9e\u4f8b\u3002 \u7b56\u7565\u6a21\u578b\u7684\u6a21\u677f\u5b9e\u73b0\uff1a \u8fd9\u91cc\u518d\u6b21\u4f53\u73b0\u4e86 \u7b56\u7565 \u6a21\u5f0f\u3002","title":"\u7b56\u7565\u6a21\u5f0f\u7684\u6a21\u677f\u5b9e\u73b0"},{"location":"design_pattern/split_representation/#_31","text":"\u4f7f\u7528 \u6a21\u677f\u7b56\u7565 \u5b9e\u73b0\u8d1f\u8f7d\u76d1\u89c6\u5668 template < class load_ , class memory_ , class latency_ , class display_ > class Monitor : public load_ , public memory_ , public latency_ , public display_ { public : Monitor () {} void GetLoad () { load = load_ :: GetCPULoad (); } void GetTotalMemory () { total_memory = memory_ :: GetTotal (); } void GetUsedMemory () { used_memory = memory_ :: GetUsed (); } void GetNetworkLatency () { latency = latency_ :: GetLatency (); } void Show () { display_ :: Show ( load , total_memory , used_memory , latency ); } private : float load , latency ; long total_memory , used_memory ; }; \u8fd9\u91cc\u4e5f\u53ef\u4ee5\u4f7f\u7528\u7ec4\u5408\u4ee3\u66ff\u7ee7\u627f\u3002 \u76f8\u5e94\u4e3b\u7a0b\u5e8f int main ( int argc , char * argv []) { Monitor < Load , memory , Latency , Display > monitor ; while ( running ()) { monitor . GetLoad (); monitor . GetTotalMemory (); monitor . GetUsedMemory (); monitor . GetNetworkLatency (); monitor . Show (); sleep ( 1000 ); } } \u5b9a\u4e49\u7b56\u7565\u7c7b class Load { public : float GetCPULoqd (); }; class Memory { public : long GetTotal (); long GetUsed (); }; class Latency { public : float GetLatency (); }; \u663e\u793a\u7b56\u7565\u7c7b class Display { public : void Show ( float load , long total_memory , long used_memory , float latency ); };","title":"\u518d\u770b\u8d1f\u8f7d\u76d1\u89c6\u5668"},{"location":"design_pattern/split_representation/#stl","text":"Standard Template Library - \u6807\u51c6\u6a21\u677f\u5e93 \u4e00\u7ec4\u6700\u5e38\u7528\u7684\uff23++\u529f\u80fd\u7684\u6a21\u677f\u5b9e\u73b0 \u7b97\u6cd5 - min , max , for_each , find_if , copy , sort , stable_sort \u7b49 \u51fd\u6570\u5bf9\u8c61\u53ca\u5176\u64cd\u4f5c\uff1a\u7b97\u6cd5\u7684\u53ef\u53d8\u90e8\u5206 - greater , less , equal_to , logical_and , logical_or , no1 , not2 , bind1st , bind2nd , ptr_fun \u7b49 \u5bb9\u5668\u53ca\u5176\u8fed\u4ee3\u5668\uff1a\u7b97\u6cd5\u6240\u4f5c\u7528\u7684\u4e00\u7ec4\u6570\u636e\u53ca\u5bf9\u5176\u8fdb\u884c\u904d\u5386\u7684\u624b\u6bb5 - vector , dqueue , list , set , map , stack , queue \u53ca\u5176\u8fed\u4ee3\u5668, istream_oterator , ostream_iterator \u7b49 \u5176\u4ed6\uff1a\u5982 string \u7c7b","title":"STL"},{"location":"design_pattern/split_steps/","text":"\u7b97\u6cd5\u6a2a\u5411\u62c6\u5206 - \u5206\u79bb\u6b65\u9aa4 \u9762\u5411\u5bf9\u8c61\u7684\u63a5\u53e3\u8bbe\u8ba1\u8981\u65f6\u523b\u9075\u5faa\u529f\u80fd\u7684 \u5355\u4e00\u6027 \u539f\u5219\u3002 \u8bbe\u8ba1\u4e00\u4e2a\u8d1f\u8f7d\u76d1\u89c6\u5668 \u8d1f\u8f7d\u76d1\u89c6\u5668 \u76d1\u89c6\u8ba1\u7b97\u8282\u70b9\u7684\u6577\u5728\u72b6\u6001\uff08\u5982CPU\u5360\u7528\u7387\u3001\u5b58\u50a8\u5668\u5360\u7528\u7387\u3001\u5230\u67d0\u4e2a\u7279\u5b9a\u8282\u70b9\u7684\u7f51\u7edc\u5ef6\u8fdf\uff09\u3002 \u4ee5CPU\u5360\u7528\u7387\u7684\u76d1\u89c6\u4e3a\u4f8b\uff0c\u4e0d\u540c\u6761\u4ef6\u4e0b\uff08\u4f8b\u5982\u4e0d\u540c\u79cd\u7c7b\u4e0d\u540c\u7248\u672c\u7684OS\uff09\u83b7\u5f97CPU\u5360\u7528\u7387\u7684\u65b9\u6cd5\u4e0d\u540c\u3002 \u600e\u6837\u5728\u4e00\u4e2a\u7a0b\u5e8f\u4e2d\u5b9e\u73b0\u5bf9\u8fd9\u4e9b\u4e0d\u540c\u6761\u4ef6\u7684\u9002\u5e94\u5462\uff1f \u81ea\u9876\u5411\u4e0b \u4e3b\u7a0b\u5e8f\uff0cMonitor\u7684\u4f7f\u7528\u65b9\u6cd5 int main ( int argc , char * argv []) { WindowsDisplay display ; Monitor monitor ( & display ); while ( running ()) { monitor . GetLoad (); monitor . GetTotalMemory (); monitor . GetUsedMemory (); monitor . GetNetworkLantency (); monitor . show (); sleep ( 1000 ); } } switch case - \u5bf9\u4e8e\u4e0d\u540c\u7684\u6761\u4ef6\u4e0b\u5b9e\u73b0 Monitor::GetLoad \u51fd\u6570 enum MonitorType { Win32 , Win64 , Ganglia }; MonitorType type = Ganglia ; float Monitor :: GetLoad () { switch ( type ) { case Win32 : // Get system load via Win32 APIs return load ; case Win64 : // Get system load via Win64 APIs return load ; case Ganglia : // Get system load via Ganglia interface return load ; } } \u5f0a\u7aef\uff1a\u6bcf\u589e\u52a0\u4e00\u79cd\u65b0\u7684\u7cfb\u7edf\u73af\u5883\uff0c\u9700\u8981\u5bf9 Monitor::GetLoad \u51fd\u6570\u505a\u4fee\u6539\u3002 \u6a21\u677f\u65b9\u6cd5 class Monitor { public : virtual void GetLoad () = 0 ; virtual void GetTotalMemory () = 0 ; virtual void GetUsedMemory () = 0 ; virtual void GetNetworkLatency () = 0 ; Monitor ( Display * display ); virtual ~ Monitor (); void Show (); protected : float load , latency ; long total_memory , used_memory ; Display * m_display ; }; void Monitor :: Show () { m_display -> Show ( load , total_memory , used_memory , latency ); } \u8fd9\u79cd\u5b9e\u73b0\u7684\u95ee\u9898 \u5982\u679c\u51e0\u4e2a\u51fd\u6570\u63a5\u53e3\u7684\u5b9e\u73b0\u76f8\u4e92\u72ec\u7acb\uff0c\u5206\u522b\u6709 N, M, K N, M, K \u79cd\u5b9e\u73b0\u65b9\u6cd5\uff0c\u90a3\u4e48\uff0c\u5b9e\u73b0\u5b50\u7c7b\u7684\u4e2a\u6570\u5c06\u662f N \\times M \\times K N \\times M \\times K \u79cd\u3002 \u4f8b\u5982\u5982\u679c\u5b9e\u73b0 GetLoad() \u7684\u65b9\u5f0f\u6709 4 4 \u79cd\uff0c\u5b9e\u73b0 GetTotalMemory() \u7684\u65b9\u5f0f\u6709 3 3 \u79cd\uff0c\u90a3\u4e48\u5b50\u7c7b\u7684\u6570\u91cf\u53ef\u4ee5\u6709 12 12 \u79cd\u3002\u5f53\u4ee3\u7801\u9700\u8981\u7ef4\u62a4\u7684\u65f6\u5019\u9700\u8981\u5bf9\u91cd\u590d\u7684\u4ee3\u7801\u8fdb\u884c\u4fee\u6539\uff0c\u8d39\u65f6\u8d39\u529b\u3002 \u63a5\u53e3\u5206\u79bb\u4e0e\u5355\u4e00\u8d23\u4efb\u539f\u5219 \u4e24\u79cd\u4e0d\u540c\u5c42\u6b21\u7684\u53d8\u5316 \u5bf9\u4e8e\u4e0a\u8ff0\u5b9e\u73b0\uff0c\u5b58\u5728\u4e24\u79cd\u4e0d\u540c\u5c42\u9762\u7684\u53d8\u5316\uff0c\u5e94\u8be5\u6709\u6240\u533a\u5206 \u5728\u5b9e\u73b0\u5c42\u9762\u4e0a\uff1a\u5bf9\u4e8e\u6bcf\u4e2a\u529f\u80fd\uff0c\u5b58\u5728\u591a\u79cd\u5b9e\u73b0\u65b9\u6cd5 \u76f8\u5bf9\u4e8e\u57fa\u7c7b\u662f\u53ef\u53d8\u7684\uff0c\u6bcf\u79cd\u53d8\u5316\u5bf9\u5e94\u4e00\u4e2a\u5b50\u7c7b \u8fd9\u79cd\u53d8\u5316\u8868\u73b0\u5728\u7f16\u8bd1\u671f\uff0c\u662f\u4e00\u79cd\u76f8\u5bf9\u9759\u6001\u7684\u53ef\u53d8 \u5728\u7ec4\u7ec7\u5c42\u9762\u4e0a\uff1a\u5927\u201c\u7c7b\u201d\u7684\u529f\u80fd\u7531\u4e00\u7cfb\u5217\u5b50\u529f\u80fd\u6784\u6210 \u5b50\u529f\u80fd\u4e4b\u95f4\u662f\u76f8\u4e92\u72ec\u7acb\u7684\uff0c\u5e94\u5f53\u5c06\u8fd9\u4e9b\u5b50\u529f\u80fd\u62c6\u5206\u5230\u4e0d\u540c\u7684\u201c\u5c0f\u201d\u7c7b \u7ec4\u5408\u662f\u81ea\u7531\u7684\u3001\u52a8\u6001\u7684\u3001\u53ef\u53d8\u7684\u3001\u901a\u8fc7\u5b9e\u73b0\u5b50\u529f\u80fd\u7684\u201c\u5c0f\u201d\u7c7b\u5bf9\u8c61\u7684\u7ec4\u5408\u6765\u5b8c\u6210 \u8fd9\u79cd\u53d8\u5316\u8868\u73b0\u5728\u8fd0\u884c\u671f\uff0c\u662f\u4e00\u79cd\u76f8\u5bf9\u52a8\u6001\u7684\u53ef\u53d8 \u9694\u79bb\u4e0d\u540c\u5c42\u9762\u7684\u201c\u53d8\u201d \u9759\u6001\u7684\u53ef\u53d8\u7528 \u7ee7\u627f \u52a8\u6001\u7684\u53ef\u53d8\u7528 \u7ec4\u5408 \u5355\u4e00\u8d23\u4efb \u5355\u4e00\u8d23\u4efb\u539f\u5219 \u7c7b\u529f\u80fd\u5e94\u8be5\u662f \u5185\u805a \u7684\uff0c\u4e00\u4e2a\u7c7b\u53ea\u627f\u62c5\u4e00\u9879\u529f\u80fd \u8868\u73b0\u4e3a\uff1a\u4fee\u6539/\u6d3e\u751f\u4e00\u4e2a\u7c7b\u53ea\u5e94\u8be5\u6709\u4e00\u4e2a\u7406\u7531\uff0c\u53ea\u80fd\u7531\u5355\u4e2a\u53d8\u5316\u56e0\u7d20\u5f15\u8d77 \u5c06\u591a\u4e2a\u4e0d\u540c\u529f\u80fd\u4ea4\u7531\u540c\u4e00\u4e2a\u7c7b\u5b9e\u73b0\uff0c\u8fdd\u53cd\u4e86\u5355\u4e00\u8d23\u4efb\u539f\u5219 \u5f53\u4e00\u4e2a\u529f\u80fd\u9700\u8981\u53d8\u5316\u65f6\uff0c\u4e0d\u5f97\u4e0d\u4fee\u6539\u6216\u8005\u6d3e\u751f\u65b0\u7684\u5b9e\u73b0\u7c7b \u5206\u79bb\u4e24\u79cd\u5c42\u6b21 \u5265\u79bb\u51fa\u65b0\u7684\u63a5\u53e3 \u6bcf\u4e2a\u529f\u80fd\uff08\u7b97\u6cd5\uff09\u7684\u5b9e\u73b0\u5b9a\u4e49\u4e3a\u4e00\u4e2a\u63a5\u53e3\uff08\u79f0\u4e3a \u7b56\u7565 \uff09 \u4e0e\u63a5\u53e3\u4e0d\u540c\u7684\u5b9e\u73b0\u7ec4\u6210\u4e00\u4e2a \u7b56\u7565\u7c7b\u7684\u4f53\u7cfb \u7528\u7ec4\u5408\u66ff\u4ee3\u7ee7\u627f \u7528\u529f\u80fd\uff08\u7b97\u6cd5\uff09\u63a5\u53e3\u4e4b\u95f4\u7684\u7ec4\u5408\u6765\u5b9e\u73b0\u529f\u80fd\uff08\u7b97\u6cd5\uff09\u4e4b\u95f4\u7684\u7ec4\u5408 \u5982\u6b64\u4e00\u6765\uff0c\u5bf9\u4e8e\u5b9e\u73b0\u76f8\u4e92\u72ec\u7acb\u7684\u51fd\u6570\u63a5\u53e3\u5206\u522b\u6709 N, M, K N, M, K \u79cd\u5b9e\u73b0\u65b9\u6cd5\uff0c\u9700\u8981\u5b9e\u73b0\u7684\u7c7b\u7684\u6570\u91cf\u4ece N \\times M \\times K N \\times M \\times K \u53d8\u4e3a N + M + K N + M + K \u4e2a\u201c\u5c0f\u201d\u7c7b\u548c 1 1 \u4e2a\u5927\u7c7b\u3002 \u91cd\u65b0\u770b\u8d1f\u8d23\u76d1\u89c6\u5176\u7684\u8bbe\u8ba1 \u5265\u79bb\u65b0\u7684\u63a5\u53e3 \u7531\u4e09\u4e2a\u201c\u7b56\u7565\u201d\u63a5\u53e3\u5206\u522b\u5b9a\u4e49\u4e0d\u540c\u7684\u529f\u80fd \u6bcf\u4e2a\u7b56\u7565\u63a5\u53e3\u6709\u4e00\u7cfb\u5217\u4e0d\u540c\u7684\u5b9e\u73b0 \u7528\u7ec4\u5408\u66ff\u4ee3\u7ee7\u627f Monitor \u7c7b\u4e2d\u5821\u6751\u4e00\u7ec4\u201c\u7b56\u7565\u201d\u63a5\u53e3\u7c7b\u7684\u5b9e\u4f8b \u8fd9\u4e9b\u5b9e\u4f8b\u53ef\u4ee5\u81ea\u7531\u7ec4\u5408\u548c\u52a8\u6001\u66ff\u6362 \u5b9e\u73b0 LoadStrategy \u201c\u5c0f\u7c7b\u201d class LoadStrategy { public : virtual float GetLoad () = 0 ; }; class LoadStrategyImpl1 : public LoadStrategy { public : float GetLoad () { // Get load here... return load ; } }; class LoadStrategyImpl2 : public LoadStrategy { public : float GetLoad () { // Get load here... return load ; } }; \u5b9e\u73b0 Monitor \u7c7b class Monitor { public : Monitor ( LoadStrategy * load_strategy , MemoryStrategy * memory_strategy , LatencyStrategy * latency_strategy , Display * display ); void GetLoad (); void GetTotalMemory (); void GetUsedMemory (); void GetNetworkLatency (); void Show (); private : LoadStraegy * load_strategy_ ; MemoryStrategy * memory_strategy_ ; LatencyStrategy * latency_strategy_ ; float load , latency ; long total_memory , used_memory ; Display * display_ ; }; Monitor :: Monitor ( LoadStrategy * load_strategy , MemoryStrategy * memory_strategy , LatencyStrategy * latency_strategy , Display * display ) : load_strategy_ ( load_strategy ), memory_strategy_ ( memory_strategy ), latency_strategy_ ( latency_strategy ), display_ ( display ), load ( 0.0 ), latency ( 0.0 ), total_memory ( 0 ), used_memory ( 0 ) {} void Monitor :: Show () { display -> Show ( load , total_memory , used_memory , latency ); } \u4e3b\u51fd\u6570\u5b9e\u73b0 int main ( int argc , char * argv []) { GangliaLoadStrategy load_strategy ; WinMemoryStrategy memory_strategy ; PingLatencyStrategy latency_strategy ; WindowDisplay display ; Monitor monitor ( & load_strategy , & memory_strategy , & latency_strategy , & display ); while ( running ()) { monitor . GetLoad (); monitor . GetTotalMemory (); monitor . GetUsedMemory (); monitor . GetNetworkLatency (); monitor . Show (); sleep ( 1000 ); } } \u8fd9\u6837\u7684\u5b9e\u73b0\u8fd8\u5177\u5907\u8fd0\u884c\u671f\u7684 \u7075\u6d3b\u6027 \uff0c\u53ef\u4ee5\u4f7f\u7528\u65b0\u7684\u7b56\u7565\u7c7b\u66ff\u6362\u539f\u59cb\u7684\u7b56\u7565\u7c7b\u3002 class Monitor { public : // ,,, void SetLoadStrategy ( LoadStrategy * load_strategy ); void SetMemoryStrategy ( MemoryStrategy * memory_strategy ); void SetLatencyStrategy ( LoadStrategy * latency_strategy ); }; int main ( int argc , char * argv []) { //... LoadStrategyImpl2 new_load_strategy ; monitor . SetLoadStrategy ( & new_load_strategy ); monitor . GetLoad (); //... } \u59d4\u6258\u4e0e\u63a5\u53e3\u7684\u8fdb\u4e00\u6b65\u5206\u89e3 \u63a5\u7740\u8d1f\u8f7d\u76d1\u89c6\u5668\u7684\u8bbe\u8ba1\uff0c\u63a5\u4e0b\u6765\u5b9e\u73b0\u7ed3\u679c\u663e\u793a\u90e8\u5206 \u56de\u987e\u4e4b\u524d\u8bbe\u8ba1\u4e2d\u7559\u4e0b\u7684 Monitor::Show() \u63a5\u53e3 class Monitor { public : //... void Show (); protected : float load , latency ; long total_memory , used_memory ; Display * display_ ; }; void Monitor :: Show () { display_ -> Show ( load , total_memory , used_memory , latency ); } \u8fd9\u91cc Monitor::Show \u8c03\u7528\u7684\u662f Display display_ \u8fd9\u4e2a\u6210\u5458\u7684 Show \u65b9\u6cd5\uff0c\u800c Display::Show \u53c8\u6839\u636e\u73af\u5883\u8c03\u7528\u76f8\u5e94\u5b50\u7c7b\u7684 Show \u65b9\u6cd5\u3002 Monitor \u6709\u4e00\u4e2a\u201c\u663e\u793a\u201d\u7684\u4efb\u52a1\uff0c\u4f46\u5b83\u672c\u8eab\u6ca1\u6709\u5b9e\u73b0\u800c\u662f\u4ea4\u7ed9 Display display_ \u8fd9\u4e2a\u6210\u5458\u5b9e\u73b0\u3002\u8fd9\u662f\u4e00\u79cd \u59d4\u6258 \u6a21\u5f0f Delegation, Wrapper, Helper \u4e00\u822c\u90fd\u6307\u7684\u662f \u59d4\u6258 \u6a21\u5f0f \u6df1\u5165 Display \u201c\u663e\u793a\u201d\u5206\u6210\u4e24\u7c7b\uff1aConsole\u548cGUI\uff0cGUI\u66f4\u52a0\u7f8e\u89c2\u3001\u5e38\u7528\u3002 GUI\u6709\u591a\u79cd\u4e0d\u540c\u7684\u5b9e\u73b0\uff08Windows, X-Win, QT, ...\uff09\uff0c\u6765\u5b9e\u73b0\u591a\u4e2a\u4e0d\u540c\u7684 GUIDisplay \u540c\u65f6\uff0c\u6211\u4eec\u53c8\u5e0c\u671b\u663e\u793a\u662f\u591a\u6837\u5316\u7684\uff0c\u5982\u4e0d\u540c\u7684\u989c\u8272\u3001\u5f62\u72b6\uff1b\u67f1\u72b6\u56fe\u3001\u6298\u7ebf\u56fe\u3001\u997c\u56fe \u95ee\u9898 \u5bf9\u4e8e GUIDisplay \u7684\u5404\u4e2a\u5b50\u7c7b\uff0c\u5927\u91cf\u91cd\u590d\u4ee3\u7801\uff08\u4ee3\u7801\u5197\u4f59\uff0c\u7ef4\u62a4\u96be\u5ea6\u52a0\u5927\uff09 \u5206\u6790\uff1a\u53d8\u4e0e\u4e0d\u53d8 \u4e0d\u53d8 \u53d8 \u4efb\u4f55\u7ed8\u56fe\u57fa\u7840\u90fd\u662f\u753b\u70b9\uff0c\u753b\u6cd5\u4e00\u6837 \u4e0d\u540cGUI\uff0c\u5b9e\u73b0\u753b\u70b9\u7684API\u63a5\u53e3\u4e0d\u540c \u628a\u53d8\u4e0e\u4e0d\u53d8\u5206\u79bb\uff0c\u62bd\u8c61\u51fa\u65b0\u7684\u63a5\u53e3 \u5206\u79bb\u65b0\u7684\u63a5\u53e3 \u5c06 GUIDisplay \u4e2d\u7684\u51fd\u6570\u5206\u6210\u4e09\u7c7b \u5176\u4e2d \u7b2c\u4e00\u7c7b\u662f\u5176\u5bf9\u5916\u66b4\u9732\u7684\u63a5\u53e3 \u7b2c\u4e8c\u7c7b\u662f\u9700\u8981\u8c03\u7528\u7279\u5b9a\u5e73\u53f0API\u7684\u51fd\u6570 \u7b2c\u4e09\u7c7b\u51fd\u6570\u57fa\u4e8e\u7b2c\u4e8c\u7c7b\u51fd\u6570\u5b9e\u73b0 \u4e8e\u662f\u53ef\u4ee5\u8bb2\u4e09\u7c7b\u51fd\u6570\u5206\u79bb\u5f00\u6765\uff0c\u5728\u4e0d\u540c\u5c42\u9762\u4f53\u73b0\u5176\u53ef\u53d8\u6027\u3002 \u5206\u79bb\u4e0d\u540c\u5c42\u9762\u7684\u53ef\u53d8\u6027 \u201c\u663e\u793a\u201d\u90e8\u5206\u5305\u542b\u4e24\u4e2a\u5c42\u9762\u7684\u53d8\u5316\uff1a \u8c03\u7528\u4e0d\u540c\u5e73\u53f0API\u5b9e\u73b0\u76f8\u540c\u7684\u57fa\u7840\u529f\u80fd \u7ed3\u679c\u91c7\u7528\u547d\u4ee4\u884c\u663e\u793a\u8fd8\u662fGUI\u663e\u793a Bridge\u6a21\u5f0f - \u628a\u62bd\u8c61\u90e8\u5206\u548c\u5b9e\u73b0\u90e8\u5206\u5206\u79bb\uff0c\u662f\u5b83\u4eec\u53ef\u4ee5\u72ec\u7acb\u53d8\u5316\u3002 \u5b9e\u73b0 class Display { public : virtual void Show ( float load , long total_memory , long used_memory , float latency ) = 0 ; virtual ~ Display () {} }; class ConsoleDisplay : public Display { public : void Show ( float load , long total_memory , long used_memory , float latency ) { cout << \"load = \" << load << endl ; cout << \"total_memory = \" << total_memory << endl ; cout << \"used_memory = \" << used_memory << endl ; cout << \"latency = \" << latency << endl ; } }; \u65b0\u7684\u63a5\u53e3 class GUIDisplay : public Display { public : virtual void Show ( float load , long total_memory , long used_memory , float latency ) = 0 ; GUIDisplay ( GUIDisplayImpl * impl ) : impl_ ( impl ) {} ~ GUIDisplay (); GUIDisplay ( const GUIDisplay & d ); GUIDisplay & operator = ( const GUIDisplay & d ); protected : void DrawLine ( int x1 , int y1 , int x2 , int y2 ); void DrawRect ( int x1 , int y1 , int x2 , int y2 ); //... private : void DrawPoint ( int x , int y ); void DrawText ( int x , int y , string text ); GUIDisplayImpl * impl_ ; }; \u5c06 GUIDisplay \u7c7b\u7684 DrawPoint \u548c DrawText \u59d4\u6258 \u7ed9 GUIDisplayImpl \u7c7b\uff08\u5c06\u57fa\u7840\u7c7b\u4e2d\u4e0e\u73af\u5883\u76f8\u5173\u7684\u529f\u80fd\u4ea4\u7ed9\u548c\u73af\u5883\u76f8\u5173\u7684\u7c7b\u53bb\u5b9e\u73b0\uff09\u3002 GUIDisplayImpl \u7684\u5b9e\u73b0\uff1a class GUIDisplayImpl { public : GUIDisplayImpl () : use ( 1 ) {} // \u6ce8\u610f\u8fd9\u91cc\u5f15\u7528\u8ba1\u6570\u7684\u4f7f\u7528 virtual void DrawPoint ( int x , int y ) = 0 ; virtual void DrawText ( int x , int y , string text ) = 0 ; private : int use ; friend class GUIDisplay ; }; void GUIDisplay :: DrawPoint ( int x , int y ) { impl_ -> DrawPoint ( x , y ); } void GUIDisplay :: DrawText ( int x , int y , string text ) { impl_ -> DrawText ( x , y , text ); } \u6ce8\u610f\u8fd9\u91cc\u5c06 GUIDisplay \u58f0\u660e\u6210 GUIDisplayImpl \u7684\u53cb\u5143\u662f \u5f15\u7528\u8ba1\u6570 \u7684\u9700\u8981\u3002 \u5b9e\u73b0\u65b0\u7684\u63a5\u53e3 WindowsDisplayImpl class WindowsDisplayImpl : public GUIDisplayImpl { public : WindowsDisplayImpl () { /* init it here. */ } ~ WindowsDisplayImpl (); void DrawPoint ( int x , int y ); void DrawText ( int x , int y , string text ); }; void WindowsDisplayImpl :: DrawPoint ( int x , int y ) { SetPixel ( hdc , x , y , forColor ); } void WindowsDisplayImpl :: DrawText ( int x , int y , string text ) { TextOut ( hdc , x , y , text . c_str (), text . size ()); } XWinDisplayImpl class XWinDisplayImpl : public GUIDisplayImpl { public : XWinDisplayImpl () { /* init it here. */ } ~ XWinDisplayImpl () {} void DrawPoint ( int x , int y ); void DrawText ( int x , int y , string text ); }; void XWinDisplayImpl :: DrawPoint ( int x , int y ) { XDrawPoint ( display , win , gc , x , y ); } void XWinDisplayImpl :: DrawText ( int x , int y , string text ) { XDrawString ( display , win , gc , x , y , text , text . size ()); } \u4e0d\u53d8\u7684\u90e8\u5206 \u5bf9\u4e8e\u90a3\u4e9b\u57fa\u4e8e DrawPoint \u548c DrawText \u5b9e\u73b0\u7684\u51fd\u6570\uff0c\u5728 GUIDisplay \u4e2d\u76f4\u63a5\u5b9e\u73b0\u5373\u53ef\u3002 void GUIDisplay :: DrawLine ( int x1 , int y1 , int x2 , int y2 ) { for ( int x = x1 ; x < x2 ; x ++ ) { int y = x1 + ( x - x1 ) * ( y2 - y1 ) / ( x2 - x1 ); DrawPoint ( x , y ); } } void GUIDisplay :: DrawRect ( int x1 , int y1 , int x2 , int y2 ) { DrawLine ( x1 , y1 , x2 , y2 ); DrawLine ( x2 , y1 , x2 , y2 ); DrawLine ( x2 , y2 , x1 , y2 ); DrawLine ( x1 , y2 , x1 , y1 ); } \u53e6\u4e00\u4e2a\u5c42\u9762\u7684\u53ef\u53d8\u90e8\u5206 \u5bf9\u4e8e Show \u51fd\u6570\uff0c\u5176\u591a\u6837\u6027\u4f53\u73b0\u5728\u663e\u793a\u6570\u636e\u7684\u65b9\u5f0f\uff08\u6298\u7ebf\u56fe\u6216\u67f1\u72b6\u56fe\u6216\u4e8c\u8005\u7684\u7ec4\u5408\uff09 \u8fd9\u4e00\u90e8\u5206\u53ef\u4ee5\u7559\u7ed9 GUIDisplay \u5b9a\u4e49\u865a\u51fd\u6570\u7684\u5b9e\u73b0 \u4f7f\u7528\u7ee7\u627f\u5b9e\u73b0 GUIDisplay \u2014\u2014 \u753b\u4e00\u4e2a\u65b9\u6846\u663e\u793aCPU\u8d1f\u8f7d\uff1a class Layout1 : public GUIDisplay { public : Layout1 ( GUIDisplayImpl * impl ) : GUIDisplay ( impl ) {} void Show ( float load , long total_memory , long used_memory , float latency ); }; void Layout1 :: Show ( float load , long tota_memory , long used_memory , float latency ) { DrawRect ( 10 , 10 , 300 , 20 ); DrawText ( 10 , 10 , float2str ( load )); //...... } \u5b9e\u73b0\u4e0d\u540c\u7684 Layout \u2014\u2014 \u753b\u4e00\u4e2a\u65b9\u6846\uff0c\u5176\u4e2d\u753b\u4e00\u4e2a\u6a2a\u5411\u67f1\u72b6\u56fe\uff1a class Layout2 : public GUIDisplay { public : Layout2 ( GUIDisplayImpl * impl ) : GUIDisplay ( impl ) {} void Show ( float load , long total_momery , long used_momery , float latency ); }; void Layout2 :: Show ( float load , long total_memory , long used_memory , float latency ) { DrawRect ( 10 , 10 , 30 , 300 ); int miny = load * 290 / 100 + 10 ; for ( int y = 300 ; y > miny ; y -= 3 ) DrawLine ( 10 , y , 30 , y ); //... } \u603b\u7ed3\uff1a \u4f7f\u7528\u4e0d\u540c\u7684 Layout \u6307\u9488\u53ef\u4ee5\u663e\u793a\u4e0d\u540c\u7684\u6c47\u62a5\u98ce\u683c\uff1b \u5f53\u9700\u8981\u6539\u53d8\u73af\u5883\u7684\u65f6\u5019\uff0c\u53ea\u9700\u6539\u53d8 GUIDisplayImpl \u2014\u2014 Bridge\u6a21\u5f0f \uff0c\u5373\u53ef\u9002\u5e94\u4e0d\u7528\u7684\u7cfb\u7edf\u73af\u5883\u3002","title":"\u7b97\u6cd5\u62c6\u5206 - \u5206\u79bb\u6b65\u9aa4"},{"location":"design_pattern/split_steps/#-","text":"\u9762\u5411\u5bf9\u8c61\u7684\u63a5\u53e3\u8bbe\u8ba1\u8981\u65f6\u523b\u9075\u5faa\u529f\u80fd\u7684 \u5355\u4e00\u6027 \u539f\u5219\u3002","title":"\u7b97\u6cd5\u6a2a\u5411\u62c6\u5206 - \u5206\u79bb\u6b65\u9aa4"},{"location":"design_pattern/split_steps/#_1","text":"","title":"\u8bbe\u8ba1\u4e00\u4e2a\u8d1f\u8f7d\u76d1\u89c6\u5668"},{"location":"design_pattern/split_steps/#_2","text":"\u76d1\u89c6\u8ba1\u7b97\u8282\u70b9\u7684\u6577\u5728\u72b6\u6001\uff08\u5982CPU\u5360\u7528\u7387\u3001\u5b58\u50a8\u5668\u5360\u7528\u7387\u3001\u5230\u67d0\u4e2a\u7279\u5b9a\u8282\u70b9\u7684\u7f51\u7edc\u5ef6\u8fdf\uff09\u3002 \u4ee5CPU\u5360\u7528\u7387\u7684\u76d1\u89c6\u4e3a\u4f8b\uff0c\u4e0d\u540c\u6761\u4ef6\u4e0b\uff08\u4f8b\u5982\u4e0d\u540c\u79cd\u7c7b\u4e0d\u540c\u7248\u672c\u7684OS\uff09\u83b7\u5f97CPU\u5360\u7528\u7387\u7684\u65b9\u6cd5\u4e0d\u540c\u3002 \u600e\u6837\u5728\u4e00\u4e2a\u7a0b\u5e8f\u4e2d\u5b9e\u73b0\u5bf9\u8fd9\u4e9b\u4e0d\u540c\u6761\u4ef6\u7684\u9002\u5e94\u5462\uff1f","title":"\u8d1f\u8f7d\u76d1\u89c6\u5668"},{"location":"design_pattern/split_steps/#_3","text":"\u4e3b\u7a0b\u5e8f\uff0cMonitor\u7684\u4f7f\u7528\u65b9\u6cd5 int main ( int argc , char * argv []) { WindowsDisplay display ; Monitor monitor ( & display ); while ( running ()) { monitor . GetLoad (); monitor . GetTotalMemory (); monitor . GetUsedMemory (); monitor . GetNetworkLantency (); monitor . show (); sleep ( 1000 ); } } switch case - \u5bf9\u4e8e\u4e0d\u540c\u7684\u6761\u4ef6\u4e0b\u5b9e\u73b0 Monitor::GetLoad \u51fd\u6570 enum MonitorType { Win32 , Win64 , Ganglia }; MonitorType type = Ganglia ; float Monitor :: GetLoad () { switch ( type ) { case Win32 : // Get system load via Win32 APIs return load ; case Win64 : // Get system load via Win64 APIs return load ; case Ganglia : // Get system load via Ganglia interface return load ; } } \u5f0a\u7aef\uff1a\u6bcf\u589e\u52a0\u4e00\u79cd\u65b0\u7684\u7cfb\u7edf\u73af\u5883\uff0c\u9700\u8981\u5bf9 Monitor::GetLoad \u51fd\u6570\u505a\u4fee\u6539\u3002 \u6a21\u677f\u65b9\u6cd5 class Monitor { public : virtual void GetLoad () = 0 ; virtual void GetTotalMemory () = 0 ; virtual void GetUsedMemory () = 0 ; virtual void GetNetworkLatency () = 0 ; Monitor ( Display * display ); virtual ~ Monitor (); void Show (); protected : float load , latency ; long total_memory , used_memory ; Display * m_display ; }; void Monitor :: Show () { m_display -> Show ( load , total_memory , used_memory , latency ); }","title":"\u81ea\u9876\u5411\u4e0b"},{"location":"design_pattern/split_steps/#_4","text":"\u5982\u679c\u51e0\u4e2a\u51fd\u6570\u63a5\u53e3\u7684\u5b9e\u73b0\u76f8\u4e92\u72ec\u7acb\uff0c\u5206\u522b\u6709 N, M, K N, M, K \u79cd\u5b9e\u73b0\u65b9\u6cd5\uff0c\u90a3\u4e48\uff0c\u5b9e\u73b0\u5b50\u7c7b\u7684\u4e2a\u6570\u5c06\u662f N \\times M \\times K N \\times M \\times K \u79cd\u3002 \u4f8b\u5982\u5982\u679c\u5b9e\u73b0 GetLoad() \u7684\u65b9\u5f0f\u6709 4 4 \u79cd\uff0c\u5b9e\u73b0 GetTotalMemory() \u7684\u65b9\u5f0f\u6709 3 3 \u79cd\uff0c\u90a3\u4e48\u5b50\u7c7b\u7684\u6570\u91cf\u53ef\u4ee5\u6709 12 12 \u79cd\u3002\u5f53\u4ee3\u7801\u9700\u8981\u7ef4\u62a4\u7684\u65f6\u5019\u9700\u8981\u5bf9\u91cd\u590d\u7684\u4ee3\u7801\u8fdb\u884c\u4fee\u6539\uff0c\u8d39\u65f6\u8d39\u529b\u3002","title":"\u8fd9\u79cd\u5b9e\u73b0\u7684\u95ee\u9898"},{"location":"design_pattern/split_steps/#_5","text":"","title":"\u63a5\u53e3\u5206\u79bb\u4e0e\u5355\u4e00\u8d23\u4efb\u539f\u5219"},{"location":"design_pattern/split_steps/#_6","text":"\u5bf9\u4e8e\u4e0a\u8ff0\u5b9e\u73b0\uff0c\u5b58\u5728\u4e24\u79cd\u4e0d\u540c\u5c42\u9762\u7684\u53d8\u5316\uff0c\u5e94\u8be5\u6709\u6240\u533a\u5206 \u5728\u5b9e\u73b0\u5c42\u9762\u4e0a\uff1a\u5bf9\u4e8e\u6bcf\u4e2a\u529f\u80fd\uff0c\u5b58\u5728\u591a\u79cd\u5b9e\u73b0\u65b9\u6cd5 \u76f8\u5bf9\u4e8e\u57fa\u7c7b\u662f\u53ef\u53d8\u7684\uff0c\u6bcf\u79cd\u53d8\u5316\u5bf9\u5e94\u4e00\u4e2a\u5b50\u7c7b \u8fd9\u79cd\u53d8\u5316\u8868\u73b0\u5728\u7f16\u8bd1\u671f\uff0c\u662f\u4e00\u79cd\u76f8\u5bf9\u9759\u6001\u7684\u53ef\u53d8 \u5728\u7ec4\u7ec7\u5c42\u9762\u4e0a\uff1a\u5927\u201c\u7c7b\u201d\u7684\u529f\u80fd\u7531\u4e00\u7cfb\u5217\u5b50\u529f\u80fd\u6784\u6210 \u5b50\u529f\u80fd\u4e4b\u95f4\u662f\u76f8\u4e92\u72ec\u7acb\u7684\uff0c\u5e94\u5f53\u5c06\u8fd9\u4e9b\u5b50\u529f\u80fd\u62c6\u5206\u5230\u4e0d\u540c\u7684\u201c\u5c0f\u201d\u7c7b \u7ec4\u5408\u662f\u81ea\u7531\u7684\u3001\u52a8\u6001\u7684\u3001\u53ef\u53d8\u7684\u3001\u901a\u8fc7\u5b9e\u73b0\u5b50\u529f\u80fd\u7684\u201c\u5c0f\u201d\u7c7b\u5bf9\u8c61\u7684\u7ec4\u5408\u6765\u5b8c\u6210 \u8fd9\u79cd\u53d8\u5316\u8868\u73b0\u5728\u8fd0\u884c\u671f\uff0c\u662f\u4e00\u79cd\u76f8\u5bf9\u52a8\u6001\u7684\u53ef\u53d8 \u9694\u79bb\u4e0d\u540c\u5c42\u9762\u7684\u201c\u53d8\u201d \u9759\u6001\u7684\u53ef\u53d8\u7528 \u7ee7\u627f \u52a8\u6001\u7684\u53ef\u53d8\u7528 \u7ec4\u5408","title":"\u4e24\u79cd\u4e0d\u540c\u5c42\u6b21\u7684\u53d8\u5316"},{"location":"design_pattern/split_steps/#_7","text":"\u5355\u4e00\u8d23\u4efb\u539f\u5219 \u7c7b\u529f\u80fd\u5e94\u8be5\u662f \u5185\u805a \u7684\uff0c\u4e00\u4e2a\u7c7b\u53ea\u627f\u62c5\u4e00\u9879\u529f\u80fd \u8868\u73b0\u4e3a\uff1a\u4fee\u6539/\u6d3e\u751f\u4e00\u4e2a\u7c7b\u53ea\u5e94\u8be5\u6709\u4e00\u4e2a\u7406\u7531\uff0c\u53ea\u80fd\u7531\u5355\u4e2a\u53d8\u5316\u56e0\u7d20\u5f15\u8d77 \u5c06\u591a\u4e2a\u4e0d\u540c\u529f\u80fd\u4ea4\u7531\u540c\u4e00\u4e2a\u7c7b\u5b9e\u73b0\uff0c\u8fdd\u53cd\u4e86\u5355\u4e00\u8d23\u4efb\u539f\u5219 \u5f53\u4e00\u4e2a\u529f\u80fd\u9700\u8981\u53d8\u5316\u65f6\uff0c\u4e0d\u5f97\u4e0d\u4fee\u6539\u6216\u8005\u6d3e\u751f\u65b0\u7684\u5b9e\u73b0\u7c7b","title":"\u5355\u4e00\u8d23\u4efb"},{"location":"design_pattern/split_steps/#_8","text":"\u5265\u79bb\u51fa\u65b0\u7684\u63a5\u53e3 \u6bcf\u4e2a\u529f\u80fd\uff08\u7b97\u6cd5\uff09\u7684\u5b9e\u73b0\u5b9a\u4e49\u4e3a\u4e00\u4e2a\u63a5\u53e3\uff08\u79f0\u4e3a \u7b56\u7565 \uff09 \u4e0e\u63a5\u53e3\u4e0d\u540c\u7684\u5b9e\u73b0\u7ec4\u6210\u4e00\u4e2a \u7b56\u7565\u7c7b\u7684\u4f53\u7cfb \u7528\u7ec4\u5408\u66ff\u4ee3\u7ee7\u627f \u7528\u529f\u80fd\uff08\u7b97\u6cd5\uff09\u63a5\u53e3\u4e4b\u95f4\u7684\u7ec4\u5408\u6765\u5b9e\u73b0\u529f\u80fd\uff08\u7b97\u6cd5\uff09\u4e4b\u95f4\u7684\u7ec4\u5408 \u5982\u6b64\u4e00\u6765\uff0c\u5bf9\u4e8e\u5b9e\u73b0\u76f8\u4e92\u72ec\u7acb\u7684\u51fd\u6570\u63a5\u53e3\u5206\u522b\u6709 N, M, K N, M, K \u79cd\u5b9e\u73b0\u65b9\u6cd5\uff0c\u9700\u8981\u5b9e\u73b0\u7684\u7c7b\u7684\u6570\u91cf\u4ece N \\times M \\times K N \\times M \\times K \u53d8\u4e3a N + M + K N + M + K \u4e2a\u201c\u5c0f\u201d\u7c7b\u548c 1 1 \u4e2a\u5927\u7c7b\u3002","title":"\u5206\u79bb\u4e24\u79cd\u5c42\u6b21"},{"location":"design_pattern/split_steps/#_9","text":"\u5265\u79bb\u65b0\u7684\u63a5\u53e3 \u7531\u4e09\u4e2a\u201c\u7b56\u7565\u201d\u63a5\u53e3\u5206\u522b\u5b9a\u4e49\u4e0d\u540c\u7684\u529f\u80fd \u6bcf\u4e2a\u7b56\u7565\u63a5\u53e3\u6709\u4e00\u7cfb\u5217\u4e0d\u540c\u7684\u5b9e\u73b0 \u7528\u7ec4\u5408\u66ff\u4ee3\u7ee7\u627f Monitor \u7c7b\u4e2d\u5821\u6751\u4e00\u7ec4\u201c\u7b56\u7565\u201d\u63a5\u53e3\u7c7b\u7684\u5b9e\u4f8b \u8fd9\u4e9b\u5b9e\u4f8b\u53ef\u4ee5\u81ea\u7531\u7ec4\u5408\u548c\u52a8\u6001\u66ff\u6362 \u5b9e\u73b0 LoadStrategy \u201c\u5c0f\u7c7b\u201d class LoadStrategy { public : virtual float GetLoad () = 0 ; }; class LoadStrategyImpl1 : public LoadStrategy { public : float GetLoad () { // Get load here... return load ; } }; class LoadStrategyImpl2 : public LoadStrategy { public : float GetLoad () { // Get load here... return load ; } }; \u5b9e\u73b0 Monitor \u7c7b class Monitor { public : Monitor ( LoadStrategy * load_strategy , MemoryStrategy * memory_strategy , LatencyStrategy * latency_strategy , Display * display ); void GetLoad (); void GetTotalMemory (); void GetUsedMemory (); void GetNetworkLatency (); void Show (); private : LoadStraegy * load_strategy_ ; MemoryStrategy * memory_strategy_ ; LatencyStrategy * latency_strategy_ ; float load , latency ; long total_memory , used_memory ; Display * display_ ; }; Monitor :: Monitor ( LoadStrategy * load_strategy , MemoryStrategy * memory_strategy , LatencyStrategy * latency_strategy , Display * display ) : load_strategy_ ( load_strategy ), memory_strategy_ ( memory_strategy ), latency_strategy_ ( latency_strategy ), display_ ( display ), load ( 0.0 ), latency ( 0.0 ), total_memory ( 0 ), used_memory ( 0 ) {} void Monitor :: Show () { display -> Show ( load , total_memory , used_memory , latency ); } \u4e3b\u51fd\u6570\u5b9e\u73b0 int main ( int argc , char * argv []) { GangliaLoadStrategy load_strategy ; WinMemoryStrategy memory_strategy ; PingLatencyStrategy latency_strategy ; WindowDisplay display ; Monitor monitor ( & load_strategy , & memory_strategy , & latency_strategy , & display ); while ( running ()) { monitor . GetLoad (); monitor . GetTotalMemory (); monitor . GetUsedMemory (); monitor . GetNetworkLatency (); monitor . Show (); sleep ( 1000 ); } } \u8fd9\u6837\u7684\u5b9e\u73b0\u8fd8\u5177\u5907\u8fd0\u884c\u671f\u7684 \u7075\u6d3b\u6027 \uff0c\u53ef\u4ee5\u4f7f\u7528\u65b0\u7684\u7b56\u7565\u7c7b\u66ff\u6362\u539f\u59cb\u7684\u7b56\u7565\u7c7b\u3002 class Monitor { public : // ,,, void SetLoadStrategy ( LoadStrategy * load_strategy ); void SetMemoryStrategy ( MemoryStrategy * memory_strategy ); void SetLatencyStrategy ( LoadStrategy * latency_strategy ); }; int main ( int argc , char * argv []) { //... LoadStrategyImpl2 new_load_strategy ; monitor . SetLoadStrategy ( & new_load_strategy ); monitor . GetLoad (); //... }","title":"\u91cd\u65b0\u770b\u8d1f\u8d23\u76d1\u89c6\u5176\u7684\u8bbe\u8ba1"},{"location":"design_pattern/split_steps/#_10","text":"\u63a5\u7740\u8d1f\u8f7d\u76d1\u89c6\u5668\u7684\u8bbe\u8ba1\uff0c\u63a5\u4e0b\u6765\u5b9e\u73b0\u7ed3\u679c\u663e\u793a\u90e8\u5206 \u56de\u987e\u4e4b\u524d\u8bbe\u8ba1\u4e2d\u7559\u4e0b\u7684 Monitor::Show() \u63a5\u53e3 class Monitor { public : //... void Show (); protected : float load , latency ; long total_memory , used_memory ; Display * display_ ; }; void Monitor :: Show () { display_ -> Show ( load , total_memory , used_memory , latency ); } \u8fd9\u91cc Monitor::Show \u8c03\u7528\u7684\u662f Display display_ \u8fd9\u4e2a\u6210\u5458\u7684 Show \u65b9\u6cd5\uff0c\u800c Display::Show \u53c8\u6839\u636e\u73af\u5883\u8c03\u7528\u76f8\u5e94\u5b50\u7c7b\u7684 Show \u65b9\u6cd5\u3002 Monitor \u6709\u4e00\u4e2a\u201c\u663e\u793a\u201d\u7684\u4efb\u52a1\uff0c\u4f46\u5b83\u672c\u8eab\u6ca1\u6709\u5b9e\u73b0\u800c\u662f\u4ea4\u7ed9 Display display_ \u8fd9\u4e2a\u6210\u5458\u5b9e\u73b0\u3002\u8fd9\u662f\u4e00\u79cd \u59d4\u6258 \u6a21\u5f0f Delegation, Wrapper, Helper \u4e00\u822c\u90fd\u6307\u7684\u662f \u59d4\u6258 \u6a21\u5f0f","title":"\u59d4\u6258\u4e0e\u63a5\u53e3\u7684\u8fdb\u4e00\u6b65\u5206\u89e3"},{"location":"design_pattern/split_steps/#display","text":"\u201c\u663e\u793a\u201d\u5206\u6210\u4e24\u7c7b\uff1aConsole\u548cGUI\uff0cGUI\u66f4\u52a0\u7f8e\u89c2\u3001\u5e38\u7528\u3002 GUI\u6709\u591a\u79cd\u4e0d\u540c\u7684\u5b9e\u73b0\uff08Windows, X-Win, QT, ...\uff09\uff0c\u6765\u5b9e\u73b0\u591a\u4e2a\u4e0d\u540c\u7684 GUIDisplay \u540c\u65f6\uff0c\u6211\u4eec\u53c8\u5e0c\u671b\u663e\u793a\u662f\u591a\u6837\u5316\u7684\uff0c\u5982\u4e0d\u540c\u7684\u989c\u8272\u3001\u5f62\u72b6\uff1b\u67f1\u72b6\u56fe\u3001\u6298\u7ebf\u56fe\u3001\u997c\u56fe","title":"\u6df1\u5165Display"},{"location":"design_pattern/split_steps/#_11","text":"\u5bf9\u4e8e GUIDisplay \u7684\u5404\u4e2a\u5b50\u7c7b\uff0c\u5927\u91cf\u91cd\u590d\u4ee3\u7801\uff08\u4ee3\u7801\u5197\u4f59\uff0c\u7ef4\u62a4\u96be\u5ea6\u52a0\u5927\uff09 \u5206\u6790\uff1a\u53d8\u4e0e\u4e0d\u53d8 \u4e0d\u53d8 \u53d8 \u4efb\u4f55\u7ed8\u56fe\u57fa\u7840\u90fd\u662f\u753b\u70b9\uff0c\u753b\u6cd5\u4e00\u6837 \u4e0d\u540cGUI\uff0c\u5b9e\u73b0\u753b\u70b9\u7684API\u63a5\u53e3\u4e0d\u540c \u628a\u53d8\u4e0e\u4e0d\u53d8\u5206\u79bb\uff0c\u62bd\u8c61\u51fa\u65b0\u7684\u63a5\u53e3","title":"\u95ee\u9898"},{"location":"design_pattern/split_steps/#_12","text":"\u5c06 GUIDisplay \u4e2d\u7684\u51fd\u6570\u5206\u6210\u4e09\u7c7b \u5176\u4e2d \u7b2c\u4e00\u7c7b\u662f\u5176\u5bf9\u5916\u66b4\u9732\u7684\u63a5\u53e3 \u7b2c\u4e8c\u7c7b\u662f\u9700\u8981\u8c03\u7528\u7279\u5b9a\u5e73\u53f0API\u7684\u51fd\u6570 \u7b2c\u4e09\u7c7b\u51fd\u6570\u57fa\u4e8e\u7b2c\u4e8c\u7c7b\u51fd\u6570\u5b9e\u73b0 \u4e8e\u662f\u53ef\u4ee5\u8bb2\u4e09\u7c7b\u51fd\u6570\u5206\u79bb\u5f00\u6765\uff0c\u5728\u4e0d\u540c\u5c42\u9762\u4f53\u73b0\u5176\u53ef\u53d8\u6027\u3002","title":"\u5206\u79bb\u65b0\u7684\u63a5\u53e3"},{"location":"design_pattern/split_steps/#_13","text":"\u201c\u663e\u793a\u201d\u90e8\u5206\u5305\u542b\u4e24\u4e2a\u5c42\u9762\u7684\u53d8\u5316\uff1a \u8c03\u7528\u4e0d\u540c\u5e73\u53f0API\u5b9e\u73b0\u76f8\u540c\u7684\u57fa\u7840\u529f\u80fd \u7ed3\u679c\u91c7\u7528\u547d\u4ee4\u884c\u663e\u793a\u8fd8\u662fGUI\u663e\u793a Bridge\u6a21\u5f0f - \u628a\u62bd\u8c61\u90e8\u5206\u548c\u5b9e\u73b0\u90e8\u5206\u5206\u79bb\uff0c\u662f\u5b83\u4eec\u53ef\u4ee5\u72ec\u7acb\u53d8\u5316\u3002 \u5b9e\u73b0 class Display { public : virtual void Show ( float load , long total_memory , long used_memory , float latency ) = 0 ; virtual ~ Display () {} }; class ConsoleDisplay : public Display { public : void Show ( float load , long total_memory , long used_memory , float latency ) { cout << \"load = \" << load << endl ; cout << \"total_memory = \" << total_memory << endl ; cout << \"used_memory = \" << used_memory << endl ; cout << \"latency = \" << latency << endl ; } }; \u65b0\u7684\u63a5\u53e3 class GUIDisplay : public Display { public : virtual void Show ( float load , long total_memory , long used_memory , float latency ) = 0 ; GUIDisplay ( GUIDisplayImpl * impl ) : impl_ ( impl ) {} ~ GUIDisplay (); GUIDisplay ( const GUIDisplay & d ); GUIDisplay & operator = ( const GUIDisplay & d ); protected : void DrawLine ( int x1 , int y1 , int x2 , int y2 ); void DrawRect ( int x1 , int y1 , int x2 , int y2 ); //... private : void DrawPoint ( int x , int y ); void DrawText ( int x , int y , string text ); GUIDisplayImpl * impl_ ; }; \u5c06 GUIDisplay \u7c7b\u7684 DrawPoint \u548c DrawText \u59d4\u6258 \u7ed9 GUIDisplayImpl \u7c7b\uff08\u5c06\u57fa\u7840\u7c7b\u4e2d\u4e0e\u73af\u5883\u76f8\u5173\u7684\u529f\u80fd\u4ea4\u7ed9\u548c\u73af\u5883\u76f8\u5173\u7684\u7c7b\u53bb\u5b9e\u73b0\uff09\u3002 GUIDisplayImpl \u7684\u5b9e\u73b0\uff1a class GUIDisplayImpl { public : GUIDisplayImpl () : use ( 1 ) {} // \u6ce8\u610f\u8fd9\u91cc\u5f15\u7528\u8ba1\u6570\u7684\u4f7f\u7528 virtual void DrawPoint ( int x , int y ) = 0 ; virtual void DrawText ( int x , int y , string text ) = 0 ; private : int use ; friend class GUIDisplay ; }; void GUIDisplay :: DrawPoint ( int x , int y ) { impl_ -> DrawPoint ( x , y ); } void GUIDisplay :: DrawText ( int x , int y , string text ) { impl_ -> DrawText ( x , y , text ); } \u6ce8\u610f\u8fd9\u91cc\u5c06 GUIDisplay \u58f0\u660e\u6210 GUIDisplayImpl \u7684\u53cb\u5143\u662f \u5f15\u7528\u8ba1\u6570 \u7684\u9700\u8981\u3002 \u5b9e\u73b0\u65b0\u7684\u63a5\u53e3 WindowsDisplayImpl class WindowsDisplayImpl : public GUIDisplayImpl { public : WindowsDisplayImpl () { /* init it here. */ } ~ WindowsDisplayImpl (); void DrawPoint ( int x , int y ); void DrawText ( int x , int y , string text ); }; void WindowsDisplayImpl :: DrawPoint ( int x , int y ) { SetPixel ( hdc , x , y , forColor ); } void WindowsDisplayImpl :: DrawText ( int x , int y , string text ) { TextOut ( hdc , x , y , text . c_str (), text . size ()); } XWinDisplayImpl class XWinDisplayImpl : public GUIDisplayImpl { public : XWinDisplayImpl () { /* init it here. */ } ~ XWinDisplayImpl () {} void DrawPoint ( int x , int y ); void DrawText ( int x , int y , string text ); }; void XWinDisplayImpl :: DrawPoint ( int x , int y ) { XDrawPoint ( display , win , gc , x , y ); } void XWinDisplayImpl :: DrawText ( int x , int y , string text ) { XDrawString ( display , win , gc , x , y , text , text . size ()); }","title":"\u5206\u79bb\u4e0d\u540c\u5c42\u9762\u7684\u53ef\u53d8\u6027"},{"location":"design_pattern/split_steps/#_14","text":"\u5bf9\u4e8e\u90a3\u4e9b\u57fa\u4e8e DrawPoint \u548c DrawText \u5b9e\u73b0\u7684\u51fd\u6570\uff0c\u5728 GUIDisplay \u4e2d\u76f4\u63a5\u5b9e\u73b0\u5373\u53ef\u3002 void GUIDisplay :: DrawLine ( int x1 , int y1 , int x2 , int y2 ) { for ( int x = x1 ; x < x2 ; x ++ ) { int y = x1 + ( x - x1 ) * ( y2 - y1 ) / ( x2 - x1 ); DrawPoint ( x , y ); } } void GUIDisplay :: DrawRect ( int x1 , int y1 , int x2 , int y2 ) { DrawLine ( x1 , y1 , x2 , y2 ); DrawLine ( x2 , y1 , x2 , y2 ); DrawLine ( x2 , y2 , x1 , y2 ); DrawLine ( x1 , y2 , x1 , y1 ); }","title":"\u4e0d\u53d8\u7684\u90e8\u5206"},{"location":"design_pattern/split_steps/#_15","text":"\u5bf9\u4e8e Show \u51fd\u6570\uff0c\u5176\u591a\u6837\u6027\u4f53\u73b0\u5728\u663e\u793a\u6570\u636e\u7684\u65b9\u5f0f\uff08\u6298\u7ebf\u56fe\u6216\u67f1\u72b6\u56fe\u6216\u4e8c\u8005\u7684\u7ec4\u5408\uff09 \u8fd9\u4e00\u90e8\u5206\u53ef\u4ee5\u7559\u7ed9 GUIDisplay \u5b9a\u4e49\u865a\u51fd\u6570\u7684\u5b9e\u73b0 \u4f7f\u7528\u7ee7\u627f\u5b9e\u73b0 GUIDisplay \u2014\u2014 \u753b\u4e00\u4e2a\u65b9\u6846\u663e\u793aCPU\u8d1f\u8f7d\uff1a class Layout1 : public GUIDisplay { public : Layout1 ( GUIDisplayImpl * impl ) : GUIDisplay ( impl ) {} void Show ( float load , long total_memory , long used_memory , float latency ); }; void Layout1 :: Show ( float load , long tota_memory , long used_memory , float latency ) { DrawRect ( 10 , 10 , 300 , 20 ); DrawText ( 10 , 10 , float2str ( load )); //...... } \u5b9e\u73b0\u4e0d\u540c\u7684 Layout \u2014\u2014 \u753b\u4e00\u4e2a\u65b9\u6846\uff0c\u5176\u4e2d\u753b\u4e00\u4e2a\u6a2a\u5411\u67f1\u72b6\u56fe\uff1a class Layout2 : public GUIDisplay { public : Layout2 ( GUIDisplayImpl * impl ) : GUIDisplay ( impl ) {} void Show ( float load , long total_momery , long used_momery , float latency ); }; void Layout2 :: Show ( float load , long total_memory , long used_memory , float latency ) { DrawRect ( 10 , 10 , 30 , 300 ); int miny = load * 290 / 100 + 10 ; for ( int y = 300 ; y > miny ; y -= 3 ) DrawLine ( 10 , y , 30 , y ); //... } \u603b\u7ed3\uff1a \u4f7f\u7528\u4e0d\u540c\u7684 Layout \u6307\u9488\u53ef\u4ee5\u663e\u793a\u4e0d\u540c\u7684\u6c47\u62a5\u98ce\u683c\uff1b \u5f53\u9700\u8981\u6539\u53d8\u73af\u5883\u7684\u65f6\u5019\uff0c\u53ea\u9700\u6539\u53d8 GUIDisplayImpl \u2014\u2014 Bridge\u6a21\u5f0f \uff0c\u5373\u53ef\u9002\u5e94\u4e0d\u7528\u7684\u7cfb\u7edf\u73af\u5883\u3002","title":"\u53e6\u4e00\u4e2a\u5c42\u9762\u7684\u53ef\u53d8\u90e8\u5206"},{"location":"economics/macro_economics/","text":"\u5b8f\u89c2\u7ecf\u6d4e\u5b66","title":"\u5b8f\u89c2\u7ecf\u6d4e\u5b66"},{"location":"economics/macro_economics/#_1","text":"","title":"\u5b8f\u89c2\u7ecf\u6d4e\u5b66"},{"location":"economics/micro_economics/","text":"\u5fae\u89c2\u7ecf\u6d4e\u5b66 \u7ecf\u6d4e\u5b66\u5341\u5927\u539f\u7406 \u4eba\u4eec\u5982\u4f55\u505a\u51fa\u51b3\u7b56 \u4eba\u4eec\u9762\u4e34\u6743\u8861\u53d6\u820d\u3002 \u67d0\u79cd\u4e1c\u897f\u7684\u6210\u672c\u662f\u4e3a\u4e86\u5f97\u5230\u4ed6\u6240\u653e\u5f03\u7684\u4e1c\u897f \u7406\u6027\u4eba\u8003\u8651\u8fb9\u9645\u91cf \u4eba\u4eec\u4f1a\u5bf9\u6fc0\u52b1\u505a\u51fa\u53cd\u5e94 \u4eba\u4eec\u5982\u4f55\u76f8\u4e92\u5f71\u54cd \u8d38\u6613\u53ef\u4ee5\u4f7f\u6bcf\u4e2a\u4eba\u7684\u72b6\u51b5\u90fd\u53d8\u5f97\u66f4\u597d \u5e02\u573a\u901a\u5e38\u662f\u7ec4\u7ec7\u7ecf\u6d4e\u4e92\u52a8\u7684\u4e00\u79cd\u597d\u65b9\u6cd5 \u653f\u5e9c\u6709\u65f6\u53ef\u4ee5\u6539\u5584\u5e02\u573a\u7ed3\u679c \u6574\u4f53\u7ecf\u6d4e\u5982\u4f55\u8fd0\u884c \u4e00\u56fd\u7684\u751f\u6d3b\u6c34\u5e73\u53d6\u51b3\u4e8e\u5b83\u751f\u4ea7\u7269\u54c1\u548c\u670d\u52a1\u7684\u80fd\u529b \u5f53\u653f\u5e9c\u53d1\u578b\u4e86\u8fc7\u591a\u8d27\u5e01\u65f6\uff0c\u7269\u4ef7\u4e0a\u5347 \u793e\u4f1a\u9762\u4e34\u901a\u8d27\u81a8\u80c0\u548c\u5931\u4e1a\u4e4b\u95f4\u7684\u77ed\u671f\u6743\u8861\u53d6\u820d \u7ecf\u6d4e\u5b66\u5bb6\u7684\u601d\u8003\u65b9\u5f0f \u4f5c\u4e3a\u79d1\u5b66\u5bb6 \u7ecf\u6d4e\u5b66\u5bb6\u4f7f\u7528\u201c\u89c2\u5bdf\u3001\u7406\u8bba\u548c\u8fdb\u4e00\u6b65\u89c2\u5bdf\u201d\u7684\u65b9\u6cd5\u7814\u7a76\u95ee\u9898 \u7ecf\u6d4e\u5b66\u4f7f\u7528\u7b80\u5316\u6a21\u578b\u6765\u63cf\u8ff0\u95ee\u9898\uff0c\u4e3e\u4f8b\u6765\u8bf4 \u7b2c\u4e00\u4e2a\u6a21\u578b\uff1a\u5faa\u73af\u6d41\u91cf\u56fe \u7b2c\u4e8c\u4e2a\u6a21\u578b\uff1a\u751f\u4ea7\u53ef\u80fd\u6027\u8fb9\u754c \u4f5c\u4e3a\u653f\u7b56\u987e\u95ee \u5b9e\u8bc1\u5206\u6790 \u63cf\u8ff0\u4e16\u754c\u662f\u4ec0\u4e48\u6837\u5b50 \u89c4\u8303\u5206\u6790 \u63cf\u8ff0\u4e16\u754c\u5e94\u8be5\u662f\u4ec0\u4e48\u6837\u5b50 \u4f5c\u4e3a\u987e\u95ee\u7684\u7ecf\u6d4e\u5b66\u5bb6\u7ecf\u5e38\u4f1a\u7ed9\u51fa\u622a\u7136\u4e0d\u540c\u7684\u653f\u7b56\u5efa\u8bae\uff0c\u800c\u653f\u7b56\u5236\u5b9a\u8005\u4e5f\u7ecf\u5e38\u4e0d\u4e88\u91c7\u7eb3\u3002 \u79d1\u5b66\u5224\u65ad\u548c\u4e2a\u4eba\u4ef7\u503c\u89c2\u90fd\u4f1a\u5f71\u54cd\u7ecf\u6d4e\u5b66\u5bb6\u7ed9\u51fa\u7684\u89c2\u70b9\u548c\u610f\u89c1\u3002 \u76f8\u4e92\u4f9d\u5b58\u6027\u548c\u8d38\u6613\u7684\u597d\u5904","title":"\u5fae\u89c2\u7ecf\u6d4e\u5b66"},{"location":"economics/micro_economics/#_1","text":"","title":"\u5fae\u89c2\u7ecf\u6d4e\u5b66"},{"location":"economics/micro_economics/#_2","text":"","title":"\u7ecf\u6d4e\u5b66\u5341\u5927\u539f\u7406"},{"location":"economics/micro_economics/#_3","text":"\u4eba\u4eec\u9762\u4e34\u6743\u8861\u53d6\u820d\u3002 \u67d0\u79cd\u4e1c\u897f\u7684\u6210\u672c\u662f\u4e3a\u4e86\u5f97\u5230\u4ed6\u6240\u653e\u5f03\u7684\u4e1c\u897f \u7406\u6027\u4eba\u8003\u8651\u8fb9\u9645\u91cf \u4eba\u4eec\u4f1a\u5bf9\u6fc0\u52b1\u505a\u51fa\u53cd\u5e94","title":"\u4eba\u4eec\u5982\u4f55\u505a\u51fa\u51b3\u7b56"},{"location":"economics/micro_economics/#_4","text":"\u8d38\u6613\u53ef\u4ee5\u4f7f\u6bcf\u4e2a\u4eba\u7684\u72b6\u51b5\u90fd\u53d8\u5f97\u66f4\u597d \u5e02\u573a\u901a\u5e38\u662f\u7ec4\u7ec7\u7ecf\u6d4e\u4e92\u52a8\u7684\u4e00\u79cd\u597d\u65b9\u6cd5 \u653f\u5e9c\u6709\u65f6\u53ef\u4ee5\u6539\u5584\u5e02\u573a\u7ed3\u679c","title":"\u4eba\u4eec\u5982\u4f55\u76f8\u4e92\u5f71\u54cd"},{"location":"economics/micro_economics/#_5","text":"\u4e00\u56fd\u7684\u751f\u6d3b\u6c34\u5e73\u53d6\u51b3\u4e8e\u5b83\u751f\u4ea7\u7269\u54c1\u548c\u670d\u52a1\u7684\u80fd\u529b \u5f53\u653f\u5e9c\u53d1\u578b\u4e86\u8fc7\u591a\u8d27\u5e01\u65f6\uff0c\u7269\u4ef7\u4e0a\u5347 \u793e\u4f1a\u9762\u4e34\u901a\u8d27\u81a8\u80c0\u548c\u5931\u4e1a\u4e4b\u95f4\u7684\u77ed\u671f\u6743\u8861\u53d6\u820d","title":"\u6574\u4f53\u7ecf\u6d4e\u5982\u4f55\u8fd0\u884c"},{"location":"economics/micro_economics/#_6","text":"","title":"\u7ecf\u6d4e\u5b66\u5bb6\u7684\u601d\u8003\u65b9\u5f0f"},{"location":"economics/micro_economics/#_7","text":"\u7ecf\u6d4e\u5b66\u5bb6\u4f7f\u7528\u201c\u89c2\u5bdf\u3001\u7406\u8bba\u548c\u8fdb\u4e00\u6b65\u89c2\u5bdf\u201d\u7684\u65b9\u6cd5\u7814\u7a76\u95ee\u9898 \u7ecf\u6d4e\u5b66\u4f7f\u7528\u7b80\u5316\u6a21\u578b\u6765\u63cf\u8ff0\u95ee\u9898\uff0c\u4e3e\u4f8b\u6765\u8bf4 \u7b2c\u4e00\u4e2a\u6a21\u578b\uff1a\u5faa\u73af\u6d41\u91cf\u56fe \u7b2c\u4e8c\u4e2a\u6a21\u578b\uff1a\u751f\u4ea7\u53ef\u80fd\u6027\u8fb9\u754c","title":"\u4f5c\u4e3a\u79d1\u5b66\u5bb6"},{"location":"economics/micro_economics/#_8","text":"\u5b9e\u8bc1\u5206\u6790 \u63cf\u8ff0\u4e16\u754c\u662f\u4ec0\u4e48\u6837\u5b50 \u89c4\u8303\u5206\u6790 \u63cf\u8ff0\u4e16\u754c\u5e94\u8be5\u662f\u4ec0\u4e48\u6837\u5b50 \u4f5c\u4e3a\u987e\u95ee\u7684\u7ecf\u6d4e\u5b66\u5bb6\u7ecf\u5e38\u4f1a\u7ed9\u51fa\u622a\u7136\u4e0d\u540c\u7684\u653f\u7b56\u5efa\u8bae\uff0c\u800c\u653f\u7b56\u5236\u5b9a\u8005\u4e5f\u7ecf\u5e38\u4e0d\u4e88\u91c7\u7eb3\u3002 \u79d1\u5b66\u5224\u65ad\u548c\u4e2a\u4eba\u4ef7\u503c\u89c2\u90fd\u4f1a\u5f71\u54cd\u7ecf\u6d4e\u5b66\u5bb6\u7ed9\u51fa\u7684\u89c2\u70b9\u548c\u610f\u89c1\u3002","title":"\u4f5c\u4e3a\u653f\u7b56\u987e\u95ee"},{"location":"economics/micro_economics/#_9","text":"","title":"\u76f8\u4e92\u4f9d\u5b58\u6027\u548c\u8d38\u6613\u7684\u597d\u5904"},{"location":"languages/cpp/basic/","text":"C++\u57fa\u7840 \u53d8\u91cf\u5b9a\u4e49 auto \u53d8\u91cf \u7531\u7f16\u8bd1\u5668\u6839\u636e\u4e0a\u4e0b\u6587\u81ea\u52a8\u786e\u5b9a\u53d8\u91cf\u7c7b\u578b\uff0c\u5982\uff1a auto i = 3 ; auto f = 4.0f ; \u6307\u9488\u53d8\u91cf\u7684\u52a8\u6001\u751f\u6210\u548c\u5220\u9664 \u6307\u9488\u53d8\u91cf\u6240\u6307\u5185\u5b58\u53ef\u4ee5\u901a\u8fc7 new/delete \u8fd0\u7b97\u7b26\u5728\u7a0b\u5e8f\u8fd0\u884c\u65f6\u52a8\u6001\u751f\u6210\u548c\u5220\u9664\uff0c\u5982\uff1a int * ptr = new int ; int * array = new int [ 10 ]; delete ptr ; delete [] array ; \u5de6\u503c\u5f15\u7528 \u5177\u540d\u53d8\u91cf\u7684\u522b\u540d\uff1a\u7c7b\u578b\u540d& \u5f15\u7528\u540d \u53d8\u91cf\u540d int v0 ; int & v1 = v0 ; \u8fd9\u91cc v1 \u662f v0 \u7684\u5f15\u7528\uff0c\u4ed6\u4eec\u5728\u5185\u5b58\u4e2d\u662f\u540c\u4e00\u5355\u5143\u7684\u4e24\u4e2a\u4e0d\u540c\u540d\u5b57 \u5f15\u7528\u5fc5\u987b\u5728\u5b9a\u4e49\u65f6\u8fdb\u884c\u521d\u59cb\u5316\uff08\u8d4b\u521d\u503c\uff09\u3002 \u88ab\u5f15\u7528\u53d8\u91cf\u540d\u53ef\u4ee5\u662f\u7ed3\u6784\u53d8\u91cf\u6210\u5458\uff0c\u5982 s.m \u3002 \u51fd\u6570\u53c2\u6570\u53ef\u4ee5\u662f\u5f15\u7528\u7c7b\u578b\uff0c\u8868\u793a\u51fd\u6570\u7684\u5f62\u5f0f\u53c2\u6570\u4e0e\u5b9e\u9645\u53c2\u6570\u662f\u540c\u4e00\u4e2a\u53d8\u91cf\uff0c\u6539\u53d8\u5f62\u53c2\u5c06\u6539\u53d8\u5b9e\u53c2\u3002 \u5982\u8c03\u7528\u4ee5\u4e0b\u51fd\u6570\u5c06\u4ea4\u6362\u5b9e\u53c2\u503c\uff1a void swap ( int & a , int & b ) { int tmp = b ; b = a ; a = tmp ; } \u51fd\u6570\u7684\u8fd4\u56de\u503c\u53ef\u4ee5\u662f\u5f15\u7528\u7c7b\u578b\uff0c\u4f46\u4e0d\u80fd\u662f\u51fd\u6570\u7684\u4e34\u65f6\u53d8\u91cf\u3002 \u53f3\u503c\u5f15\u7528\uff08C++11 \u5f15\u5165\uff09 \u53f3\u503c \uff1a\u4e0d\u80fd\u53d6\u5730\u5740\u7684\u3001\u6ca1\u6709\u540d\u5b57\u7684\u5c31\u662f\u53f3\u503c \u533f\u540d\u53d8\u91cf\uff08\u4e34\u65f6\u53d8\u91cf\uff09\u7684\u522b\u540d\uff1a\u7c7b\u578b\u540d&& \u5f15\u7528\u540d \u8868\u8fbe\u5f0f\uff0c\u5982 int && sum = 3 + 4 ; float && res = ReturnRvalue ( f1 , f2 ); \u53f3\u503c\u5f15\u7528\u7684\u5178\u578b\u5e94\u7528\u662f\u5728\u51fd\u6570\u53c2\u6570\u4e2d\uff0c\u76ee\u7684\u662f\u51cf\u5c11\u4e34\u65f6\u53d8\u91cf\u7684\u62f7\u8d1d\u5f00\u9500\uff0c\u4f8b\u5982\uff1a void AcceptRvalueRef ( T && s ) {...} \u53d8\u91cf\u521d\u59cb\u5316\u3001\u7c7b\u578b\u63a8\u5bfc\u3001\u57fa\u4e8e\u8303\u56f4\u7684\u5faa\u73af \u521d\u59cb\u5316\u5217\u8868 \u7528 {}``\u5305\u62ec\u8d77\u6765\u7684\u5143\u7d20\u5e8f\u5217\uff0c\u53ef\u4ee5\u7528\u6765\u5bf9\u53d8\u91cf\u8fdb\u884c\u521d\u59cb\u5316\uff0c\u5982 int a [] = { 1 , 3 , 5 }; int a [] { 1 , 3 , 5 }; \u521d\u59cb\u5316\u5217\u8868\u53ef\u4ee5\u518d {} \u4e4b\u524d\u4f7f\u7528 =`\uff0c\u4e5f\u53ef\u4ee5\u4e0d\u7528\u3002 \u53d8\u91cf\u7684\u521d\u59cb\u5316\u65b9\u5f0f int a = 3 + 5 ; int a = { 3 + 5 }; int a ( 3 + 5 ); // \u8c03\u7528int\u7684\u6784\u9020\u51fd\u6570 int a { 3 + 5 }; int * i = new int ( 10 ); double * d = new double { 1.2f }; // \u521d\u59cb\u5316\u5217\u8868 \u7c7b\u578b\u63a8\u5bfc \u4f7f\u7528 decltype \u53ef\u4ee5\u5bf9\u53d8\u91cf\u6216\u8868\u8fbe\u5f0f\u7ed3\u679c\u7684\u7c7b\u578b\u8fdb\u884c\u63a8\u5bfc\uff0c\u5982 struct { char * name ; } anon_u ; struct { int d ; decltype ( anon_u ) id ; } anon_s [ 100 ]; // \u533f\u540d\u7684struct\u6570\u7ec4 int main () { decltype ( anon_s ) as ; cin >> as [ 0 ]. id . name ; } \u57fa\u4e8e\u8303\u56f4\u7684 for \u5faa\u73af\u8bed\u53e5 \u5728\u5faa\u73af\u5934\u7684\u5706\u62ec\u53f7\u4e2d\uff0c\u7531\u5192\u53f7 : \u5206\u4e3a\u4e24\u90e8\u5206\uff0c\u7b2c\u4e00\u90e8\u5206\u9002\u7528\u4e8e\u8fed\u4ee3\u7684\u53d8\u91cf\uff0c\u7b2c\u4e8c\u90e8\u5206\u5219\u8868\u793a\u88ab\u8fed\u4ee3\u7684\u8303\u56f4\uff0c\u5982\uff1a int arr [ 3 ] = { 1 , 3 , 5 }; for ( int e : arr ) //... \u51fd\u6570 \u51fd\u6570\u91cd\u8f7d \u540c\u4e00\u540d\u79f0\u7684\u51fd\u6570\uff0c\u6709\u4e24\u4e2a\u4ee5\u4e0a\u4e0d\u540c\u7684\u51fd\u6570\u5b9e\u73b0\uff0c\u88ab\u79f0\u4e3a\u201c\u51fd\u6570\u91cd\u8f7d\u201d\uff0c\u5982\uff1a void print ( char * msg ) { cout << \"message: \" << msg << endl ; } void print ( int score ) { cout << \"score: \" << score << endl ; } \u51fd\u6570\u91cd\u8f7d\u8981\u6c42\u51fd\u6570\u5f62\u53c2\u4e0d\u540c\uff0c\u4e0d\u80fd\u51fa\u73b0\u4ec5\u4ec5\u8fd4\u56de\u503c\u4e0d\u540c\u7684\u60c5\u51b5\u3002\u7f16\u8bd1\u5668\u901a\u8fc7\u51fd\u6570\u8c03\u7528\u8bed\u53e5\u7684\u5b9e\u53c2\u786e\u5b9a\u54ea\u4e00\u4e2a\u51fd\u6570\u88ab\u8c03\u7528\u3002 \u591a\u4e2a\u540c\u540d\u51fd\u6570\u5b9e\u73b0\u4e4b\u95f4\uff0c\u5fc5\u987b\u4fdd\u8bc1\u81f3\u5c11\u6709\u4e00\u4e2a\u51fd\u6570\u53c2\u6570\u7684\u7c7b\u578b\u6709\u533a\u522b\u3002\u8fd4\u56de\u503c\u3001\u53c2\u6570\u540d\u79f0\u7b49\u4e0d\u80fd\u4f5c\u4e3a\u533a\u5206\u6807\u8bc6\u3002 \u51fd\u6570\u53c2\u6570\u7684\u7f3a\u7701\u503c \u51fd\u6570\u53c2\u6570\u53ef\u4ee5\u5728\u5b9a\u4e49\u65f6\u8bbe\u7f6e\u9ed8\u8ba4\u503c\uff08\u7f3a\u7701\u503c\uff09\uff0c\u8fd9\u6837\u5728\u8c03\u7528\u8be5\u51fd\u6570\u65f6\uff0c\u82e5\u4e0d\u63d0\u4f9b\u76f8\u5e94\u7684\u5b9e\u53c2\uff0c\u5219\u7f16\u8bd1\u5668\u81ea\u52a8\u5c06\u76f8\u5e94\u5f62\u53c2\u8bbe\u7f6e\u6210\u7f3a\u7701\u503c\uff0c\u5982\uff1a void print ( char * msg = \"hello\" ) { cout << msg << '#' ; } int main () { print ( \"Beijing...\" ); print (); return 0 ; } \u8f93\u51fa\uff1a Beijing...#hello# \u5e26\u7f3a\u7701\u503c\u7684\u51fd\u6570\u53c2\u6570\u5fc5\u987b\u653e\u5728\u6ca1\u6709\u7f3a\u7701\u503c\u7684\u51fd\u6570\u53c2\u6570\u540e\u9762\u3002 \u8ffd\u8e2a\u8fd4\u56de\u7c7b\u578b\u7684\u51fd\u6570 \u53ef\u4ee5\u5c06\u51fd\u6570\u8fd4\u56de\u7c7b\u578b\u7684\u4fe1\u606f\u653e\u5230\u51fd\u6570\u53c2\u6570\u5217\u8868\u7684\u540e\u9762\u8fdb\u884c\u58f0\u660e\uff0c\u5982\uff1a \u666e\u901a\u51fd\u6570\u58f0\u660e\u5f62\u5f0f\uff1a int func ( char * ptr , int val ); \u8ffd\u8e2a\u8fd4\u56de\u7c7b\u578b\u7684\u51fd\u6570\u58f0\u660e\u5f62\u5f0f\uff1a auto func ( char * ptr , int val ) -> int ; \u8ffd\u8e2a\u8fd4\u56de\u7c7b\u578b\u5728\u539f\u672c\u51fd\u6570\u8fd4\u56de\u503c\u7684\u4f4d\u7f6e\u4f7f\u7528 auto \u5173\u952e\u5b57\u3002 \u52a8\u673a \uff1a\u6709\u65f6\u51fd\u6570\u5728\u5b9a\u4e49\u7684\u65f6\u5019\u5e76\u4e0d\u80fd\u786e\u5b9a\u8fd4\u56de\u503c\u7c7b\u578b\uff0c\u800c\u9700\u8981\u901a\u8fc7 decl \u83b7\u53d6\u53c2\u6570\u7684\u7c7b\u578b\u6765\u786e\u5b9a\u3002 \u5e94\u7528 \uff1a \u5728C++\u6a21\u677f\u7684\u5b9a\u4e49\u4e2d\uff0c\u6709\u65f6\u8fd4\u56de\u7c7b\u578b\u9700\u8981\u6839\u636e\u53c2\u6570\u7c7b\u578b\u7c7b\u786e\u5b9a\uff0c\u4f1a\u7528\u5230\u8fd9\u4e2a\u7279\u6027\u3002 \u7c7b \u7528\u6237\u81ea\u5b9a\u4e49\u7684\u7c7b\u578b\u2014\u2014\u7c7b\uff1a \u4e00\u79cd\u7528\u6237\u81ea\u5b9a\u4e49\u7684\u7c7b\u578b\uff0c\u5305\u542b\u51fd\u6570\u4e0e\u6570\u636e\u7684\u7279\u6b8a\u201c\u7ed3\u6784\u4f53\u201d\uff0c\u6269\u5145C++\u8bed\u8a00\u7684\u7c7b\u578b\u4f53\u7cfb\u3002 \u7c7b\u4e2d\u5305\u542b\u7684\u51fd\u6570\uff0c\u79f0\u4e3a \u6210\u5458\u51fd\u6570 \uff1b\u5305\u542b\u7684\u6570\u636e\uff0c\u79f0\u4e3a \u6570\u636e\u6210\u5458 \u3002 \u7c7b\u4e2d\u51fd\u6570\u53ca\u53ef\u4ee5\u5728\u7c7b\u4e2d\u7ed9\u51fa\u5b9a\u4e49\uff0c\u4e5f\u53ef\u4ee5\u5728\u7c7b\u5916\u7ed9\u51fa\u5b9a\u4e49\u3002 \u7c7b\u7684\u6210\u5458\uff08\u51fd\u6570\u3001\u6570\u636e\uff09\u53ef\u4ee5\u6839\u636e\u9700\u8981\u5206\u6210\u7ec4\uff0c\u4e0d\u540c\u7ec4\u8bbe\u7f6e\u4e0d\u540c\u7684\u8bbf\u95ee\u6743\u9650\u3002 \u6743\u9650\u79cd\u7c7b\uff1a public , private , protected \u3002 \u7c7b\u5b9a\u4e49\u540e\uff0c\u6838\u51fd\u6570\u5185\u5efa\u7684\u7c7b\u578b\u4e00\u6837\uff0c\u7528\u7c7b\u6765\u5b9a\u4e49\u53d8\u91cf\uff0c\u8be5\u53d8\u91cf\u901a\u5e38\u88ab\u79f0\u4e3a \u5bf9\u8c61 \u3002 \u901a\u8fc7\u201c\u5bf9\u8c61\u540d.\u6210\u5458\u540d\u201d\u7684\u5f62\u5f0f\uff0c\u53ef\u4ee5\u4f7f\u7528\u5bf9\u8c61\u7684\u6570\u636e\u6210\u5458\uff0c\u6216\u8c03\u7528\u5bf9\u8c61\u7684\u6570\u636e\u51fd\u6570\uff0c\u4f46\u4ec5\u9650\u4e8e\u8bbf\u95ee public \u6743\u9650\u7684\u6210\u5458\u3002 \u5728\u7c7b\u5916\u5b9a\u4e49\u6210\u5458\u51fd\u6570\u65f6\uff0c\u51fd\u6570\u540d\u524d\u8981\u52a0\u4e0a\u7c7b\u540d\u9650\u5b9a\uff0c\u683c\u5f0f\u4e3a\uff1a \u7c7b\u540d::\u51fd\u6570\u540d \uff0c\u5176\u4e2d :: \u79f0\u4e3a \u57df\u8fd0\u7b97\u7b26 \u3002 \u5728\u5934\u6587\u4ef6\u4e2d\u58f0\u660e\u7c7b class // matrix.h #ifndef MATRIX_H #define MATRIX_H class Matrix { int data [ 6 ][ 6 ]; public : void fill ( char dir ); }; #endif \u5728\u5b9e\u73b0\u6587\u4ef6\u4e2d\u5b9a\u4e49\u7c7b class // matrix.cpp #include \"matrix.h\" void Matrix :: fill ( char dir ) { //... } \u901a\u5e38\uff0c\u7c7b\u7684\u58f0\u660e\u653e\u5728\u5934\u6587\u4ef6\u4e2d\uff0c\u800c\u7c7b\u7684\u6210\u5458\u51fd\u6570\u5b9e\u73b0\u5219\u653e\u5728\u5b9e\u73b0\u6587\u4ef6\u4e2d\u3002 \u4e3a\u4e86\u4fbf\u4e8e\u7ba1\u7406\u548c\u4ee3\u7801\u590d\u7528\uff0c\u4e00\u822c\u662f\u5c06\u4e0d\u540c\u7684\u7c7b\u5206\u522b\u4fdd\u5b58\u4e3a\u4e0d\u540c\u7684\u5934\u6587\u4ef6\u548c\u5b9e\u73b0\u6587\u4ef6\u3002 \u6210\u5458\u51fd\u6570\u7684\u4e24\u79cd\u5b9a\u4e49\u65b9\u5f0f \u53ef\u4ee5\u5728\u7c7b\u7684\u5b9a\u4e49\u5185\u90e8\u5b9e\u73b0\uff0c\u4e5f\u53ef\u4ee5\u7528 :: \u8fd0\u7b97\u7b26\u5728\u5916\u90e8\u5b9e\u73b0\u3002 class Matrix { public : void fill ( char dir ) { //... } }; void Matrix :: fill ( char dir ) { //... }; this \u6307\u9488 \u6240\u6709\u6210\u5458\u51fd\u6570\u7684\u53c2\u6570\u4e2d\uff0c\u9690\u542b\u7740\u4e00\u4e2a\u53ea\u60f3\u5f53\u524d\u5bf9\u8c61\u7684\u6307\u9488\u53d8\u91cf\u2014\u2014 this \u3002 \u8fd9\u4e5f\u662f \u6210\u5458\u51fd\u6570 \u4e0e \u666e\u901a\u51fd\u6570 \u7684\u91cd\u8981\u533a\u522b \u8bbf\u95ee\u6743\u9650 C++\u89c4\u5b9a\u7c7b\u7684\u6210\u5458\u7f3a\u7701\u4e3a private \u6743\u9650\u3002 \u5bf9\u8c61\u4f7f\u7528 . \u64cd\u4f5c\u7b26\u8bbf\u95ee\u5bf9\u8c61\u7684 public \u6210\u5458\u3002 \u5bf9\u8c61\u6307\u9488\u4f7f\u7528 -> \u64cd\u4f5c\u7b26\u8bbf\u95ee\u6240\u6307\u5bf9\u8c61\u7684\u516c\u6709\u6210\u5458\u3002 \u53cb\u5143 \u6709\u65f6\u9700\u8981\u5141\u8bb8\u67d0\u4e9b\u51fd\u6570\u8bbf\u95ee\u5bf9\u8c61\u7684\u79c1\u6709\u6210\u5458\uff0c\u53ef\u4ee5\u901a\u8fc7\u58f0\u660e\u8be5 \u51fd\u6570 \u4e3a \u7c7b \u7684\u201c\u53cb\u5143\u201d\u6765\u5b9e\u73b0\u3002 class Test { int id ; public : friend void print ( Test obj ); //... }; void print ( Test obj ) { cout << obj . id << endl ; } Test \u7c7b\u4e2d\u58f0\u660e\u4e86 Test \u7c7b\u7684\u53cb\u5143\u51fd\u6570 print \uff0c\u8be5\u51fd\u6570\u5728\u5b9e\u73b0\u65f6\u53ef\u4ee5\u8bbf\u95ee Test \u7c7b\u5b9a\u4e49\u7684\u51fd\u6570\u5bf9\u8c61\u7684\u79c1\u6709\u6210\u5458\u3002 \u5de5\u7a0b\u4e2d\u4e00\u79cd\u5e38\u89c1\u7684\u7528\u6cd5\u662f\u5c06UT\u4e2d\u7684\u6d4b\u8bd5\u51fd\u6570\u751f\u547d\u6210\u88ab\u6d4b\u8bd5\u7c7b\u7684\u53cb\u5143\uff0c\u4ee5\u4fbf\u5728\u6d4b\u8bd5\u51fd\u6570\u4e2d\u8bbf\u95ee\u88ab\u6d4b\u8bd5\u7c7b\u7684\u79c1\u6709\u6210\u5458\u3002 \u6784\u9020\u51fd\u6570\u3001\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u4e0e\u6790\u6784\u51fd\u6570 \u89e3\u91ca\u5982\u4e0b\u7a0b\u5e8f\u7684\u8fd0\u884c\u7ed3\u679c\uff1a #include <iostream> using namespace std ; class Test { public : Test () { cout << \"Test()\" << endl ; } Test ( const Test & src ) { cout << \"Test(const Test&)\" << endl ; } ~ Test () { cout << \"~Test()\" << endl ; } }; void func1 ( Test obj ) { cout << \"func1()...\" << endl ; } Test func2 () { cout << \"func2()...\" << endl ; return Test (); } int main () { cout << \"main()...\" << endl ; Test t ; func1 ( t ); t = func2 (); return 0 ; } \u62f7\u8d1d\u6784\u9020\u51fd\u6570 \u4f1a\u5728\u51fd\u6570\u7531\u5b9e\u53c2\u83b7\u5f97\u5f62\u53c2\u65f6\u8c03\u7528\u3002 \u8f93\u51fa main()... Test() Test(const Test&) func1()... ~Test() func2()... Test() ~Test() ~Test() \u8d4b\u503c\u8fd0\u7b97\u7b26 = \u91cd\u8f7d \u89e3\u91ca\u5982\u4e0b\u7a0b\u5e8f\u7684\u8fd0\u884c\u7ed3\u679c #include <iostream> using namespace std ; class Test { public : Test ( int _id ) : id ( _id ) { cout << \"obj_\" << id << \"created \\n \" ; } Test & operator = ( const Test & right ) { if ( this == & right ) cout << \"same obj! \\n \" ; else { cout << \"obj_\" << id << \" = obj_\" << right . id << endl ; } return * this ; } private : int id ; }; int main () { Test a ( 1 ), b ( 2 ); cout << \"a = a: \" ; a = a ; cout << \"a = b: \" ; a = b ; return 0 ; } } \u8f93\u51fa obj_1created obj_2created a = a: same obj! a = b: obj_1 = obj_2 \u6d41\u8fd0\u7b97\u7b26 <</>> \u91cd\u8f7d \u89e3\u91ca\u5982\u4e0b\u7a0b\u5e8f\u8fd0\u884c\u7ed3\u679c #include <iostream> using namespace std ; class Test { int id ; public : Test ( int _id ) : id ( _id ) { cout << \"obj_\" << id << \"created \\n \" ; } friend istream & operator >> ( istream & in , Test & dst ); friend ostream & operator << ( ostream & out , const Test & src ); }; istream & operator >> ( istream & in , Test & dst ) { in >> dst . id ; return in ; } ostream & operator << ( ostream & out , const Test & src ) { cout << src . id << endl ; return out ; } int main () { Test obj ( 1 ); cout << obj ; cin >> obj ; cout << obj ; return 0 ; } \u5c06 \u6d41\u8fd0\u7b97\u7b26 \u58f0\u660e\u6210 Test Test \u7c7b\u7684\u53cb\u5143\uff0c\u5728\u5b9e\u73b0\u7684\u65f6\u5019\u53ef\u4ee5\u8bbf\u95ee\u5176\u79c1\u6709\u53d8\u91cf\u3002 \u8fd4\u56de\u6d41\u5bf9\u8c61\u662f\u4e3a\u4e86\u652f\u6301\u6d41\u8fd0\u7b97\u7b26\u7684\u94fe\u5f0f\u64cd\u4f5c\u3002 \u8f93\u51fa\uff08\u4e2d\u95f4\u8f93\u5165\u6d41\u5185\u5bb9\u4e3a 2 2 \uff09 obj_1created 1 2 2 \u51fd\u6570\u8fd0\u7b97\u7b26 () \u91cd\u8f7d \u89e3\u91ca\u5982\u4e0b\u7a0b\u5e8f\u8fd0\u884c\u7ed3\u679c #include <iostream> using namespace std ; class Test { public : int operator ()( int a , int b ) { cout << \"operator() called. \" << a << ' ' << b << endl ; return a + b ; } }; int main () { Test sum ; int s = sum ( 3 , 4 ); cout << \"a + b = \" << s << endl ; return 0 ; } sum\u5bf9\u8c61\u770b\u4e0a\u53bb\u50cf\u4e00\u4e2a\u51fd\u6570\uff0c\u6545\u4e5f\u79f0\u201c\u51fd\u6570\u5bf9\u8c61\u201d\u3002 \u8f93\u51fa operator() called. 3 4 a + b = 7 \u4e0b\u6807\u8fd0\u7b97\u7b26 [] \u548c ++/-- \u81ea\u589e\u51cf\u8fd0\u7b97\u7b26 \u4e0b\u6807\u8fd0\u7b97\u7b26 \u4e0b\u9762\u7684\u4ee3\u7801\u4f53\u73b0\u8bbe\u8ba1\u6a21\u5f0f\u4e2d\u201c\u5305\u88c5\u201d\u7684\u601d\u60f3\uff0c\u8ba9\u539f\u672c\u53ea\u652f\u6301\u6570\u5b57\u7684 [] \u8fd0\u7b97\u7b26\u5bf9\u5916\u652f\u6301\u5b57\u7b26\u4e32\u7c7b\u578b\u7d22\u5f15\u3002 #include <iostream> #include <string.h> using namespace std ; char week_name [ 7 ][ 4 ] = { \"mon\" , \"tu\" , \"wed\" , \"thu\" , \"fri\" , \"sat\" , \"sun\" }; class WeekTemp { public : int & operator []( const char * name ) { for ( int i = 0 ; i < 7 ; i ++ ) { if ( strcmp ( week_name [ i ], name ) == 0 ) return temp [ i ]; } } private : int temp [ 7 ]; }; int main () { WeekTemp beijing ; beijing [ \"mon\" ] = - 3 ; beijing [ \"tu\" ] = - 1 ; cout << \"Monday Temperture: \" << beijing [ \"mon\" ] << endl ; return 0 ; } \u8f93\u51fa Monday Temperture: -3 \u524d\u7f00 ++/-- \u4e0e\u540e\u7f00 ++/-- \u524d\u7f00\u8fd0\u7b97\u7b26\u91cd\u8f7d\u58f0\u660e ReturnType operator ++ (); ReturnType operator -- (); \u540e\u7f00\u8fd0\u7b97\u7b26\u91cd\u8f7d\u58f0\u660e ReturnType operator ++ ( int dummy ); ReturnType operator -- ( int dummy ); \u901a\u8fc7\u5728\u51fd\u6570\u53c2\u6570\u4e2d\u7684\u54d1\u5143\u53c2\u6570 dummy \u6765\u533a\u5206\u524d\u7f00\u548c\u540e\u7f00\u7684\u540c\u540d\u91cd\u8f7d\u3002 \u54d1\u5143\uff1a\u51fd\u6570\u4f53\u8bed\u53e5\u4e2d\u6ca1\u6709\u4f7f\u7528\u8be5\u53c2\u6570\u3002 \u9759\u6001\u6210\u5458\u548c\u5e38\u91cf\u6210\u5458 \u9759\u6001\u6210\u5458 static \u4fee\u9970\u7684\u6570\u636e\u6210\u5458\u96b6\u5c5e\u4e8e\u7c7b\u3002 \u9759\u6001\u6570\u636e\u6210\u5458\u88ab\u8be5\u7c7b\u7684\u6240\u6709\u5bf9\u8c61\u5171\u4eab\uff08\u5373\u6240\u6709\u5bf9\u8c61\u4e2d\u7684\u8fd9\u4e2a\u6570\u636e\u57df\u5904\u4e8e\u540c\u4e00\u5185\u5b58\u4f4d\u7f6e\uff09 \u9759\u6001\u6570\u636e\u6210\u5458\u8981\u5728 \u5b9e\u73b0\u6587\u4ef6 \u4e2d\u8d4b\u521d\u503c\uff0c\u683c\u5f0f\u4e3a\uff1a Type ClassName::static_var = Value; \u5bf9\u4e8e\u9759\u6001\u6210\u5458\u51fd\u6570\uff0c\u7f16\u8bd1\u5668\u4e0d\u63d0\u4f9b\u6307\u5411\u5bf9\u8c61\u7684\u6307\u9488\uff0c\u5b83\u4eec\u4e0d\u80fd\u8c03\u7528\u975e\u9759\u6001\u6210\u5458\u51fd\u6570\u3002 \u7c7b\u7684\u9759\u6001\u6210\u5458\u65e2\u53ef\u4ee5\u901a\u8fc7\u5bf9\u8c61\u6765\u8bbf\u95ee\uff0c\u4e5f\u53ef\u4ee5\u901a\u8fc7\u7c7b\u540d\u6765\u8bbf\u95ee\u3002 \u89e3\u91ca\u5982\u4e0b\u4ee3\u7801\u884c\u4e3a\uff1a #include <iostream> using namespace std ; class Test { public : Test () { count ++ ; } ~ Test () { count -- ; } static int how_many () { return count ; } private : static int count ; }; int Test :: count = 0 ; void print ( Test t ) { cout << \"in print(), Test#: \" << t . how_many () << endl ; } int main () { Test t1 ; cout << \"Test#: \" << Test :: how_many () << endl ; Test t2 = t1 ; cout << \"Test#: \" << Test :: how_many () << endl ; print ( t2 ); cout << \"Test#: \" << t1 . how_many () << \", \" << t2 . how_many () << endl ; return 0 ; } \u8f93\u51fa Test#: 1 Test#: 1 in print(), Test#: 1 Test#: 0, 0 \u6ce8\u610f\u5230 t2 = t1; \u6b64\u5904\u8c03\u7528\u7684\u662f = \u8fd0\u7b97\u7b26\uff0c\u800c print(t2); \u8c03\u7528\u7684\u662f \u62f7\u8d1d\u6784\u9020\u51fd\u6570 \uff0c\u4f46\u5728 Test \u91cc\u9762\u5747\u672a\u5b9a\u4e49\u884c\u4e3a\u3002\u4f46 print(t2); \u8fd4\u56de\u65f6\u8c03\u7528\u4e86 \u6790\u6784\u51fd\u6570 \uff0c\u6545\u6700\u540e\u4e00\u884c\u9759\u6001\u6210\u5458 count \u53d8\u6210\u4e860\u3002 \u5e38\u91cf\u6210\u5458 const \u4fee\u9970\u7684\u6570\u636e\u6210\u5458\uff0c\u79f0\u4e3a\u7c7b\u7684\u5e38\u91cf\u6570\u636e\u6210\u5458\uff0c\u5728\u5bf9\u8c61\u7684\u6574\u4e2a\u751f\u547d\u5468\u671f\u91cc\u4e0d\u53ef\u6539\u53d8\u3002 \u5e38\u91cf\u6570\u636e\u6210\u5458\u53ea\u80fd\u5728\u6784\u9020\u51fd\u6570\u521d\u59cb\u5316\u5217\u8868\u4e2d\u88ab\u8bbe\u7f6e\uff0c\u4e0d\u80fd\u5728\u51fd\u6570\u4f53\u4e2d\u901a\u8fc7\u8d4b\u503c\u8bbe\u7f6e\u3002 const \u4fee\u9970\u7684\u6210\u5458\u51fd\u6570\uff0c\u5219\u8be5\u6210\u5458\u51fd\u6570\u5728\u5b9e\u73b0\u65f6\u4e0d\u80fd\u4fee\u6539\u7c7b\u7684\u6570\u636e\u6210\u5458 \u2014\u2014\u2014\u2014 \u5373\u9759\u6001\u51fd\u6570\u4e0d\u80fd\u6539\u53d8\u5bf9\u8c61\u72b6\u6001\u3002 \u82e5\u5bf9\u8c61\u88ab\u5b9a\u4e49\u4e3a\u5e38\u91cf\uff0c\u5219\u5b83\u53ea\u80fd\u8c03\u7528\u4ee5 const \u4fee\u9970\u7684\u6210\u5458\u51fd\u6570\uff0c\u5176\u4ed6\u666e\u901a\u6210\u5458\u51fd\u6570\u5219\u4e0d\u5141\u8bb8\u8c03\u7528\u3002 \u89e3\u91ca\u5982\u4e0b\u4ee3\u7801\u884c\u4e3a #include <iostream> using namespace std ; class Test { public : Test ( int id ) : ID ( id ) {} int MyID () const { return ID ; } int Who () { return ID ; } private : const int ID ; }; int main () { Test obj1 ( 12231031 ); cout << \"ID_1 = \" << obj1 . MyID () << endl ; cout << \"ID_2 = \" << obj1 . Who () << endl ; const Test obj2 ( 1602401 ); cout << \"id_1: \" << obj2 . MyID () << endl ; return 0 ; } \u8f93\u51fa ID_1 = 12231031 ID_2 = 12231031 id_1: 1602401 \u5bf9\u8c61\u7ec4\u5408 \u53ef\u4ee5\u5728\u7c7b\u4e2d\u4f7f\u7528\u5176\u4ed6\u7c7b\u6765\u5b9a\u4e49\u6570\u636e\u6210\u5458\uff0c\u901a\u5e38\u79f0\u4e4b\u4e3a\u201c\u5b50\u5bf9\u8c61\u201d\u3002\u8fd9\u79cd\u5305\u542b\u5173\u7cfb\u79f0\u4e3a \u7ec4\u5408 \uff0c\u7ec4\u5408\u5173\u7cfb\u53ef\u4ee5\u5d4c\u5957\u3002 \u5b50\u5bf9\u8c61\u6784\u9020\u65f6\u82e5\u9700\u8981\u53c2\u6570\uff0c\u5219\u5e94\u5728\u5f53\u524d\u7c7b\u7684\u6784\u9020\u51fd\u6570\u7684 \u521d\u59cb\u5316\u5217\u8868 \u4e2d\u8fdb\u884c\u3002\u82e5\u4f7f\u7528\u9ed8\u8ba4\u6784\u9020\u51fd\u6570\u6765\u6784\u9020\u5b50\u5bf9\u8c61\u5219\u4e0d\u7528\u505a\u4efb\u4f55\u5904\u7406\u3002 \u5bf9\u8c61\u6784\u9020\u4e0e\u6790\u6784\u6b21\u5e8f\uff1a\u7a7f\u8131\u539f\u7406 \u5148\u5b8c\u6210\u5b50\u5bf9\u8c61\u6784\u9020\uff0c\u518d\u5b8c\u6210\u5f53\u524d\u5bf9\u8c61\u6784\u9020 \u5148\u5bf9\u5916\u5c42\u5bf9\u8c61\u6790\u6784\uff0c\u518d\u5bf9\u5185\u5c42\u5bf9\u8c61\u6790\u6784 \u89e3\u91ca\u5982\u4e0b\u4ee3\u7801\u884c\u4e3a #include <iostream> using namespace std ; class C1 { public : C1 ( int id ) : ID ( id ) { cout << \"C1(int)\" << endl ; } ~ C1 () { cout << \"~C1()\" << endl ; } private : int ID ; }; class C2 { public : C2 () { cout << \"C2()\" << endl ; } ~ C2 () { cout << \"~C2()\" << endl ; } }; class C3 { public : C3 () : num ( 0 ), sub_obj1 ( 123 ) { cout << \"C3()\" << endl ; } C3 ( int n ) : num ( n ), sub_obj1 ( 123 ) { cout << \"C3(int)\" << endl ; } C3 ( int n , int k ) : num ( n ), sub_obj1 ( k ) { cout << \"C3(int, int)\" << endl ; } ~ C3 () { cout << \"~C3()\" << endl ; } private : int num ; C1 sub_obj1 ; C2 sub_obj2 ; }; int main () { C3 a , b ( 1 ), c ( 2 ), d ( 3 , 4 ); return 0 ; } C1 \u3001 C2 \u662f C3 \u7684\u5b50\u5bf9\u8c61\uff0c\u5176\u4e2d C2 \u63d0\u4f9b\u4e86\u7f3a\u7701\u6784\u9020\u51fd\u6570\uff0c\u6545\u5728 C3 \u4e2d\u4e0d\u7528\u663e\u5f0f\u521d\u59cb\u5316\uff1b\u4f46 C1 \u53ea\u63d0\u4f9b\u4e86\u4e00\u4e2a\u5e26\u53c2\u6570\u7684\u6784\u9020\u51fd\u6570\uff0c\u6545\u5fc5\u987b\u5728 C3 \u7684 \u521d\u59cb\u5316\u5217\u8868 \u91cc\u9762\u5b8c\u6210\u521d\u59cb\u5316\u3002 \u8f93\u51fa C1(int) C2() C3() C1(int) C2() C3(int) C1(int) C2() C3(int) C1(int) C2() C3(int, int) ~C3() ~C2() ~C1() ~C3() ~C2() ~C1() ~C3() ~C2() ~C1() ~C3() ~C2() ~C1() \u4ece\u8f93\u51fa\u53ef\u4ee5\u770b\u51fa\u6784\u9020\u94fe\u4ece\u5185\u5230\u5916\uff0c\u800c\u6790\u6784\u94fe\u4ece\u5916\u5411\u5185\u3002 \u79fb\u52a8\u6784\u9020\u51fd\u6570 (C++ 11\u5f15\u5165) \u8bed\u6cd5\uff1a ClassName(ClassName&&); \u76ee\u7684 \u7528\u6765\u5077\u201c\u4e34\u65f6\u53d8\u91cf\u201d\u4e2d\u7684\u8d44\u6e90\uff08\u5982\u5185\u5b58\uff09\u3002 \u4e34\u65f6\u53d8\u91cf\u88ab\u7f16\u8bd1\u5668\u8bbe\u7f6e\u4e3a\u5e38\u91cf\u5f62\u5f0f\uff0c\u4f7f\u7528\u201c\u62f7\u8d1d\u6784\u9020\u201d\u51fd\u6570\u65e0\u6cd5\u5c06\u8d44\u6e90\u201c\u5077\u201d\u51fa\u6765\uff08\u6539\u52a8\u4e86\u5143\u5bf9\u8c61\uff0c\u8fdd\u53cd\u5e38\u91cf\u7684\u9650\u5236\uff09\u3002 \u57fa\u4e8e \u53f3\u503c\u5f15\u7528 \u5b9a\u4e49\u7684 \u79fb\u52a8\u6784\u9020\u51fd\u6570 \u652f\u6301\u63a5\u53d7\u4e34\u65f6\u53d8\u91cf\uff0c\u80fd\u201c\u5077\u201d\u51fa\u4e34\u65f6\u53d8\u91cf\u4e2d\u7684\u8d44\u6e90\u3002 #include <iostream> using namespace std ; class Test { public : int * buf ; Test () { buf = new int ( 3 ); cout << \"Test(): this->buf @ \" << hex << buf << endl ; } ~ Test () { cout << \"~Test(): this->buf @ \" << hex << buf << endl ; if ( buf ) delete buf ; } Test ( Test & t ) : buf ( new int ( * t . buf )) { cout << \"Test(const Test&) called. this->buf @ \" << hex << buf << endl ; t . buf = nullptr ; } Test ( Test && t ) : buf ( t . buf ) { cout << \"Test(Test&&) called. this->buf @ \" << hex << buf << endl ; t . buf = nullptr ; } }; Test GetTemp () { Test tmp ; cout << \"GetTemp(): tmp.buf @ \" << hex << tmp . buf << endl ; return tmp ; } void fun ( Test t ) { cout << \"fun(Test t): t.buf @ \" << hex << t . buf << endl ; } int main () { Test a = GetTemp (); cout << \"main() : a.buf @ \" << hex << a . buf << endl ; fun ( a ); return 0 ; } \u8f93\u51fa Test(): this->buf @ 0x558bd1e13e70 GetTemp(): tmp.buf @ 0x558bd1e13e70 main() : a.buf @ 0x558bd1e13e70 Test(const Test&) called. this->buf @ 0x558bd1e142a0 fun(Test t): t.buf @ 0x558bd1e142a0 ~Test(): this->buf @ 0x558bd1e142a0 ~Test(): this->buf @ 0 \u5728\u5982\u4e0a\u7ed3\u679c\u4e2d\u6ca1\u6709\u8c03\u7528\u79fb\u52a8\u6784\u9020\u51fd\u6570\uff0c\u6b32\u6267\u884c\u8be5\u51fd\u6570\uff0c\u9700\u8981\u589e\u52a0\u7f16\u8bd1\u9009\u9879\uff0c\u7981\u6b62\u7f16\u8bd1\u5668\u8fdb\u884c\u8fd4\u56de\u503c\u4f18\u5316 g++ main.cpp --std = c++11 -fno-elide-constructors -o main \u8f93\u51fa Test(): this->buf @ 0x560b6f4dce70 GetTemp(): tmp.buf @ 0x560b6f4dce70 Test(Test&&) called. this->buf @ 0x560b6f4dce70 ~Test(): this->buf @ 0 Test(Test&&) called. this->buf @ 0x560b6f4dce70 ~Test(): this->buf @ 0 main() : a.buf @ 0x560b6f4dce70 Test(const Test&) called. this->buf @ 0x560b6f4dd2a0 fun(Test t): t.buf @ 0x560b6f4dd2a0 ~Test(): this->buf @ 0x560b6f4dd2a0 ~Test(): this->buf @ 0 \u53ef\u89c1\uff0c\u51fd\u6570\u8fd4\u56de\u7684\u65f6\u5019\u8c03\u7528\u7684\u662f\u79fb\u52a8\u6784\u9020\u51fd\u6570\u3002 \u5982\u679c\u5c06 Test \u7c7b\u4e2d\u7684\u79fb\u52a8\u6784\u9020\u51fd\u6570\u53bb\u6389\uff0c\u540c\u6837\u7981\u7528\u7f16\u8bd1\u4f18\u5316\uff0c\u5219\u7f16\u8bd1\u62a5\u9519\uff1a main.cpp: In function \u2018int main()\u2019: main.cpp:38:21: error: cannot bind non-const lvalue reference of type \u2018Test&\u2019 to an rvalue of type \u2018Test\u2019 Test a = GetTemp(); ~~~~~~~^~ main.cpp:18:5: note: initializing argument 1 of \u2018Test::Test(Test&)\u2019 Test(Test& t) : buf(new int(*t.buf)) { ^~~~ default\u4fee\u9970\u7b26 (C++ 11\u5f15\u5165) \u7f16\u8bd1\u5668\u81ea\u52a8\u751f\u6210\u7684\u6210\u5458\u51fd\u6570 \u5982\u679c\u4ee5\u4e0b\u6210\u5458\u51fd\u6570\u7528\u6237\u90fd\u6ca1\u6709\u4e3a\u7c7b\u5b9e\u73b0\uff0c\u5219\u7f16\u8bd1\u5668\u4f1a\u81ea\u52a8\u4e3a\u7c7b\u751f\u6210\u5b83\u4eec\u7684\u7f3a\u7701\u5b9e\u73b0 \u9ed8\u8ba4\u6784\u9020\u51fd\u6570 - \u7a7a\u51fd\u6570\uff0c\u4ec0\u4e48\u4e5f\u4e0d\u505a \u6790\u6784\u51fd\u6570 - \u7a7a\u51fd\u6570\uff0c\u4ec0\u4e48\u4e5f\u4e0d\u505a \u62f7\u8d1d\u6784\u9020\u51fd\u6570 - \u6309bit\u4f4d\u8d4b\u503c\u5bf9\u8c61\u6240\u5360\u5185\u5b58\u5185\u5bb9 \u79fb\u52a8\u6784\u9020\u51fd\u6570 - \u4e0e\u9ed8\u8ba4\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u4e00\u6837 \u8d4b\u503c\u8fd0\u7b97\u7b26\u91cd\u8f7d - \u4e0e\u9ed8\u8ba4\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u4e00\u6837 \u5982\u679c\u7528\u6237\u5b9a\u4e49\u4e86\u4e0a\u8ff0\u67d0\u4e2a\u6210\u5458\u51fd\u6570\uff0c\u5219\u7f16\u8bd1\u5668\u4e0d\u518d\u81ea\u52a8\u63d0\u4f9b\u76f8\u5e94\u7684\u9ed8\u8ba4\u5b9e\u73b0\u3002 =default \u663e\u5f0f\u7f3a\u7701 \u5728\u9ed8\u8ba4\u51fd\u6570\u5b9a\u4e49\u6216\u58f0\u660e\u52a0\u4e0a =default \uff0c\u53ef\u663e\u5f0f\u7684\u53ea\u662f\u7f16\u8bd1\u5668\u751f\u6210\u8be5\u51fd\u6570\u7684\u9ed8\u8ba4\u7248\u672c\u3002 class T { public : T () = default ; T ( int i ) : data ( i ) {} private : int data ; }; \u7ee7\u627f \u5728\u5df2\u6709\u7c7b\u7684\u57fa\u7840\u4e0a\uff0c\u53ef\u4ee5\u901a\u8fc7\u201c\u7ee7\u627f\u201d\u6765\u5b9a\u4e49\u65b0\u7684\u7c7b\uff0c\u5b9e\u73b0\u5bf9\u5df2\u6709\u4ee3\u7801\u7684\u590d\u7528\u3002 \u5e38\u89c1\u7684\u7ee7\u627f\u65b9\u5f0f\uff1a public , private class Derived: [private] Base {...}; \u7f3a\u7701\u7ee7\u627f\u65b9\u5f0f\u662f private \u7ee7\u627f\u3002 class Derived: public Base {...}; \u57fa\u7c7b/\u7236\u7c7b - base class - \u88ab\u7ee7\u627f\u7684\u5df2\u6709\u7c7b \u6d3e\u751f\u7c7b/\u5b50\u7c7b/\u6269\u5c55\u7c7b - derived class - \u901a\u8fc7\u7ee7\u627f\u5f97\u5230\u7684\u65b0\u7c7b \u5b50\u7c7b\u5bf9\u8c61\u7684\u6784\u9020\u4e0e\u6790\u6784\u8fc7\u7a0b \u57fa\u7c7b\u4e2d\u7684\u6570\u636e\u6210\u5458\u901a\u8fc7\u7ee7\u627f\u6210\u4e3a\u5b50\u7c7b\u5bf9\u8c61\u7684\u4e00\u90e8\u5206\uff0c\u9700\u8981\u5728\u6784\u9020\u5b50\u7c7b\u5bf9\u8c61\u7684\u8fc7\u7a0b\u4e2d\u8c03\u7528\u79ef\u7d2f\u7684\u6784\u9020\u51fd\u6570\u6765\u521d\u59cb\u5316\u3002 \u82e5\u6ca1\u6709\u663e\u5f0f\u8c03\u7528\uff0c\u5219\u7f16\u8bd1\u5668\u4f1a\u81ea\u52a8\u751f\u6210\u4e00\u4e2a\u5bf9\u57fa\u7c7b\u7684\u9ed8\u8ba4\u6784\u9020\u51fd\u6570\u7684\u8c03\u7528 \u82e5\u91c7\u7528\u663e\u5f0f\u8c03\u7528\uff0c\u5219\u53ea\u80fd\u5728\u5b50\u7c7b\u6784\u9020\u51fd\u6570\u7684\u521d\u59cb\u5316\u5217\u8868\u4e2d\u8fdb\u884c \u5148\u6267\u884c\u57fa\u7c7b\u7684\u6784\u9020\u51fd\u6570\u6765\u521d\u59cb\u5316\u7ee7\u627f\u6765\u7684\u6570\u636e\uff0c\u518d\u6267\u884c\u5b50\u7c7b\u7684\u6784\u9020\u51fd\u6570\u3002 \u5bf9\u8c61\u6790\u6784\u65f6\uff0c\u5148\u6267\u884c\u5b50\u7c7b\u7684\u6790\u6784\u51fd\u6570\uff0c\u518d\u6267\u884c\u7531\u7f16\u8bd1\u5668\u81ea\u52a8\u8c03\u7528\u7684\u57fa\u7c7b\u7684\u6790\u6784\u51fd\u6570\u3002 \u7ee7\u627f\u57fa\u7c7b\u7684\u6784\u9020\u51fd\u6570 \u4ee5\u5982\u4e0b\u4ee3\u7801\u4e3a\u4f8b #include <iostream> using namespace std ; class Base { public : Base ( int _data ) : data ( _data ) { cout << \"Base::Base(\" << _data << \") \\n \" ; } private : int data ; }; class Derive : public Base { public : using Base :: Base ; void print () { cout << \"data = \" << data << endl ; } private : int data { 2020 }; }; int main () { Derive obj ( 356 ); obj . print (); return 0 ; } Derive \u4e2d\u4f7f\u7528 using Base::Base; \u5c06 Base \u4e2d\u7684\u6240\u6709\u6784\u9020\u51fd\u6570\u90fd\u7ee7\u627f\u4e86\u8fc7\u6765\u3002\u6545\u53ef\u4ee5\u8c03\u7528\u5e26\u4e00\u4e2a int \u578b\u53c2\u6570\u7684\u6784\u9020\u51fd\u6570\u3002 Base::Base(356) data = 2020 \u867d\u7136\u57fa\u7c7b\u6784\u9020\u51fd\u6570\u7684\u9ed8\u8ba4\u503c\u4e0d\u4f1a\u88ab\u5b50\u7c7b\u7ee7\u627f\uff0c\u4f46\u7531\u9ed8\u8ba4\u53c2\u6570\u5bfc\u81f4\u7684\u591a\u4e2a\u6784\u9020\u51fd\u6570\u7248\u672c\u90fd\u4f1a\u88ab\u5b50\u7c7b\u7ee7\u627f\u3002 \u5982\u679c\u57fa\u7c7b\u7684\u67d0\u4e2a\u6784\u9020\u51fd\u6570\u88ab\u58f0\u660e\u6210\u79c1\u6709\u6210\u5458\u51fd\u6570\uff0c\u5219\u4e0d\u80fd\u5728\u5b50\u7c7b\u4e2d\u58f0\u660e\u7ee7\u627f\u8be5\u6784\u9020\u51fd\u6570\u3002 \u5982\u679c\u5b50\u7c7b\u4f7f\u7528\u4e86\u7ee7\u627f\u57fa\u7c7b\u6784\u9020\u51fd\u6570\uff0c\u7f16\u8bd1\u5668\u5c31\u4e0d\u4f1a\u518d\u4e3a\u5b50\u7c7b\u751f\u6210\u9ed8\u8ba4\u6784\u9020\u51fd\u6570\u3002 \u51fd\u6570\u91cd\u5199 (override) \u5b50\u7c7b\u4e2d\u7684\u57fa\u7c7b\u6210\u5458 \u5b50\u7c7b\u5bf9\u8c61\u5305\u542b\u4ece\u57fa\u7c7b\u7ee7\u627f\u6765\u7684\u6570\u636e\u6210\u5458\uff0c\u5b83\u4eec\u6784\u6210\u4e86\u201c\u57fa\u7c7b\u5b50\u5bf9\u8c61\u201d\u3002 \u57fa\u7c7b\u4e2d\u7684\u79c1\u6709\u6210\u5458\uff0c\u4e0d\u5141\u8bb8\u5728\u5b50\u7c7b\u6210\u5458\u51fd\u6570\u4e2d\u88ab\u8bbf\u95ee\uff0c\u4e5f\u4e0d\u5141\u8bb8\u5b50\u7c7b\u7684\u5bf9\u8c61\u8bbf\u95ee\u5b83\u4eec\u3002 \u771f\u6b63\u4f53\u73b0\u201c\u57fa\u7c7b\u79c1\u6709\u201d\uff0c\u5bf9\u5b50\u7c7b\u4e5f\u4e0d\u5f00\u653e\u5176\u6743\u9650 \u57fa\u7c7b\u4e2d\u7684\u516c\u6709\u6210\u5458\uff1a \u82e5\u4f7f\u7528 public \u7ee7\u627f\u65b9\u5f0f\uff0c\u5219\u6210\u4e3a\u5b50\u7c7b\u7684\u516c\u6709\u6210\u5458\uff0c\u65e2\u53ef\u4ee5\u5728\u5b50\u7c7b\u6210\u5458\u4e2d\u8bbf\u95ee\uff0c\u4e5f\u53ef\u4ee5\u88ab\u5b50\u7c7b\u7684\u5bf9\u8c61\u8bbf\u95ee\uff1b \u82e5\u4f7f\u7528 private \u7ee7\u627f\u65b9\u5f0f\uff0c\u5219\u53ea\u80fd\u4f9b\u5b50\u7c7b\u6210\u5458\u51fd\u6570\u7684\u8bbf\u95ee\uff0c\u4e0d\u80fd\u88ab\u5b50\u7c7b\u5bf9\u8c61\u8bbf\u95ee\u3002 \u8003\u8651\u5982\u4e0b\u4ee3\u7801 #include <iostream> using namespace std ; class B { public : void f () { cout << \"in B::f()...\" << endl ; } }; class D1 : public B {}; class D2 : private B { public : void g () { cout << \"in D2::g(), calling f()...\" << endl ; f (); } }; int main () { cout << \"in main()...\" << endl ; D1 obj1 ; cout << \"calling obj1.f()...\" << endl ; obj1 . f (); D2 obj2 ; cout << \"calling obj2.g()...\" << endl ; obj2 . g (); return 0 ; } \u8f93\u51fa in main()... calling obj1.f()... in B::f()... calling obj2.g()... in D2::g(), calling f()... in B::f()... \u5982\u679c\u79c1\u6709\u7ee7\u627f\u7684\u5b50\u7c7b D2 \u8c03\u7528\u7236\u7c7b\u7684\u5171\u6709\u51fd\u6570\uff0c\u5219\u4f1a\u62a5\u9519\uff1a error: \u2018B\u2019 is not an accessible base of \u2018D2 \u8fd9\u91cc\u57fa\u7c7b\u63a5\u53e3\u4e0d\u8bb8\u5b50\u7c7b\u5bf9\u8c61\u8c03\u7528\u3002 \u5b50\u7c7b\u91cd\u5199\u57fa\u7c7b\u7684\u6210\u5458\u51fd\u6570 \u57fa\u7c7b\u5df2\u5b9a\u4e49\u7684\u6210\u5458\u51fd\u6570\uff0c\u5728\u5b50\u7c7b\u4e2d\u53ef\u4ee5\u91cd\u65b0\u5b9a\u4e49\uff0c\u8fd9\u88ab\u79f0\u4e3a\u201c\u51fd\u6570\u91cd\u5199\u201d\uff08override\uff09 \u91cd\u5199\u53d1\u751f\u65f6\uff0c\u57fa\u7c7b\u4e2d\u8be5\u6210\u5458\u51fd\u6570\u7684\u5176\u4ed6\u91cd\u8f7d\u51fd\u6570\u90fd\u5c06\u88ab\u5c4f\u853d\u6389\uff0c\u4e0d\u80fd\u63d0\u4f9b\u7ed9\u5b50\u7c7b\u5bf9\u8c61\u4f7f\u7528\u3002 \u53ef\u4ee5\u5728\u5b50\u7c7b\u4e2d\u901a\u8fc7 using \u7c7b\u540d::\u6210\u5458\u51fd\u6570\u540d; \u5728\u5b50\u7c7b\u4e2d\u201c=\u6062\u590d\u201d\u6307\u5b9a\u7684\u57fa\u7c7b\u6210\u5458\u51fd\u6570\uff08\u53bb\u6389\u5c4f\u853d\uff09\uff0c\u4f7f\u4e4b\u91cd\u65b0\u53ef\u7528\u3002 \u8003\u8651\u5982\u4e0b\u4ee3\u7801 #include <iostream> using namespace std ; class T {}; class B { public : void f () { cout << \"B::f() \\n \" ; } void f ( int i ) { cout << \"B::f(\" << i << \") \\n \" ; } void f ( double d ) { cout << \"B::f(\" << d << \") \\n \" ; } void f ( T ) { cout << \"B::f(T) \\n \" ; } }; class D1 : public B { public : void f ( int i ) { cout << \"D1::f(\" << i << \") \\n \" ; } }; int main () { D1 d ; d . f ( 10 ); d . f ( 4.9 ); // d.f(); // d.f(T()) }; \u6ce8\u610f d.f(4.9); \u8fd9\u4e00\u53e5\u7f16\u8bd1\u4f1a\u51fa\u8b66\u544a\uff0c\u7f16\u8bd1\u5668\u6267\u884c\u5f3a\u5236\u7c7b\u578b\u8f6c\u6362\u4f7f\u7528\u6574\u578b\u53c2\u6570\u7684\u51fd\u6570\u7248\u672c\u3002 \u800c\u88ab\u6ce8\u91ca\u7684\u4e24\u4e2a\u8bed\u53e5\u5219\u4f1a\u51fa\u73b0\u7f16\u8bd1\u9519\u8bef\uff0c\u56e0\u4e3a\u91cd\u5199\u5bfc\u81f4\u5176\u4ed6\u91cd\u8f7d\u51fd\u6570\u88ab\u5c4f\u853d\u6389 \u8f93\u51fa D1::f(10) D1::f(4) \u4f7f\u7528 using \u6062\u590d\u57fa\u7c7b\u51fd\u6570 #include <iostream> using namespace std ; class T {}; class B { public : void f () { cout << \"B::f() \\n \" ; } void f ( int i ) { cout << \"B::f(\" << i << \") \\n \" ; } void f ( double d ) { cout << \"B::f(\" << d << \") \\n \" ; } void f ( T ) { cout << \"B::f(T) \\n \" ; } }; class D1 : public B { public : using B :: f ; void f ( int i ) { cout << \"D1::f(\" << i << \") \\n \" ; } }; int main () { D1 d ; d . f ( 10 ); d . f ( 4.9 ); d . f (); d . f ( T ()); return 0 ; }; \u8f93\u51fa D1::f(10) B::f(4.9) B::f() B::f(T) \u865a\u51fd\u6570 \u5411\u4e0a\u6620\u5c04\u548c\u5411\u4e0b\u6620\u5c04 \u5b50\u7c7b\u5bf9\u8c61\u8f6c\u6362\u6210\u57fa\u7c7b\u5bf9\u8c61\uff0c\u79f0\u4e3a\u5411\u4e0a\u6620\u5c04\u3002\u800c\u57fa\u7c7b\u5bf9\u8c61\u8f6c\u6362\u4e3a\u5b50\u7c7b\u5bf9\u8c61\uff0c\u6210\u4e3a\u5411\u4e0b\u6620\u5c04\u3002 \u5411\u4e0a\u6620\u5c04\u53ef\u4ee5\u7531\u7f16\u8bd1\u5668\u81ea\u52a8\u5b8c\u6210\uff0c\u662f\u4e00\u79cd\u9690\u5f0f\u7684\u81ea\u52a8\u7c7b\u578b\u8f6c\u6362\u3002 \u6240\u6709\u63a5\u53d7\u57fa\u7c7b\u5bf9\u8c61\u7684\u5730\u65b9\uff08\u5982\u51fd\u6570\u53c2\u6570\uff09\uff0c\u90fd\u53ef\u4ee5\u4f7f\u7528\u5b50\u7c7b\u5bf9\u8c61\uff0c\u7f16\u8bd1\u5668\u4f1a\u81ea\u52a8\u5c06\u5b50\u7c7b\u5bf9\u8c61\u8f6c\u6362\u4e3a\u57fa\u7c7b\u5bf9\u8c61\u4ee5\u4fbf\u4f7f\u7528\u3002 \u5728\u5982\u4e0b\u4ee3\u7801\u4e2d\uff0c\u5b50\u7c7b\u91cd\u5199\u4e86\u57fa\u7c7b\u7684 print \u51fd\u6570\uff0c\u5c06\u5b50\u7c7b\u5bf9\u8c61\u4f20\u7ed9\u4ee5\u57fa\u7c7b\u4f5c\u4e3a\u5f62\u53c2\u7684\u51fd\u6570\uff0c\u5b50\u7c7b\u88ab\u9690\u5f0f\u8f6c\u6362\u4e3a\u57fa\u7c7b\uff0c\u6545\u51fd\u6570\u5185\u8c03\u7528\u7684\u662f\u57fa\u7c7b\u7684 print \u51fd\u6570\u3002 #include <iostream> using namespace std ; class Base { public : void print () { cout << \"Base::print()\" << endl ; } }; class Derive : public Base { public : void print () { cout << \"Derive::print()\" << endl ; } }; void fun ( Base obj ) { obj . print (); } int main () { Derive d ; d . print (); fun ( d ); return 0 ; } \u8f93\u51fa Derive::print() Base::print() \u865a\u51fd\u6570 \u5bf9\u4e8e\u88ab\u5b50\u7c7b\u91cd\u5199\u7684\u6210\u5458\u51fd\u6570\uff0c\u82e5\u5b83\u5728\u57fa\u7c7b\u4e2d\u88ab\u58f0\u660e\u4e3a\u865a\u51fd\u6570\uff08\u5982\u4e0b\u6240\u793a\uff09\uff0c\u5219\u901a\u8fc7\u79ef\u7d2f\u6307\u9488\u6216\u5f15\u7528\u8c03\u7528\u8be5\u51fd\u6570\u6210\u5458\u65f6\uff0c\u7f16\u8bd1\u5668\u5c06\u6839\u636e\u6240\u6307\uff08\u6216\u5f15\u7528\uff09\u5bf9\u8c61\u7684\u5b9e\u9645\u7c7b\u578b\u51b3\u5b9a\u662f\u8c03\u7528\u79ef\u7d2f\u4e2d\u7684\u51fd\u6570\uff0c\u8fd8\u662f\u8c03\u7528\u5b50\u7c7b\u91cd\u5199\u7684\u51fd\u6570\u3002 class Base { public : virtual \u8fd4\u56de\u7c7b\u578b \u51fd\u6570\u540d ( \u5f62\u53c2 ); ... }; \u82e5\u67d0\u6210\u5458\u51fd\u6570\u5728\u57fa\u7c7b\u4e2d\u88ab\u58f0\u660e\u4e3a\u865a\u51fd\u6570\uff0c\u5f53\u5b50\u7c7b\u91cd\u5199\u5b83\u65f6\uff0c\u65e0\u8bba\u662f\u5426\u58f0\u660e\u4e3a\u865a\u51fd\u6570\uff0c\u8be5\u6210\u5458\u51fd\u6570\u4ecd\u7136\u662f\u865a\u51fd\u6570\u3002 \u5c06\u4e0a\u4e00\u8282\u7684\u4f8b\u5b50\u4e2d\u57fa\u7c7b\u7684 print \u51fd\u6570\u5b9a\u4e49\u4e3a\u865a\u51fd\u6570\uff0c\u800c\u51fd\u6570 fun \u7684\u5f62\u53c2\u6539\u4e3a\u57fa\u7c7b\u7684\u5f15\u7528\u7c7b\u578b\uff0c\u5219\u8c03\u7528\u7684\u5c31\u662f\u865a\u51fd\u6570\u5728\u5b50\u7c7b\u4e2d\u7684\u5b9e\u73b0\u3002 #include <iostream> using namespace std ; class Base { public : virtual void print () { cout << \"Base::print()\" << endl ; } }; class Derive : public Base { public : void print () { cout << \"Derive::print()\" << endl ; } }; void fun ( Base & obj ) { obj . print (); } int main () { Derive d ; d . print (); fun ( d ); return 0 ; } \u8f93\u51fa Derive::print() Derive::print() \u865a\u6790\u6784\u51fd\u6570 \u57fa\u7c7b\u7684\u6790\u6784\u51fd\u6570\u603b\u662f\u8981\u88ab\u58f0\u660e\u6210 virtual \u7684\uff0c\u8fd9\u6837\u624d\u80fd\u4fdd\u8bc1\u5b50\u7c7b\u5b9a\u4e49\u7684\u6790\u6784\u51fd\u6570\u603b\u80fd\u88ab\u6267\u884c\u3002 \u4e8b\u5b9e\u4e0a\uff0c\u6700\u597d\u7684\u505a\u6cd5\u662f\uff1a\u4efb\u4f55\u7c7b\u7684\u6790\u6784\u51fd\u6570\u90fd\u5e94\u8be5\u88ab\u58f0\u660e\u6210 virtual \u7684\uff0c\u56e0\u4e3a\u8c01\u53c8\u80fd\u4fdd\u8bc1\u8fd9\u4e2a\u7c7b\u4e0d\u4f1a\u88ab\u5176\u4ed6\u7684\u7c7b\u7ee7\u627f\u5462\uff1f #include <iostream> using namespace std ; class B { public : virtual void show () { cout << \"B.show() \\n \" ; } virtual ~ B () { cout << \"~B() \\n \" ; } }; class D : public B { public : void show () { cout << \"D.show() \\n \" ; } ~ D () { cout << \"~D() \\n \" ; } }; void test ( B * ptr ) { ptr -> show (); } int main () { B * ptr = new D ; test ( ptr ); delete ptr ; return 0 ; } \u8f93\u51fa D.show() ~D() ~B() \u4ece\u8f93\u51fa\u53ef\u89c1\u6790\u6784\u51fd\u6570\u7684\u8c03\u7528\u987a\u5e8f\u662f \u5148\u8c03\u7528\u5b50\u7c7b\u7684\u6790\u6784\u51fd\u6570\uff0c\u518d\u8c03\u7528\u57fa\u7c7b\u7684\u6790\u6784\u51fd\u6570 \u3002 \u5982\u679c\u5220\u9664\u57fa\u7c7b\u6790\u6784\u51fd\u6570\u524d\u7684 virtual \u5173\u952e\u5b57\uff0c\u5219\u8f93\u51fa\u4e3a D.show() ~B() \u6b64\u65f6\u5982\u679c\u5b50\u7c7b\u4e2d\u72ec\u6709\u7684\u6570\u636e\u6210\u5458\uff0c\u5219\u4ed6\u4eec\u4e0d\u4f1a\u88ab\u91ca\u653e\uff0c\u8fdb\u800c\u5bfc\u81f4\u5185\u5b58\u6cc4\u9732\u3002 \u7981\u6b62\u91cd\u5199\u7684\u865a\u51fd\u6570 final (c++ 11\u5f15\u5165) \u4f7f\u7528 final \u7ba1\u554a\u67b6\u5b50\u4fee\u9970\u7684\u865a\u51fd\u6570\uff0c\u5b50\u7c7b\u4e0d\u53ef\u5bf9\u5b83\u8fdb\u884c\u91cd\u5199 \u2014\u2014 \u6539\u53d8\u51fd\u6570\u7684\u5b9a\u4e49\u3002 \u5728\u6d3e\u751f\u8fc7\u7a0b\u4e2d\uff0c final \u53ef\u4ee5\u518d\u7ee7\u627f\u5173\u7cfb\u94fe\u7684 \u4e2d\u9014 \u8fdb\u884c\u8bbe\u5b9a\uff0c\u7981\u6b62\u540e\u7eed\u5b50\u7c7b\u5bf9\u6307\u5b9a\u865a\u51fd\u6570\u91cd\u5199\u3002 \u4e0b\u5c5e\u4ee3\u7801\u4e2d\uff0c class C \u7684\u5b9e\u73b0\u662f\u65e0\u6cd5\u901a\u8fc7\u7f16\u8bd1\u7684\u3002 class A { public : virtual void fun () = 0 ; }; class B : public A { public : void fun () final ; }; class C : public B { public : void fun (); }; class A \u4e2d\u7684 virtual void fun() = 0; \u5c06 fun() \u5b9a\u4e49\u4e3a\u4e00\u4e2a \u7eaf\u865a\u51fd\u6570 \u3002 A \u7531\u6b64\u6210\u4e3a\u4e00\u4e2a \u62bd\u8c61\u7c7b \u3002 C++\u4e2d\u62bd\u8c61\u7c7b\u4e0d\u80fd\u7528\u4e8e\u5b9a\u4e49\u5bf9\u8c61\uff0c\u8fd9\u6837\u7684\u7c7b\u4e00\u822c\u7528\u4e8e \u5b9a\u4e49\u63a5\u53e3 \u3002 \u81ea\u52a8\u7c7b\u578b\u8f6c\u6362 \u65b9\u6cd5\u4e00 - \u5728\u6e90\u7c7b\u4e2d\u5b9a\u4e49\u201c\u76ee\u6807\u7c7b\u578b\u8f6c\u6362\u8fd0\u7b97\u7b26\u201d #include <iostream> using namespace std ; class Dst { public : Dst () { cout << \"Dst::Dst()\" << endl ; } }; class Src { public : Src () { cout << \"Src::operator Dst() called\" << endl ; } operator Dst () const { cout << \"Src::operator Dst() called\" << endl ; return Dst (); } }; \u65b9\u6cd5\u4e8c - \u5728\u76ee\u6807\u7c7b\u4e2d\u5b9a\u4e49\u201c\u6e90\u7c7b\u5bf9\u8c61\u505a\u53c2\u6570\u7684\u6784\u9020\u51fd\u6570\u201d #include <iostream> using namespace std ; class Src ; class Dst { public : Dst () { cout << \"Dst::Dst()\" << endl ; } Dst ( const Src & s ) { cout << \"Dst::Dst(const Src&)\" << endl ; } }; class Src { public : Src () { cout << \"Src::Src()\" << endl ; } }; \u6ce8\uff1a class Src; \u8fd9\u4e00\u884c\u662f\u4e00\u4e2a\u524d\u7f6e\u7684\u7c7b\u578b\u58f0\u660e\uff0c\u56e0\u4e3a\u5728 Dst \u7684\u5b9a\u4e49\u4e2d\u8981\u7528\u5230 Src \u7c7b\u3002 \u81ea\u52a8\u7c7b\u578b\u8f6c\u6362\u4e3e\u4f8b \u6d4b\u8bd5\u4ee3\u7801\u5982\u4e0b\uff08\u9690\u5f0f\u8f6c\u6362\uff09 void Func ( Dst d ) {} int main () { Src s ; Dst d1 ( s ); // \u8fd9\u662f\u76f4\u63a5\u6784\u9020\uff0c\u4e0d\u662f\u7c7b\u578b\u8f6c\u6362 Dst d2 = s ; // \u81ea\u52a8\u7c7b\u578b\u8f6c\u6362\uff0c\u4e0d\u662f\u62f7\u8d1d\u6784\u9020\u51fd\u6570 Func ( s ); // \u81ea\u52a8\u7c7b\u578b\u8f6c\u6362 return 0 \uff1b } \u6ce8\u610f\uff1a\u4e24\u79cd\u81ea\u5b9a\u4e49\u7c7b\u578b\u8f6c\u6362\u7684\u65b9\u6cd5\u4e0d\u80fd\u540c\u65f6\u4f7f\u7528\uff0c\u53ea\u6709\u5728\u4e0a\u8ff0\u65b9\u6cd5\u4e00\u548c\u65b9\u6cd5\u4e8c\u4f7f\u7528\u4e14\u4f7f\u7528\u4e00\u4e2a\u7684\u524d\u63d0\u4e0b\u624d\u80fd\u7f16\u8bd1\u901a\u8fc7\u3002 \u7981\u6b62\u81ea\u52a8\u7c7b\u578b\u8f6c\u6362 \u65b9\u6cd5\u4e00 - explicit \u5173\u952e\u5b57 #include <iostream> using namespace std ; class Src ; class Dst { public : Dst () { cout << \"Dst::Dst()\" << endl ; } explicit // <1> \u4e0d\u51c6\u7528\u4e8e\u81ea\u52a8\u7c7b\u578b\u8f6c\u6362 Dst ( const Src & s ) { cout << \"Dst::Dst(const Src&)\" << endl ; } }; class Src { public : Src () { cout << \"Src::Src()\" << endl ; } explicit // <2> \u4e0d\u51c6\u7528\u4e8e\u81ea\u52a8\u7c7b\u578b\u8f6c\u6362 operator Dst () const { cout << \"Src::operator Dst() called\" << endl ; return Dst (); } }; <1> - \u8be5\u51fd\u6570\u53ea\u7528\u4e8e\u6784\u9020\u51fd\u6570\uff0c\u4e0d\u7528\u4e8e\u81ea\u52a8\u7c7b\u578b\u8f6c\u6362\uff08\u4e0d\u80fd\u81ea\u52a8\u8c03\u7528\uff09 <2> - \u8be5\u51fd\u6570\u53ea\u7528\u4e8e\u7c7b\u578b\u8f6c\u6362\uff0c\u4e0d\u7528\u4e8e\u81ea\u52a8\u7c7b\u578b\u8f6c\u6362\uff08\u4e0d\u80fd\u81ea\u52a8\u8c03\u7528\uff09 \u4e3a\u6b64\uff0c\u5982\u60f3\u8ba9\u4e0b\u65b9\u4ee3\u7801\u901a\u8fc7\uff0c\u4e0a\u65b9\u4ee3\u7801\u4e2d\u4e24\u5904 explicit \u5fc5\u987b\u4fdd\u7559\u4e14\u4ec5\u4fdd\u7559\u4e00\u5904\u3002 void Func ( Dst d ) {} int main () { Src s ; Dst d1 ( s ); Dst d2 = s ; Func ( s ); return 0 ; } \u65b9\u6cd5\u4e8c - =delete \u9650\u5b9a (C++ 11 \u5f15\u5165) \u4f7f\u7528 =delete \u4fee\u9970\u7684\u6210\u5458\u51fd\u6570\uff0c\u4e0d\u5141\u8bb8\u88ab\u8c03\u7528\u3002 #include <iostream> using namespace std ; class T { public : T ( int ) {} T ( char ) = delete ; // \u53ef\u6d88\u9664\u81ea\u52a8\u7c7b\u578b\u8f6c\u6362\u5e26\u6765\u7684\u9690\u60a3\uff0c\u5982\u6ca1\u6709` = delete`\u4fee\u9970\u7b26\uff0c\u5219\u4e3b\u51fd\u6570\u4e2d\u7684\u8bed\u53e5\u90fd\u80fd\u7f16\u8bd1\u901a\u8fc7\u3002 }; void Fun ( T t ) {} int main () { Fun ( 1 ); // Fun('X'); \u81ea\u52a8\u7c7b\u578b\u8f6c\u6362\u5931\u8d25\uff0c\u7f16\u8bd1\u4e0d\u901a\u8fc7 T ci ( 1 ); // T cc('X'); \u81ea\u52a8\u7c7b\u578b\u8f6c\u6362\u5931\u8d25\uff0c\u7f16\u8bd1\u4e0d\u901a\u8fc7 return 0 ; } =delete \u4fee\u9970\u4e00\u4e2a\u51fd\u6570 \u548c \u4e0d\u5199\u8fd9\u4e2a\u51fd\u6570 \u7684\u533a\u522b: \u5f3a\u5236\u7c7b\u578b\u8f6c\u6362\uff08\u663e\u5f0f\u8f6c\u6362\uff09 dynamic_cast<Dst_type>(Src_var) - \u7528\u4e8e\u5728\u7c7b\u7684\u96c6\u6210\u4f53\u7cfb\u4e2d\u505a\u8f6c\u6362 Src_var \u5fc5\u987b\u662f\u5f15\u7528\u6216\u6307\u9488\u7c7b\u578b\uff0c Dst_Type \u7c7b\u4e2d\u542b\u6709\u865a\u51fd\u6570\uff0c\u5426\u5219\u4f1a\u6709\u7f16\u8bd1\u9519\u8bef \u82e5\u76ee\u6807\u7c7b\u4e0e\u539f\u7c7b\u4e4b\u95f4\u6ca1\u6709\u53ca\u9648\u9aa8\u5e72\u897f\uff0c\u8f6c\u6362\u5931\u8d25\uff0c\u8fd4\u56de\u7a7a\u6307\u9488\uff08\u6ce8\uff1a\u5931\u8d25\u4e0d\u5bfc\u81f4\u8fd0\u884c\u5d29\u6e83\uff09 static_cast<Dst_Type>(Src_var) \u57fa\u7c7b\u5bf9\u8c61\u4e0d\u80fd\u8f6c\u6362\u6210\u5b50\u7c7b\u5bf9\u8c61\uff0c\u4f46\u57fa\u7c7b\u6307\u9488\u53ef\u4ee5\u8f6c\u6362\u6210\u5b50\u7c7b\u6307\u9488 \u5b50\u7c7b\u5bf9\u8c61\uff08\u6307\u9488\uff09\u53ef\u4ee5\u8f6c\u6362\u6210\u57fa\u7c7b\u5bf9\u8c61\uff08\u6307\u9488\uff09 \u6ca1\u6709\u7ee7\u627f\u5173\u7cfb\u7684\u7c7b\u4e4b\u95f4\uff0c\u5fc5\u987b\u5177\u6709\u8f6c\u6362\u9014\u5f84\u624d\u80fd\u8fdb\u884c\u8f6c\u6362\uff08\u81ea\u5b9a\u4e49\u6216\u8005\u8bed\u8a00\u8bed\u6cd5\u539f\u751f\u652f\u6301\uff09 \u4ee5\u5982\u4e0b\u4ee3\u7801\u4e3a\u4f8b #include <iostream> using namespace std ; class B { public : virtual void f () {} }; class D : public B {}; class E {}; int main () { D d1 ; B b1 ; // d1 = static_cast<D>(b1); /// Error: \u4ece\u57fa\u7c7b\u65e0\u6cd5\u8f6c\u6362\u56de\u5b50\u7c7b b1 = static_cast < B > ( d1 ); /// OK: \u53ef\u4ee5\u4ece\u5b50\u7c7b\u8f6c\u6362\u5230\u57fa\u7c7b // b1 - dynamic_cast<B>(d1); /// ERROR: \u88ab\u8f6c\u6362\u7684\u5fc5\u987b\u662f\u5f15\u7528\u6216\u6307\u9488 B * pb1 = new B (); D * pd1 = static_cast < D *> ( pb1 ); if ( pd1 ) { cout << \"static_cast, B* --> D*: OK\" << endl ; } pd1 = dynamic_cast < D *> ( pb1 ); if ( pd1 ) { cout << \"dynamic_cast, B* --> D*: OK\" << endl ; } D * pd2 = new D (); B * pb2 = static_cast < B *> ( pd2 ); if ( pb2 ) { cout << \"static_cast, D* --> B*: OK\" << endl ; } pb2 = dynamic_cast < B *> ( pd2 ); if ( pb2 ) { cout << \"dynamic_cast, D* --> B*: OK\" << endl ; } E * pe = dynamic_cast < E *> ( pb1 ); if ( ! pe ) { cout << \"dynamic_cast, B* --> E*: FAILED\" << endl ; } // pe = static_cast<E*>(pb1); /// ERROR: \u6ca1\u6709\u7ee7\u627f\u5173\u7cfb\u4e0d\u80fd\u8f6c\u6362 // E e = static_cast<E>(b1); /// ERROR\uff1a\u6ca1\u6709\u63d0\u4f9b\u8f6c\u6362\u9014\u5f84 return 0 ; } \u8f93\u51fa static_cast, B* --> D*: OK static_cast, D* --> B*: OK dynamic_cast, D* --> B*: OK dynamic_cast, B* --> E*: FAILED \u51fd\u6570\u6a21\u677f \u6709\u4e9b\u7b97\u6cd5\u5b9e\u73b0\u4e0e\u7c7b\u578b\u65e0\u5173\uff0c\u6240\u4ee5\u53ef\u4ee5\u5c06\u51fd\u6570\u7684\u53c2\u6570\u7c7b\u578b\u4e5f\u5b9a\u4e49\u4e3a\u4e00\u79cd\u7279\u6b8a\u7684\u201c\u53c2\u6570\u201d\uff0c\u8fd9\u6837\u5c31\u5f97\u5230\u4e86\u201c\u51fd\u6570\u6a21\u677f\u201d\u3002 \u5b9a\u4e49\u51fd\u6570\u6a21\u677f\u7684\u65b9\u6cd5 template < typename T > \u8fd4\u56de\u7c7b\u578b \u51fd\u6570\u540d ( \u51fd\u6570\u53c2\u6570 ) \uff1b \u4f8b\u5982\uff0c\u4efb\u610f\u4e24\u4e2a\u53d8\u91cf\u76f8\u52a0\u7684\u201c\u51fd\u6570\u6a21\u677f\u201d template < typename T > T sum ( T a , T b ) { return a + b ; } \u51fd\u6570\u6a21\u677f\u5728\u8c03\u7528\u65f6\uff0c\u56e0\u4e3a\u7f16\u8bd1\u5668\u80fd\u81ea\u52a8\u63a8\u5bfc\u51fa\u5b9e\u9645\u53c2\u6570\u7684\u7c7b\u578b\uff0c\u6240\u4ee5\uff0c\u5f62\u5f0f\u4e0a\u8c03\u7528\u4e00\u4e2a\u51fd\u6570\u6a21\u677f\u4e0e\u666e\u901a\u51fd\u6570\u6ca1\u6709\u533a\u522b\uff0c\u5982 int main () { int a = 3 , b = 4 ; cout << sum ( a , b ); float c = 1.3 , d = 1.9 ; cout << sum ( c , d ); } \u51fd\u6570\u6a21\u677f\u53c2\u6570\u4e5f\u53ef\u4ee5\u8d4b\u9ed8\u8ba4\u503c\uff08\u7f3a\u7701\u503c\uff09\uff0c\u5982 #include <iostream> using namespace std ; template < typename T0 = float , typename T1 , typename T2 = float , typename T3 , typename T4 > T0 func ( T1 v1 , T2 v2 = 0 , T3 v3 , T4 v4 ) {...} func ( 1 , 2 , 3 , 4 ); func ( 'a' , 'b' , \"cde\" , 5 ); \u7c7b\u6a21\u677f \u5728\u5b9a\u4e49\u7c7b\u65f6\u4e5f\u53ef\u4ee5\u5c06\u4e00\u4e9b\u7c7b\u578b\u4fe1\u606f\u62bd\u53d6\u51fa\u6765\uff0c\u7528\u6a21\u677f\u53c2\u6570\u6765\u66ff\u6362\uff0c\u4ece\u800c\u4f7f\u7c7b\u66f4\u5177\u6709\u901a\u7528\u6027\u3002\u8fd9\u79cd\u7c7b\u88ab\u79f0\u4e3a\u201c\u7c7b\u6a21\u677f\u201d\u3002 template < typename T > class A { public : void print () { cout << data << endl ; } private : T data ; }; \u7c7b\u6a21\u677f \u2192 \u7c7b \u2192 \u5bf9\u8c61 \u7c7b\u6a21\u677f\u7684\u201c\u6a21\u677f\u53c2\u6570\u201d \u7c7b\u578b\u53c2\u6570\uff1a\u4f7f\u7528 typename \u6216 class \u6807\u8bb0 \u975e\u7c7b\u578b\u53c2\u6570\uff1a\u6574\u6570\uff0c\u679a\u4e3e\uff0c\u6307\u9488\uff08\u6307\u5411\u5bf9\u8c61\u6216\u51fd\u6570\uff09\uff0c\u5f15\u7528\uff08\u5f15\u7528\u5bf9\u8c61\u6216\u5f15\u7528\u51fd\u6570\uff09\u3002\u5176\u4e2d\u6574\u6570\u7c7b\u578b\u662f\u6bd4\u8f83\u5e38\u7528\u7684\uff0c\u5982 template < typename T , unsigned size > class Array { T elems [ size ]; ... }; Array < char , 10 > array ; \u6a21\u677f\u53c2\u6570\u662f\u53e6\u4e00\u4e2a\u7c7b\u6a21\u677f\uff0c\u5982\u4e0b\u6240\u793a\uff1a template < typename T , template < typename TT0 , typename TT1 > class A > struct Foo { A < T , T > bar ; }; \u6210\u5458\u51fd\u6570\u6a21\u677f \u666e\u901a\u7c7b\u4e2d\u5b9a\u4e49\u6210\u5458\u51fd\u6570\u6a21\u677f class NormalClass { public : int value ; template < typename T > void set ( T const & v ) { value = int ( v ); } template < typename T > T get (); }; template < typename T > T NormalClass :: get () { return valuel ; } \u7c7b\u6a21\u677f\u4e2d\u5b9a\u4e49\u6210\u5458\u51fd\u6570\u6a21\u677f template < typename T0 > class A { public : T0 value ; template < typename T1 > void set ( T1 const & v ) { value = T0 ( v ); } template < typename T1 > T1 get (); }; template < typename T0 > template < typename T1 > T1 A :: get () { return T1 ( value ); } \u5bf9\u4e8e\u7c7b\u6a21\u677f\u5916\u9762\u5b9a\u4e49\u7684\u6210\u5458\u51fd\u6570\u6a21\u677f\uff0c\u4f1a\u62a5\u7f16\u8bd1\u9519\u8bef % g++ main.cpp -std=c++11 -o main main.cpp:16:4: error: \u2018template<class T0> class A\u2019 used without template parameters T1 A::get() { ^ main.cpp:16:4: error: too many template-parameter-lists \u6a21\u677f\u7279\u5316 \u6a21\u677f\u53c2\u6570\u7684\u5177\u4f53\u5316/\u7279\u6b8a\u5316 \u6709\u65f6\uff0c\u6709\u4e9b\u7c7b\u578b\u5e76\u4e0d\u9002\u7528\uff0c\u5219\u9700\u8981\u5bf9\u6a21\u677f\u8fdb\u884c\u7279\u6b8a\u5316\u5904\u7406\uff0c\u8fd9\u79f0\u4e3a\u201c\u6a21\u677f\u7279\u5316\u201d\u3002 \u5bf9\u4e8e\u51fd\u6570\u6a21\u677f\uff0c\u5982\u679c\u6709\u591a\u4e2a\u6a21\u677f\u53c2\u6570\uff0c\u5219\u7279\u5316\u65f6\u5fc5\u987b\u63d0\u4f9b\u6240\u6709\u53c2\u6570\u7684\u7279\u4f8b\u7c7b\u578b\uff0c \u4e0d\u80fd\u90e8\u5206\u7279\u5316 \u3002 \u5982 char* Sum(char* char*); \u5728\u51fd\u6570\u540d\u540e\u7528<>\u62ec\u53f7\u6269\u8d77\u5177\u4f53\u7c7b\u578b template <> char * Sum < char *> ( char * a , char * b ) {...} \u7531\u7f16\u8bd1\u5668\u63a8\u5bfc\u51fa\u5177\u4f53\u7c7b\u578b\uff0c\u51fd\u6570\u540d\u4e3a\u666e\u901a\u5f62\u5f0f template <> char * Sum ( char * a , char * b ) {...} \u6a21\u677f\u7684\u90e8\u5206\u7279\u5316\uff08\u504f\u7279\u5316\uff09 \u5bf9\u4e8e\u7c7b\u6a21\u677f\uff0c\u5141\u8bb8\u90e8\u5206\u7279\u5316\uff0c\u5373\u90e8\u5206\u9650\u5236\u6a21\u677f\u7684\u901a\u7528\u6027\uff0c\u5982\uff1a // \u901a\u7528\u6a21\u677f\u7c7b template < class T1 , class T2 > class A {...}; // \u90e8\u5206\u7279\u5316\u7684\u6a21\u677f\u7c7b\uff1a\u7b2c\u4e8c\u4e2a\u7c7b\u578b\u53c2\u6570\u6307\u5b9a\u4e3a int template < class T1 > class A < T1m int > {...}; \u82e5\u6307\u5b9a\u6240\u6709\u7c7b\u578b\uff0c\u5219<>\u5185\u5c06\u4e3a\u7a7a tempalte <> class A < int , int > {...}; \u51fd\u6570\u6a21\u677f\u7279\u5316\u793a\u4f8b #include <bits/stdc++.h> using namespace std ; template < typename T > T Sum ( T a , T b ) { return a + b ; } template <> char * Sum ( char * a , char * b ) { char * p = new char [ strlen ( a ), strlen ( b ) + 1 ]; strcpy ( p , a ); strcpy ( p + strlen ( a ), b ); return p ; } int main () { cout << Sum ( 3 , 4 ) << ' ' << Sum ( 5.1 , 13.8 ) << endl ; char str1 [] = \"Hello, \" , str2 [] = \"world\" ; cout << Sum ( str1 , str2 ) << endl ; return 0 ; } \u8f93\u51fa 7 18.9 Hello, world \u7c7b\u6a21\u677f\u7279\u5316\u793a\u4f8b #include <bits/stdc++.h> using namespace std ; template < typename T > class Sum { public : Sum ( T op1 , T op2 ) : a ( op1 ), b ( op2 ) {} T DoIT () { return a + b ; } private : T a , b ; }; template <> class Sum < char *> { public : Sum ( char * s1 , char * s2 ) : str1 ( s1 ), str2 ( s2 ) {} char * DoIT () { char * tmp = new char [ strlen ( str1 ) + strlen ( str2 ) + 1 ]; strcpy ( tmp , str1 ); strcat ( tmp + strlen ( str1 ), str2 ); return tmp ; } private : char * str1 , * str2 ; }; int main () { Sum < int > obj1 ( 3 , 4 ); cout << obj1 . DoIT () << endl ; char s1 [] = \"Hello\" , s2 [] = \"THU\" ; Sum < char *> obj2 ( s1 , s2 ); cout << obj2 . DoIT () << endl ; return 0 ; } \u8f93\u51fa\uff1a 7 HelloTHU","title":"\u57fa\u7840\u68b3\u7406"},{"location":"languages/cpp/basic/#c","text":"","title":"C++\u57fa\u7840"},{"location":"languages/cpp/basic/#_1","text":"","title":"\u53d8\u91cf\u5b9a\u4e49"},{"location":"languages/cpp/basic/#auto","text":"\u7531\u7f16\u8bd1\u5668\u6839\u636e\u4e0a\u4e0b\u6587\u81ea\u52a8\u786e\u5b9a\u53d8\u91cf\u7c7b\u578b\uff0c\u5982\uff1a auto i = 3 ; auto f = 4.0f ;","title":"auto\u53d8\u91cf"},{"location":"languages/cpp/basic/#_2","text":"\u6307\u9488\u53d8\u91cf\u6240\u6307\u5185\u5b58\u53ef\u4ee5\u901a\u8fc7 new/delete \u8fd0\u7b97\u7b26\u5728\u7a0b\u5e8f\u8fd0\u884c\u65f6\u52a8\u6001\u751f\u6210\u548c\u5220\u9664\uff0c\u5982\uff1a int * ptr = new int ; int * array = new int [ 10 ]; delete ptr ; delete [] array ;","title":"\u6307\u9488\u53d8\u91cf\u7684\u52a8\u6001\u751f\u6210\u548c\u5220\u9664"},{"location":"languages/cpp/basic/#_3","text":"\u5177\u540d\u53d8\u91cf\u7684\u522b\u540d\uff1a\u7c7b\u578b\u540d& \u5f15\u7528\u540d \u53d8\u91cf\u540d int v0 ; int & v1 = v0 ; \u8fd9\u91cc v1 \u662f v0 \u7684\u5f15\u7528\uff0c\u4ed6\u4eec\u5728\u5185\u5b58\u4e2d\u662f\u540c\u4e00\u5355\u5143\u7684\u4e24\u4e2a\u4e0d\u540c\u540d\u5b57 \u5f15\u7528\u5fc5\u987b\u5728\u5b9a\u4e49\u65f6\u8fdb\u884c\u521d\u59cb\u5316\uff08\u8d4b\u521d\u503c\uff09\u3002 \u88ab\u5f15\u7528\u53d8\u91cf\u540d\u53ef\u4ee5\u662f\u7ed3\u6784\u53d8\u91cf\u6210\u5458\uff0c\u5982 s.m \u3002 \u51fd\u6570\u53c2\u6570\u53ef\u4ee5\u662f\u5f15\u7528\u7c7b\u578b\uff0c\u8868\u793a\u51fd\u6570\u7684\u5f62\u5f0f\u53c2\u6570\u4e0e\u5b9e\u9645\u53c2\u6570\u662f\u540c\u4e00\u4e2a\u53d8\u91cf\uff0c\u6539\u53d8\u5f62\u53c2\u5c06\u6539\u53d8\u5b9e\u53c2\u3002 \u5982\u8c03\u7528\u4ee5\u4e0b\u51fd\u6570\u5c06\u4ea4\u6362\u5b9e\u53c2\u503c\uff1a void swap ( int & a , int & b ) { int tmp = b ; b = a ; a = tmp ; } \u51fd\u6570\u7684\u8fd4\u56de\u503c\u53ef\u4ee5\u662f\u5f15\u7528\u7c7b\u578b\uff0c\u4f46\u4e0d\u80fd\u662f\u51fd\u6570\u7684\u4e34\u65f6\u53d8\u91cf\u3002","title":"\u5de6\u503c\u5f15\u7528"},{"location":"languages/cpp/basic/#c11","text":"\u53f3\u503c \uff1a\u4e0d\u80fd\u53d6\u5730\u5740\u7684\u3001\u6ca1\u6709\u540d\u5b57\u7684\u5c31\u662f\u53f3\u503c \u533f\u540d\u53d8\u91cf\uff08\u4e34\u65f6\u53d8\u91cf\uff09\u7684\u522b\u540d\uff1a\u7c7b\u578b\u540d&& \u5f15\u7528\u540d \u8868\u8fbe\u5f0f\uff0c\u5982 int && sum = 3 + 4 ; float && res = ReturnRvalue ( f1 , f2 ); \u53f3\u503c\u5f15\u7528\u7684\u5178\u578b\u5e94\u7528\u662f\u5728\u51fd\u6570\u53c2\u6570\u4e2d\uff0c\u76ee\u7684\u662f\u51cf\u5c11\u4e34\u65f6\u53d8\u91cf\u7684\u62f7\u8d1d\u5f00\u9500\uff0c\u4f8b\u5982\uff1a void AcceptRvalueRef ( T && s ) {...}","title":"\u53f3\u503c\u5f15\u7528\uff08C++11 \u5f15\u5165\uff09"},{"location":"languages/cpp/basic/#_4","text":"","title":"\u53d8\u91cf\u521d\u59cb\u5316\u3001\u7c7b\u578b\u63a8\u5bfc\u3001\u57fa\u4e8e\u8303\u56f4\u7684\u5faa\u73af"},{"location":"languages/cpp/basic/#_5","text":"\u7528 {}``\u5305\u62ec\u8d77\u6765\u7684\u5143\u7d20\u5e8f\u5217\uff0c\u53ef\u4ee5\u7528\u6765\u5bf9\u53d8\u91cf\u8fdb\u884c\u521d\u59cb\u5316\uff0c\u5982 int a [] = { 1 , 3 , 5 }; int a [] { 1 , 3 , 5 }; \u521d\u59cb\u5316\u5217\u8868\u53ef\u4ee5\u518d {} \u4e4b\u524d\u4f7f\u7528 =`\uff0c\u4e5f\u53ef\u4ee5\u4e0d\u7528\u3002 \u53d8\u91cf\u7684\u521d\u59cb\u5316\u65b9\u5f0f int a = 3 + 5 ; int a = { 3 + 5 }; int a ( 3 + 5 ); // \u8c03\u7528int\u7684\u6784\u9020\u51fd\u6570 int a { 3 + 5 }; int * i = new int ( 10 ); double * d = new double { 1.2f }; // \u521d\u59cb\u5316\u5217\u8868","title":"\u521d\u59cb\u5316\u5217\u8868"},{"location":"languages/cpp/basic/#_6","text":"\u4f7f\u7528 decltype \u53ef\u4ee5\u5bf9\u53d8\u91cf\u6216\u8868\u8fbe\u5f0f\u7ed3\u679c\u7684\u7c7b\u578b\u8fdb\u884c\u63a8\u5bfc\uff0c\u5982 struct { char * name ; } anon_u ; struct { int d ; decltype ( anon_u ) id ; } anon_s [ 100 ]; // \u533f\u540d\u7684struct\u6570\u7ec4 int main () { decltype ( anon_s ) as ; cin >> as [ 0 ]. id . name ; }","title":"\u7c7b\u578b\u63a8\u5bfc"},{"location":"languages/cpp/basic/#for","text":"\u5728\u5faa\u73af\u5934\u7684\u5706\u62ec\u53f7\u4e2d\uff0c\u7531\u5192\u53f7 : \u5206\u4e3a\u4e24\u90e8\u5206\uff0c\u7b2c\u4e00\u90e8\u5206\u9002\u7528\u4e8e\u8fed\u4ee3\u7684\u53d8\u91cf\uff0c\u7b2c\u4e8c\u90e8\u5206\u5219\u8868\u793a\u88ab\u8fed\u4ee3\u7684\u8303\u56f4\uff0c\u5982\uff1a int arr [ 3 ] = { 1 , 3 , 5 }; for ( int e : arr ) //...","title":"\u57fa\u4e8e\u8303\u56f4\u7684for\u5faa\u73af\u8bed\u53e5"},{"location":"languages/cpp/basic/#_7","text":"","title":"\u51fd\u6570"},{"location":"languages/cpp/basic/#_8","text":"\u540c\u4e00\u540d\u79f0\u7684\u51fd\u6570\uff0c\u6709\u4e24\u4e2a\u4ee5\u4e0a\u4e0d\u540c\u7684\u51fd\u6570\u5b9e\u73b0\uff0c\u88ab\u79f0\u4e3a\u201c\u51fd\u6570\u91cd\u8f7d\u201d\uff0c\u5982\uff1a void print ( char * msg ) { cout << \"message: \" << msg << endl ; } void print ( int score ) { cout << \"score: \" << score << endl ; } \u51fd\u6570\u91cd\u8f7d\u8981\u6c42\u51fd\u6570\u5f62\u53c2\u4e0d\u540c\uff0c\u4e0d\u80fd\u51fa\u73b0\u4ec5\u4ec5\u8fd4\u56de\u503c\u4e0d\u540c\u7684\u60c5\u51b5\u3002\u7f16\u8bd1\u5668\u901a\u8fc7\u51fd\u6570\u8c03\u7528\u8bed\u53e5\u7684\u5b9e\u53c2\u786e\u5b9a\u54ea\u4e00\u4e2a\u51fd\u6570\u88ab\u8c03\u7528\u3002 \u591a\u4e2a\u540c\u540d\u51fd\u6570\u5b9e\u73b0\u4e4b\u95f4\uff0c\u5fc5\u987b\u4fdd\u8bc1\u81f3\u5c11\u6709\u4e00\u4e2a\u51fd\u6570\u53c2\u6570\u7684\u7c7b\u578b\u6709\u533a\u522b\u3002\u8fd4\u56de\u503c\u3001\u53c2\u6570\u540d\u79f0\u7b49\u4e0d\u80fd\u4f5c\u4e3a\u533a\u5206\u6807\u8bc6\u3002","title":"\u51fd\u6570\u91cd\u8f7d"},{"location":"languages/cpp/basic/#_9","text":"\u51fd\u6570\u53c2\u6570\u53ef\u4ee5\u5728\u5b9a\u4e49\u65f6\u8bbe\u7f6e\u9ed8\u8ba4\u503c\uff08\u7f3a\u7701\u503c\uff09\uff0c\u8fd9\u6837\u5728\u8c03\u7528\u8be5\u51fd\u6570\u65f6\uff0c\u82e5\u4e0d\u63d0\u4f9b\u76f8\u5e94\u7684\u5b9e\u53c2\uff0c\u5219\u7f16\u8bd1\u5668\u81ea\u52a8\u5c06\u76f8\u5e94\u5f62\u53c2\u8bbe\u7f6e\u6210\u7f3a\u7701\u503c\uff0c\u5982\uff1a void print ( char * msg = \"hello\" ) { cout << msg << '#' ; } int main () { print ( \"Beijing...\" ); print (); return 0 ; } \u8f93\u51fa\uff1a Beijing...#hello# \u5e26\u7f3a\u7701\u503c\u7684\u51fd\u6570\u53c2\u6570\u5fc5\u987b\u653e\u5728\u6ca1\u6709\u7f3a\u7701\u503c\u7684\u51fd\u6570\u53c2\u6570\u540e\u9762\u3002","title":"\u51fd\u6570\u53c2\u6570\u7684\u7f3a\u7701\u503c"},{"location":"languages/cpp/basic/#_10","text":"\u53ef\u4ee5\u5c06\u51fd\u6570\u8fd4\u56de\u7c7b\u578b\u7684\u4fe1\u606f\u653e\u5230\u51fd\u6570\u53c2\u6570\u5217\u8868\u7684\u540e\u9762\u8fdb\u884c\u58f0\u660e\uff0c\u5982\uff1a \u666e\u901a\u51fd\u6570\u58f0\u660e\u5f62\u5f0f\uff1a int func ( char * ptr , int val ); \u8ffd\u8e2a\u8fd4\u56de\u7c7b\u578b\u7684\u51fd\u6570\u58f0\u660e\u5f62\u5f0f\uff1a auto func ( char * ptr , int val ) -> int ; \u8ffd\u8e2a\u8fd4\u56de\u7c7b\u578b\u5728\u539f\u672c\u51fd\u6570\u8fd4\u56de\u503c\u7684\u4f4d\u7f6e\u4f7f\u7528 auto \u5173\u952e\u5b57\u3002 \u52a8\u673a \uff1a\u6709\u65f6\u51fd\u6570\u5728\u5b9a\u4e49\u7684\u65f6\u5019\u5e76\u4e0d\u80fd\u786e\u5b9a\u8fd4\u56de\u503c\u7c7b\u578b\uff0c\u800c\u9700\u8981\u901a\u8fc7 decl \u83b7\u53d6\u53c2\u6570\u7684\u7c7b\u578b\u6765\u786e\u5b9a\u3002 \u5e94\u7528 \uff1a \u5728C++\u6a21\u677f\u7684\u5b9a\u4e49\u4e2d\uff0c\u6709\u65f6\u8fd4\u56de\u7c7b\u578b\u9700\u8981\u6839\u636e\u53c2\u6570\u7c7b\u578b\u7c7b\u786e\u5b9a\uff0c\u4f1a\u7528\u5230\u8fd9\u4e2a\u7279\u6027\u3002","title":"\u8ffd\u8e2a\u8fd4\u56de\u7c7b\u578b\u7684\u51fd\u6570"},{"location":"languages/cpp/basic/#_11","text":"","title":"\u7c7b"},{"location":"languages/cpp/basic/#_12","text":"\u4e00\u79cd\u7528\u6237\u81ea\u5b9a\u4e49\u7684\u7c7b\u578b\uff0c\u5305\u542b\u51fd\u6570\u4e0e\u6570\u636e\u7684\u7279\u6b8a\u201c\u7ed3\u6784\u4f53\u201d\uff0c\u6269\u5145C++\u8bed\u8a00\u7684\u7c7b\u578b\u4f53\u7cfb\u3002 \u7c7b\u4e2d\u5305\u542b\u7684\u51fd\u6570\uff0c\u79f0\u4e3a \u6210\u5458\u51fd\u6570 \uff1b\u5305\u542b\u7684\u6570\u636e\uff0c\u79f0\u4e3a \u6570\u636e\u6210\u5458 \u3002 \u7c7b\u4e2d\u51fd\u6570\u53ca\u53ef\u4ee5\u5728\u7c7b\u4e2d\u7ed9\u51fa\u5b9a\u4e49\uff0c\u4e5f\u53ef\u4ee5\u5728\u7c7b\u5916\u7ed9\u51fa\u5b9a\u4e49\u3002 \u7c7b\u7684\u6210\u5458\uff08\u51fd\u6570\u3001\u6570\u636e\uff09\u53ef\u4ee5\u6839\u636e\u9700\u8981\u5206\u6210\u7ec4\uff0c\u4e0d\u540c\u7ec4\u8bbe\u7f6e\u4e0d\u540c\u7684\u8bbf\u95ee\u6743\u9650\u3002 \u6743\u9650\u79cd\u7c7b\uff1a public , private , protected \u3002 \u7c7b\u5b9a\u4e49\u540e\uff0c\u6838\u51fd\u6570\u5185\u5efa\u7684\u7c7b\u578b\u4e00\u6837\uff0c\u7528\u7c7b\u6765\u5b9a\u4e49\u53d8\u91cf\uff0c\u8be5\u53d8\u91cf\u901a\u5e38\u88ab\u79f0\u4e3a \u5bf9\u8c61 \u3002 \u901a\u8fc7\u201c\u5bf9\u8c61\u540d.\u6210\u5458\u540d\u201d\u7684\u5f62\u5f0f\uff0c\u53ef\u4ee5\u4f7f\u7528\u5bf9\u8c61\u7684\u6570\u636e\u6210\u5458\uff0c\u6216\u8c03\u7528\u5bf9\u8c61\u7684\u6570\u636e\u51fd\u6570\uff0c\u4f46\u4ec5\u9650\u4e8e\u8bbf\u95ee public \u6743\u9650\u7684\u6210\u5458\u3002 \u5728\u7c7b\u5916\u5b9a\u4e49\u6210\u5458\u51fd\u6570\u65f6\uff0c\u51fd\u6570\u540d\u524d\u8981\u52a0\u4e0a\u7c7b\u540d\u9650\u5b9a\uff0c\u683c\u5f0f\u4e3a\uff1a \u7c7b\u540d::\u51fd\u6570\u540d \uff0c\u5176\u4e2d :: \u79f0\u4e3a \u57df\u8fd0\u7b97\u7b26 \u3002 \u5728\u5934\u6587\u4ef6\u4e2d\u58f0\u660e\u7c7b class // matrix.h #ifndef MATRIX_H #define MATRIX_H class Matrix { int data [ 6 ][ 6 ]; public : void fill ( char dir ); }; #endif \u5728\u5b9e\u73b0\u6587\u4ef6\u4e2d\u5b9a\u4e49\u7c7b class // matrix.cpp #include \"matrix.h\" void Matrix :: fill ( char dir ) { //... } \u901a\u5e38\uff0c\u7c7b\u7684\u58f0\u660e\u653e\u5728\u5934\u6587\u4ef6\u4e2d\uff0c\u800c\u7c7b\u7684\u6210\u5458\u51fd\u6570\u5b9e\u73b0\u5219\u653e\u5728\u5b9e\u73b0\u6587\u4ef6\u4e2d\u3002 \u4e3a\u4e86\u4fbf\u4e8e\u7ba1\u7406\u548c\u4ee3\u7801\u590d\u7528\uff0c\u4e00\u822c\u662f\u5c06\u4e0d\u540c\u7684\u7c7b\u5206\u522b\u4fdd\u5b58\u4e3a\u4e0d\u540c\u7684\u5934\u6587\u4ef6\u548c\u5b9e\u73b0\u6587\u4ef6\u3002","title":"\u7528\u6237\u81ea\u5b9a\u4e49\u7684\u7c7b\u578b\u2014\u2014\u7c7b\uff1a"},{"location":"languages/cpp/basic/#_13","text":"\u53ef\u4ee5\u5728\u7c7b\u7684\u5b9a\u4e49\u5185\u90e8\u5b9e\u73b0\uff0c\u4e5f\u53ef\u4ee5\u7528 :: \u8fd0\u7b97\u7b26\u5728\u5916\u90e8\u5b9e\u73b0\u3002 class Matrix { public : void fill ( char dir ) { //... } }; void Matrix :: fill ( char dir ) { //... };","title":"\u6210\u5458\u51fd\u6570\u7684\u4e24\u79cd\u5b9a\u4e49\u65b9\u5f0f"},{"location":"languages/cpp/basic/#this","text":"\u6240\u6709\u6210\u5458\u51fd\u6570\u7684\u53c2\u6570\u4e2d\uff0c\u9690\u542b\u7740\u4e00\u4e2a\u53ea\u60f3\u5f53\u524d\u5bf9\u8c61\u7684\u6307\u9488\u53d8\u91cf\u2014\u2014 this \u3002 \u8fd9\u4e5f\u662f \u6210\u5458\u51fd\u6570 \u4e0e \u666e\u901a\u51fd\u6570 \u7684\u91cd\u8981\u533a\u522b","title":"this\u6307\u9488"},{"location":"languages/cpp/basic/#_14","text":"C++\u89c4\u5b9a\u7c7b\u7684\u6210\u5458\u7f3a\u7701\u4e3a private \u6743\u9650\u3002 \u5bf9\u8c61\u4f7f\u7528 . \u64cd\u4f5c\u7b26\u8bbf\u95ee\u5bf9\u8c61\u7684 public \u6210\u5458\u3002 \u5bf9\u8c61\u6307\u9488\u4f7f\u7528 -> \u64cd\u4f5c\u7b26\u8bbf\u95ee\u6240\u6307\u5bf9\u8c61\u7684\u516c\u6709\u6210\u5458\u3002","title":"\u8bbf\u95ee\u6743\u9650"},{"location":"languages/cpp/basic/#_15","text":"\u6709\u65f6\u9700\u8981\u5141\u8bb8\u67d0\u4e9b\u51fd\u6570\u8bbf\u95ee\u5bf9\u8c61\u7684\u79c1\u6709\u6210\u5458\uff0c\u53ef\u4ee5\u901a\u8fc7\u58f0\u660e\u8be5 \u51fd\u6570 \u4e3a \u7c7b \u7684\u201c\u53cb\u5143\u201d\u6765\u5b9e\u73b0\u3002 class Test { int id ; public : friend void print ( Test obj ); //... }; void print ( Test obj ) { cout << obj . id << endl ; } Test \u7c7b\u4e2d\u58f0\u660e\u4e86 Test \u7c7b\u7684\u53cb\u5143\u51fd\u6570 print \uff0c\u8be5\u51fd\u6570\u5728\u5b9e\u73b0\u65f6\u53ef\u4ee5\u8bbf\u95ee Test \u7c7b\u5b9a\u4e49\u7684\u51fd\u6570\u5bf9\u8c61\u7684\u79c1\u6709\u6210\u5458\u3002 \u5de5\u7a0b\u4e2d\u4e00\u79cd\u5e38\u89c1\u7684\u7528\u6cd5\u662f\u5c06UT\u4e2d\u7684\u6d4b\u8bd5\u51fd\u6570\u751f\u547d\u6210\u88ab\u6d4b\u8bd5\u7c7b\u7684\u53cb\u5143\uff0c\u4ee5\u4fbf\u5728\u6d4b\u8bd5\u51fd\u6570\u4e2d\u8bbf\u95ee\u88ab\u6d4b\u8bd5\u7c7b\u7684\u79c1\u6709\u6210\u5458\u3002","title":"\u53cb\u5143"},{"location":"languages/cpp/basic/#_16","text":"\u89e3\u91ca\u5982\u4e0b\u7a0b\u5e8f\u7684\u8fd0\u884c\u7ed3\u679c\uff1a #include <iostream> using namespace std ; class Test { public : Test () { cout << \"Test()\" << endl ; } Test ( const Test & src ) { cout << \"Test(const Test&)\" << endl ; } ~ Test () { cout << \"~Test()\" << endl ; } }; void func1 ( Test obj ) { cout << \"func1()...\" << endl ; } Test func2 () { cout << \"func2()...\" << endl ; return Test (); } int main () { cout << \"main()...\" << endl ; Test t ; func1 ( t ); t = func2 (); return 0 ; } \u62f7\u8d1d\u6784\u9020\u51fd\u6570 \u4f1a\u5728\u51fd\u6570\u7531\u5b9e\u53c2\u83b7\u5f97\u5f62\u53c2\u65f6\u8c03\u7528\u3002 \u8f93\u51fa main()... Test() Test(const Test&) func1()... ~Test() func2()... Test() ~Test() ~Test()","title":"\u6784\u9020\u51fd\u6570\u3001\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u4e0e\u6790\u6784\u51fd\u6570"},{"location":"languages/cpp/basic/#_17","text":"\u89e3\u91ca\u5982\u4e0b\u7a0b\u5e8f\u7684\u8fd0\u884c\u7ed3\u679c #include <iostream> using namespace std ; class Test { public : Test ( int _id ) : id ( _id ) { cout << \"obj_\" << id << \"created \\n \" ; } Test & operator = ( const Test & right ) { if ( this == & right ) cout << \"same obj! \\n \" ; else { cout << \"obj_\" << id << \" = obj_\" << right . id << endl ; } return * this ; } private : int id ; }; int main () { Test a ( 1 ), b ( 2 ); cout << \"a = a: \" ; a = a ; cout << \"a = b: \" ; a = b ; return 0 ; } } \u8f93\u51fa obj_1created obj_2created a = a: same obj! a = b: obj_1 = obj_2","title":"\u8d4b\u503c\u8fd0\u7b97\u7b26 = \u91cd\u8f7d"},{"location":"languages/cpp/basic/#_18","text":"\u89e3\u91ca\u5982\u4e0b\u7a0b\u5e8f\u8fd0\u884c\u7ed3\u679c #include <iostream> using namespace std ; class Test { int id ; public : Test ( int _id ) : id ( _id ) { cout << \"obj_\" << id << \"created \\n \" ; } friend istream & operator >> ( istream & in , Test & dst ); friend ostream & operator << ( ostream & out , const Test & src ); }; istream & operator >> ( istream & in , Test & dst ) { in >> dst . id ; return in ; } ostream & operator << ( ostream & out , const Test & src ) { cout << src . id << endl ; return out ; } int main () { Test obj ( 1 ); cout << obj ; cin >> obj ; cout << obj ; return 0 ; } \u5c06 \u6d41\u8fd0\u7b97\u7b26 \u58f0\u660e\u6210 Test Test \u7c7b\u7684\u53cb\u5143\uff0c\u5728\u5b9e\u73b0\u7684\u65f6\u5019\u53ef\u4ee5\u8bbf\u95ee\u5176\u79c1\u6709\u53d8\u91cf\u3002 \u8fd4\u56de\u6d41\u5bf9\u8c61\u662f\u4e3a\u4e86\u652f\u6301\u6d41\u8fd0\u7b97\u7b26\u7684\u94fe\u5f0f\u64cd\u4f5c\u3002 \u8f93\u51fa\uff08\u4e2d\u95f4\u8f93\u5165\u6d41\u5185\u5bb9\u4e3a 2 2 \uff09 obj_1created 1 2 2","title":"\u6d41\u8fd0\u7b97\u7b26 &lt;&lt;/&gt;&gt; \u91cd\u8f7d"},{"location":"languages/cpp/basic/#_19","text":"\u89e3\u91ca\u5982\u4e0b\u7a0b\u5e8f\u8fd0\u884c\u7ed3\u679c #include <iostream> using namespace std ; class Test { public : int operator ()( int a , int b ) { cout << \"operator() called. \" << a << ' ' << b << endl ; return a + b ; } }; int main () { Test sum ; int s = sum ( 3 , 4 ); cout << \"a + b = \" << s << endl ; return 0 ; } sum\u5bf9\u8c61\u770b\u4e0a\u53bb\u50cf\u4e00\u4e2a\u51fd\u6570\uff0c\u6545\u4e5f\u79f0\u201c\u51fd\u6570\u5bf9\u8c61\u201d\u3002 \u8f93\u51fa operator() called. 3 4 a + b = 7","title":"\u51fd\u6570\u8fd0\u7b97\u7b26 () \u91cd\u8f7d"},{"location":"languages/cpp/basic/#-","text":"","title":"\u4e0b\u6807\u8fd0\u7b97\u7b26 [] \u548c ++/-- \u81ea\u589e\u51cf\u8fd0\u7b97\u7b26"},{"location":"languages/cpp/basic/#_20","text":"\u4e0b\u9762\u7684\u4ee3\u7801\u4f53\u73b0\u8bbe\u8ba1\u6a21\u5f0f\u4e2d\u201c\u5305\u88c5\u201d\u7684\u601d\u60f3\uff0c\u8ba9\u539f\u672c\u53ea\u652f\u6301\u6570\u5b57\u7684 [] \u8fd0\u7b97\u7b26\u5bf9\u5916\u652f\u6301\u5b57\u7b26\u4e32\u7c7b\u578b\u7d22\u5f15\u3002 #include <iostream> #include <string.h> using namespace std ; char week_name [ 7 ][ 4 ] = { \"mon\" , \"tu\" , \"wed\" , \"thu\" , \"fri\" , \"sat\" , \"sun\" }; class WeekTemp { public : int & operator []( const char * name ) { for ( int i = 0 ; i < 7 ; i ++ ) { if ( strcmp ( week_name [ i ], name ) == 0 ) return temp [ i ]; } } private : int temp [ 7 ]; }; int main () { WeekTemp beijing ; beijing [ \"mon\" ] = - 3 ; beijing [ \"tu\" ] = - 1 ; cout << \"Monday Temperture: \" << beijing [ \"mon\" ] << endl ; return 0 ; } \u8f93\u51fa Monday Temperture: -3","title":"\u4e0b\u6807\u8fd0\u7b97\u7b26"},{"location":"languages/cpp/basic/#-_1","text":"\u524d\u7f00\u8fd0\u7b97\u7b26\u91cd\u8f7d\u58f0\u660e ReturnType operator ++ (); ReturnType operator -- (); \u540e\u7f00\u8fd0\u7b97\u7b26\u91cd\u8f7d\u58f0\u660e ReturnType operator ++ ( int dummy ); ReturnType operator -- ( int dummy ); \u901a\u8fc7\u5728\u51fd\u6570\u53c2\u6570\u4e2d\u7684\u54d1\u5143\u53c2\u6570 dummy \u6765\u533a\u5206\u524d\u7f00\u548c\u540e\u7f00\u7684\u540c\u540d\u91cd\u8f7d\u3002 \u54d1\u5143\uff1a\u51fd\u6570\u4f53\u8bed\u53e5\u4e2d\u6ca1\u6709\u4f7f\u7528\u8be5\u53c2\u6570\u3002","title":"\u524d\u7f00++/--\u4e0e\u540e\u7f00++/--"},{"location":"languages/cpp/basic/#_21","text":"","title":"\u9759\u6001\u6210\u5458\u548c\u5e38\u91cf\u6210\u5458"},{"location":"languages/cpp/basic/#_22","text":"static \u4fee\u9970\u7684\u6570\u636e\u6210\u5458\u96b6\u5c5e\u4e8e\u7c7b\u3002 \u9759\u6001\u6570\u636e\u6210\u5458\u88ab\u8be5\u7c7b\u7684\u6240\u6709\u5bf9\u8c61\u5171\u4eab\uff08\u5373\u6240\u6709\u5bf9\u8c61\u4e2d\u7684\u8fd9\u4e2a\u6570\u636e\u57df\u5904\u4e8e\u540c\u4e00\u5185\u5b58\u4f4d\u7f6e\uff09 \u9759\u6001\u6570\u636e\u6210\u5458\u8981\u5728 \u5b9e\u73b0\u6587\u4ef6 \u4e2d\u8d4b\u521d\u503c\uff0c\u683c\u5f0f\u4e3a\uff1a Type ClassName::static_var = Value; \u5bf9\u4e8e\u9759\u6001\u6210\u5458\u51fd\u6570\uff0c\u7f16\u8bd1\u5668\u4e0d\u63d0\u4f9b\u6307\u5411\u5bf9\u8c61\u7684\u6307\u9488\uff0c\u5b83\u4eec\u4e0d\u80fd\u8c03\u7528\u975e\u9759\u6001\u6210\u5458\u51fd\u6570\u3002 \u7c7b\u7684\u9759\u6001\u6210\u5458\u65e2\u53ef\u4ee5\u901a\u8fc7\u5bf9\u8c61\u6765\u8bbf\u95ee\uff0c\u4e5f\u53ef\u4ee5\u901a\u8fc7\u7c7b\u540d\u6765\u8bbf\u95ee\u3002 \u89e3\u91ca\u5982\u4e0b\u4ee3\u7801\u884c\u4e3a\uff1a #include <iostream> using namespace std ; class Test { public : Test () { count ++ ; } ~ Test () { count -- ; } static int how_many () { return count ; } private : static int count ; }; int Test :: count = 0 ; void print ( Test t ) { cout << \"in print(), Test#: \" << t . how_many () << endl ; } int main () { Test t1 ; cout << \"Test#: \" << Test :: how_many () << endl ; Test t2 = t1 ; cout << \"Test#: \" << Test :: how_many () << endl ; print ( t2 ); cout << \"Test#: \" << t1 . how_many () << \", \" << t2 . how_many () << endl ; return 0 ; } \u8f93\u51fa Test#: 1 Test#: 1 in print(), Test#: 1 Test#: 0, 0 \u6ce8\u610f\u5230 t2 = t1; \u6b64\u5904\u8c03\u7528\u7684\u662f = \u8fd0\u7b97\u7b26\uff0c\u800c print(t2); \u8c03\u7528\u7684\u662f \u62f7\u8d1d\u6784\u9020\u51fd\u6570 \uff0c\u4f46\u5728 Test \u91cc\u9762\u5747\u672a\u5b9a\u4e49\u884c\u4e3a\u3002\u4f46 print(t2); \u8fd4\u56de\u65f6\u8c03\u7528\u4e86 \u6790\u6784\u51fd\u6570 \uff0c\u6545\u6700\u540e\u4e00\u884c\u9759\u6001\u6210\u5458 count \u53d8\u6210\u4e860\u3002","title":"\u9759\u6001\u6210\u5458"},{"location":"languages/cpp/basic/#_23","text":"const \u4fee\u9970\u7684\u6570\u636e\u6210\u5458\uff0c\u79f0\u4e3a\u7c7b\u7684\u5e38\u91cf\u6570\u636e\u6210\u5458\uff0c\u5728\u5bf9\u8c61\u7684\u6574\u4e2a\u751f\u547d\u5468\u671f\u91cc\u4e0d\u53ef\u6539\u53d8\u3002 \u5e38\u91cf\u6570\u636e\u6210\u5458\u53ea\u80fd\u5728\u6784\u9020\u51fd\u6570\u521d\u59cb\u5316\u5217\u8868\u4e2d\u88ab\u8bbe\u7f6e\uff0c\u4e0d\u80fd\u5728\u51fd\u6570\u4f53\u4e2d\u901a\u8fc7\u8d4b\u503c\u8bbe\u7f6e\u3002 const \u4fee\u9970\u7684\u6210\u5458\u51fd\u6570\uff0c\u5219\u8be5\u6210\u5458\u51fd\u6570\u5728\u5b9e\u73b0\u65f6\u4e0d\u80fd\u4fee\u6539\u7c7b\u7684\u6570\u636e\u6210\u5458 \u2014\u2014\u2014\u2014 \u5373\u9759\u6001\u51fd\u6570\u4e0d\u80fd\u6539\u53d8\u5bf9\u8c61\u72b6\u6001\u3002 \u82e5\u5bf9\u8c61\u88ab\u5b9a\u4e49\u4e3a\u5e38\u91cf\uff0c\u5219\u5b83\u53ea\u80fd\u8c03\u7528\u4ee5 const \u4fee\u9970\u7684\u6210\u5458\u51fd\u6570\uff0c\u5176\u4ed6\u666e\u901a\u6210\u5458\u51fd\u6570\u5219\u4e0d\u5141\u8bb8\u8c03\u7528\u3002 \u89e3\u91ca\u5982\u4e0b\u4ee3\u7801\u884c\u4e3a #include <iostream> using namespace std ; class Test { public : Test ( int id ) : ID ( id ) {} int MyID () const { return ID ; } int Who () { return ID ; } private : const int ID ; }; int main () { Test obj1 ( 12231031 ); cout << \"ID_1 = \" << obj1 . MyID () << endl ; cout << \"ID_2 = \" << obj1 . Who () << endl ; const Test obj2 ( 1602401 ); cout << \"id_1: \" << obj2 . MyID () << endl ; return 0 ; } \u8f93\u51fa ID_1 = 12231031 ID_2 = 12231031 id_1: 1602401","title":"\u5e38\u91cf\u6210\u5458"},{"location":"languages/cpp/basic/#_24","text":"\u53ef\u4ee5\u5728\u7c7b\u4e2d\u4f7f\u7528\u5176\u4ed6\u7c7b\u6765\u5b9a\u4e49\u6570\u636e\u6210\u5458\uff0c\u901a\u5e38\u79f0\u4e4b\u4e3a\u201c\u5b50\u5bf9\u8c61\u201d\u3002\u8fd9\u79cd\u5305\u542b\u5173\u7cfb\u79f0\u4e3a \u7ec4\u5408 \uff0c\u7ec4\u5408\u5173\u7cfb\u53ef\u4ee5\u5d4c\u5957\u3002 \u5b50\u5bf9\u8c61\u6784\u9020\u65f6\u82e5\u9700\u8981\u53c2\u6570\uff0c\u5219\u5e94\u5728\u5f53\u524d\u7c7b\u7684\u6784\u9020\u51fd\u6570\u7684 \u521d\u59cb\u5316\u5217\u8868 \u4e2d\u8fdb\u884c\u3002\u82e5\u4f7f\u7528\u9ed8\u8ba4\u6784\u9020\u51fd\u6570\u6765\u6784\u9020\u5b50\u5bf9\u8c61\u5219\u4e0d\u7528\u505a\u4efb\u4f55\u5904\u7406\u3002 \u5bf9\u8c61\u6784\u9020\u4e0e\u6790\u6784\u6b21\u5e8f\uff1a\u7a7f\u8131\u539f\u7406 \u5148\u5b8c\u6210\u5b50\u5bf9\u8c61\u6784\u9020\uff0c\u518d\u5b8c\u6210\u5f53\u524d\u5bf9\u8c61\u6784\u9020 \u5148\u5bf9\u5916\u5c42\u5bf9\u8c61\u6790\u6784\uff0c\u518d\u5bf9\u5185\u5c42\u5bf9\u8c61\u6790\u6784 \u89e3\u91ca\u5982\u4e0b\u4ee3\u7801\u884c\u4e3a #include <iostream> using namespace std ; class C1 { public : C1 ( int id ) : ID ( id ) { cout << \"C1(int)\" << endl ; } ~ C1 () { cout << \"~C1()\" << endl ; } private : int ID ; }; class C2 { public : C2 () { cout << \"C2()\" << endl ; } ~ C2 () { cout << \"~C2()\" << endl ; } }; class C3 { public : C3 () : num ( 0 ), sub_obj1 ( 123 ) { cout << \"C3()\" << endl ; } C3 ( int n ) : num ( n ), sub_obj1 ( 123 ) { cout << \"C3(int)\" << endl ; } C3 ( int n , int k ) : num ( n ), sub_obj1 ( k ) { cout << \"C3(int, int)\" << endl ; } ~ C3 () { cout << \"~C3()\" << endl ; } private : int num ; C1 sub_obj1 ; C2 sub_obj2 ; }; int main () { C3 a , b ( 1 ), c ( 2 ), d ( 3 , 4 ); return 0 ; } C1 \u3001 C2 \u662f C3 \u7684\u5b50\u5bf9\u8c61\uff0c\u5176\u4e2d C2 \u63d0\u4f9b\u4e86\u7f3a\u7701\u6784\u9020\u51fd\u6570\uff0c\u6545\u5728 C3 \u4e2d\u4e0d\u7528\u663e\u5f0f\u521d\u59cb\u5316\uff1b\u4f46 C1 \u53ea\u63d0\u4f9b\u4e86\u4e00\u4e2a\u5e26\u53c2\u6570\u7684\u6784\u9020\u51fd\u6570\uff0c\u6545\u5fc5\u987b\u5728 C3 \u7684 \u521d\u59cb\u5316\u5217\u8868 \u91cc\u9762\u5b8c\u6210\u521d\u59cb\u5316\u3002 \u8f93\u51fa C1(int) C2() C3() C1(int) C2() C3(int) C1(int) C2() C3(int) C1(int) C2() C3(int, int) ~C3() ~C2() ~C1() ~C3() ~C2() ~C1() ~C3() ~C2() ~C1() ~C3() ~C2() ~C1() \u4ece\u8f93\u51fa\u53ef\u4ee5\u770b\u51fa\u6784\u9020\u94fe\u4ece\u5185\u5230\u5916\uff0c\u800c\u6790\u6784\u94fe\u4ece\u5916\u5411\u5185\u3002","title":"\u5bf9\u8c61\u7ec4\u5408"},{"location":"languages/cpp/basic/#c-11","text":"\u8bed\u6cd5\uff1a ClassName(ClassName&&); \u76ee\u7684 \u7528\u6765\u5077\u201c\u4e34\u65f6\u53d8\u91cf\u201d\u4e2d\u7684\u8d44\u6e90\uff08\u5982\u5185\u5b58\uff09\u3002 \u4e34\u65f6\u53d8\u91cf\u88ab\u7f16\u8bd1\u5668\u8bbe\u7f6e\u4e3a\u5e38\u91cf\u5f62\u5f0f\uff0c\u4f7f\u7528\u201c\u62f7\u8d1d\u6784\u9020\u201d\u51fd\u6570\u65e0\u6cd5\u5c06\u8d44\u6e90\u201c\u5077\u201d\u51fa\u6765\uff08\u6539\u52a8\u4e86\u5143\u5bf9\u8c61\uff0c\u8fdd\u53cd\u5e38\u91cf\u7684\u9650\u5236\uff09\u3002 \u57fa\u4e8e \u53f3\u503c\u5f15\u7528 \u5b9a\u4e49\u7684 \u79fb\u52a8\u6784\u9020\u51fd\u6570 \u652f\u6301\u63a5\u53d7\u4e34\u65f6\u53d8\u91cf\uff0c\u80fd\u201c\u5077\u201d\u51fa\u4e34\u65f6\u53d8\u91cf\u4e2d\u7684\u8d44\u6e90\u3002 #include <iostream> using namespace std ; class Test { public : int * buf ; Test () { buf = new int ( 3 ); cout << \"Test(): this->buf @ \" << hex << buf << endl ; } ~ Test () { cout << \"~Test(): this->buf @ \" << hex << buf << endl ; if ( buf ) delete buf ; } Test ( Test & t ) : buf ( new int ( * t . buf )) { cout << \"Test(const Test&) called. this->buf @ \" << hex << buf << endl ; t . buf = nullptr ; } Test ( Test && t ) : buf ( t . buf ) { cout << \"Test(Test&&) called. this->buf @ \" << hex << buf << endl ; t . buf = nullptr ; } }; Test GetTemp () { Test tmp ; cout << \"GetTemp(): tmp.buf @ \" << hex << tmp . buf << endl ; return tmp ; } void fun ( Test t ) { cout << \"fun(Test t): t.buf @ \" << hex << t . buf << endl ; } int main () { Test a = GetTemp (); cout << \"main() : a.buf @ \" << hex << a . buf << endl ; fun ( a ); return 0 ; } \u8f93\u51fa Test(): this->buf @ 0x558bd1e13e70 GetTemp(): tmp.buf @ 0x558bd1e13e70 main() : a.buf @ 0x558bd1e13e70 Test(const Test&) called. this->buf @ 0x558bd1e142a0 fun(Test t): t.buf @ 0x558bd1e142a0 ~Test(): this->buf @ 0x558bd1e142a0 ~Test(): this->buf @ 0 \u5728\u5982\u4e0a\u7ed3\u679c\u4e2d\u6ca1\u6709\u8c03\u7528\u79fb\u52a8\u6784\u9020\u51fd\u6570\uff0c\u6b32\u6267\u884c\u8be5\u51fd\u6570\uff0c\u9700\u8981\u589e\u52a0\u7f16\u8bd1\u9009\u9879\uff0c\u7981\u6b62\u7f16\u8bd1\u5668\u8fdb\u884c\u8fd4\u56de\u503c\u4f18\u5316 g++ main.cpp --std = c++11 -fno-elide-constructors -o main \u8f93\u51fa Test(): this->buf @ 0x560b6f4dce70 GetTemp(): tmp.buf @ 0x560b6f4dce70 Test(Test&&) called. this->buf @ 0x560b6f4dce70 ~Test(): this->buf @ 0 Test(Test&&) called. this->buf @ 0x560b6f4dce70 ~Test(): this->buf @ 0 main() : a.buf @ 0x560b6f4dce70 Test(const Test&) called. this->buf @ 0x560b6f4dd2a0 fun(Test t): t.buf @ 0x560b6f4dd2a0 ~Test(): this->buf @ 0x560b6f4dd2a0 ~Test(): this->buf @ 0 \u53ef\u89c1\uff0c\u51fd\u6570\u8fd4\u56de\u7684\u65f6\u5019\u8c03\u7528\u7684\u662f\u79fb\u52a8\u6784\u9020\u51fd\u6570\u3002 \u5982\u679c\u5c06 Test \u7c7b\u4e2d\u7684\u79fb\u52a8\u6784\u9020\u51fd\u6570\u53bb\u6389\uff0c\u540c\u6837\u7981\u7528\u7f16\u8bd1\u4f18\u5316\uff0c\u5219\u7f16\u8bd1\u62a5\u9519\uff1a main.cpp: In function \u2018int main()\u2019: main.cpp:38:21: error: cannot bind non-const lvalue reference of type \u2018Test&\u2019 to an rvalue of type \u2018Test\u2019 Test a = GetTemp(); ~~~~~~~^~ main.cpp:18:5: note: initializing argument 1 of \u2018Test::Test(Test&)\u2019 Test(Test& t) : buf(new int(*t.buf)) { ^~~~","title":"\u79fb\u52a8\u6784\u9020\u51fd\u6570 (C++ 11\u5f15\u5165)"},{"location":"languages/cpp/basic/#default-c-11","text":"","title":"default\u4fee\u9970\u7b26 (C++ 11\u5f15\u5165)"},{"location":"languages/cpp/basic/#_25","text":"\u5982\u679c\u4ee5\u4e0b\u6210\u5458\u51fd\u6570\u7528\u6237\u90fd\u6ca1\u6709\u4e3a\u7c7b\u5b9e\u73b0\uff0c\u5219\u7f16\u8bd1\u5668\u4f1a\u81ea\u52a8\u4e3a\u7c7b\u751f\u6210\u5b83\u4eec\u7684\u7f3a\u7701\u5b9e\u73b0 \u9ed8\u8ba4\u6784\u9020\u51fd\u6570 - \u7a7a\u51fd\u6570\uff0c\u4ec0\u4e48\u4e5f\u4e0d\u505a \u6790\u6784\u51fd\u6570 - \u7a7a\u51fd\u6570\uff0c\u4ec0\u4e48\u4e5f\u4e0d\u505a \u62f7\u8d1d\u6784\u9020\u51fd\u6570 - \u6309bit\u4f4d\u8d4b\u503c\u5bf9\u8c61\u6240\u5360\u5185\u5b58\u5185\u5bb9 \u79fb\u52a8\u6784\u9020\u51fd\u6570 - \u4e0e\u9ed8\u8ba4\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u4e00\u6837 \u8d4b\u503c\u8fd0\u7b97\u7b26\u91cd\u8f7d - \u4e0e\u9ed8\u8ba4\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u4e00\u6837 \u5982\u679c\u7528\u6237\u5b9a\u4e49\u4e86\u4e0a\u8ff0\u67d0\u4e2a\u6210\u5458\u51fd\u6570\uff0c\u5219\u7f16\u8bd1\u5668\u4e0d\u518d\u81ea\u52a8\u63d0\u4f9b\u76f8\u5e94\u7684\u9ed8\u8ba4\u5b9e\u73b0\u3002","title":"\u7f16\u8bd1\u5668\u81ea\u52a8\u751f\u6210\u7684\u6210\u5458\u51fd\u6570"},{"location":"languages/cpp/basic/#default","text":"\u5728\u9ed8\u8ba4\u51fd\u6570\u5b9a\u4e49\u6216\u58f0\u660e\u52a0\u4e0a =default \uff0c\u53ef\u663e\u5f0f\u7684\u53ea\u662f\u7f16\u8bd1\u5668\u751f\u6210\u8be5\u51fd\u6570\u7684\u9ed8\u8ba4\u7248\u672c\u3002 class T { public : T () = default ; T ( int i ) : data ( i ) {} private : int data ; };","title":"=default\u663e\u5f0f\u7f3a\u7701"},{"location":"languages/cpp/basic/#_26","text":"\u5728\u5df2\u6709\u7c7b\u7684\u57fa\u7840\u4e0a\uff0c\u53ef\u4ee5\u901a\u8fc7\u201c\u7ee7\u627f\u201d\u6765\u5b9a\u4e49\u65b0\u7684\u7c7b\uff0c\u5b9e\u73b0\u5bf9\u5df2\u6709\u4ee3\u7801\u7684\u590d\u7528\u3002 \u5e38\u89c1\u7684\u7ee7\u627f\u65b9\u5f0f\uff1a public , private class Derived: [private] Base {...}; \u7f3a\u7701\u7ee7\u627f\u65b9\u5f0f\u662f private \u7ee7\u627f\u3002 class Derived: public Base {...}; \u57fa\u7c7b/\u7236\u7c7b - base class - \u88ab\u7ee7\u627f\u7684\u5df2\u6709\u7c7b \u6d3e\u751f\u7c7b/\u5b50\u7c7b/\u6269\u5c55\u7c7b - derived class - \u901a\u8fc7\u7ee7\u627f\u5f97\u5230\u7684\u65b0\u7c7b","title":"\u7ee7\u627f"},{"location":"languages/cpp/basic/#_27","text":"\u57fa\u7c7b\u4e2d\u7684\u6570\u636e\u6210\u5458\u901a\u8fc7\u7ee7\u627f\u6210\u4e3a\u5b50\u7c7b\u5bf9\u8c61\u7684\u4e00\u90e8\u5206\uff0c\u9700\u8981\u5728\u6784\u9020\u5b50\u7c7b\u5bf9\u8c61\u7684\u8fc7\u7a0b\u4e2d\u8c03\u7528\u79ef\u7d2f\u7684\u6784\u9020\u51fd\u6570\u6765\u521d\u59cb\u5316\u3002 \u82e5\u6ca1\u6709\u663e\u5f0f\u8c03\u7528\uff0c\u5219\u7f16\u8bd1\u5668\u4f1a\u81ea\u52a8\u751f\u6210\u4e00\u4e2a\u5bf9\u57fa\u7c7b\u7684\u9ed8\u8ba4\u6784\u9020\u51fd\u6570\u7684\u8c03\u7528 \u82e5\u91c7\u7528\u663e\u5f0f\u8c03\u7528\uff0c\u5219\u53ea\u80fd\u5728\u5b50\u7c7b\u6784\u9020\u51fd\u6570\u7684\u521d\u59cb\u5316\u5217\u8868\u4e2d\u8fdb\u884c \u5148\u6267\u884c\u57fa\u7c7b\u7684\u6784\u9020\u51fd\u6570\u6765\u521d\u59cb\u5316\u7ee7\u627f\u6765\u7684\u6570\u636e\uff0c\u518d\u6267\u884c\u5b50\u7c7b\u7684\u6784\u9020\u51fd\u6570\u3002 \u5bf9\u8c61\u6790\u6784\u65f6\uff0c\u5148\u6267\u884c\u5b50\u7c7b\u7684\u6790\u6784\u51fd\u6570\uff0c\u518d\u6267\u884c\u7531\u7f16\u8bd1\u5668\u81ea\u52a8\u8c03\u7528\u7684\u57fa\u7c7b\u7684\u6790\u6784\u51fd\u6570\u3002","title":"\u5b50\u7c7b\u5bf9\u8c61\u7684\u6784\u9020\u4e0e\u6790\u6784\u8fc7\u7a0b"},{"location":"languages/cpp/basic/#_28","text":"\u4ee5\u5982\u4e0b\u4ee3\u7801\u4e3a\u4f8b #include <iostream> using namespace std ; class Base { public : Base ( int _data ) : data ( _data ) { cout << \"Base::Base(\" << _data << \") \\n \" ; } private : int data ; }; class Derive : public Base { public : using Base :: Base ; void print () { cout << \"data = \" << data << endl ; } private : int data { 2020 }; }; int main () { Derive obj ( 356 ); obj . print (); return 0 ; } Derive \u4e2d\u4f7f\u7528 using Base::Base; \u5c06 Base \u4e2d\u7684\u6240\u6709\u6784\u9020\u51fd\u6570\u90fd\u7ee7\u627f\u4e86\u8fc7\u6765\u3002\u6545\u53ef\u4ee5\u8c03\u7528\u5e26\u4e00\u4e2a int \u578b\u53c2\u6570\u7684\u6784\u9020\u51fd\u6570\u3002 Base::Base(356) data = 2020 \u867d\u7136\u57fa\u7c7b\u6784\u9020\u51fd\u6570\u7684\u9ed8\u8ba4\u503c\u4e0d\u4f1a\u88ab\u5b50\u7c7b\u7ee7\u627f\uff0c\u4f46\u7531\u9ed8\u8ba4\u53c2\u6570\u5bfc\u81f4\u7684\u591a\u4e2a\u6784\u9020\u51fd\u6570\u7248\u672c\u90fd\u4f1a\u88ab\u5b50\u7c7b\u7ee7\u627f\u3002 \u5982\u679c\u57fa\u7c7b\u7684\u67d0\u4e2a\u6784\u9020\u51fd\u6570\u88ab\u58f0\u660e\u6210\u79c1\u6709\u6210\u5458\u51fd\u6570\uff0c\u5219\u4e0d\u80fd\u5728\u5b50\u7c7b\u4e2d\u58f0\u660e\u7ee7\u627f\u8be5\u6784\u9020\u51fd\u6570\u3002 \u5982\u679c\u5b50\u7c7b\u4f7f\u7528\u4e86\u7ee7\u627f\u57fa\u7c7b\u6784\u9020\u51fd\u6570\uff0c\u7f16\u8bd1\u5668\u5c31\u4e0d\u4f1a\u518d\u4e3a\u5b50\u7c7b\u751f\u6210\u9ed8\u8ba4\u6784\u9020\u51fd\u6570\u3002","title":"\u7ee7\u627f\u57fa\u7c7b\u7684\u6784\u9020\u51fd\u6570"},{"location":"languages/cpp/basic/#override","text":"","title":"\u51fd\u6570\u91cd\u5199 (override)"},{"location":"languages/cpp/basic/#_29","text":"\u5b50\u7c7b\u5bf9\u8c61\u5305\u542b\u4ece\u57fa\u7c7b\u7ee7\u627f\u6765\u7684\u6570\u636e\u6210\u5458\uff0c\u5b83\u4eec\u6784\u6210\u4e86\u201c\u57fa\u7c7b\u5b50\u5bf9\u8c61\u201d\u3002 \u57fa\u7c7b\u4e2d\u7684\u79c1\u6709\u6210\u5458\uff0c\u4e0d\u5141\u8bb8\u5728\u5b50\u7c7b\u6210\u5458\u51fd\u6570\u4e2d\u88ab\u8bbf\u95ee\uff0c\u4e5f\u4e0d\u5141\u8bb8\u5b50\u7c7b\u7684\u5bf9\u8c61\u8bbf\u95ee\u5b83\u4eec\u3002 \u771f\u6b63\u4f53\u73b0\u201c\u57fa\u7c7b\u79c1\u6709\u201d\uff0c\u5bf9\u5b50\u7c7b\u4e5f\u4e0d\u5f00\u653e\u5176\u6743\u9650 \u57fa\u7c7b\u4e2d\u7684\u516c\u6709\u6210\u5458\uff1a \u82e5\u4f7f\u7528 public \u7ee7\u627f\u65b9\u5f0f\uff0c\u5219\u6210\u4e3a\u5b50\u7c7b\u7684\u516c\u6709\u6210\u5458\uff0c\u65e2\u53ef\u4ee5\u5728\u5b50\u7c7b\u6210\u5458\u4e2d\u8bbf\u95ee\uff0c\u4e5f\u53ef\u4ee5\u88ab\u5b50\u7c7b\u7684\u5bf9\u8c61\u8bbf\u95ee\uff1b \u82e5\u4f7f\u7528 private \u7ee7\u627f\u65b9\u5f0f\uff0c\u5219\u53ea\u80fd\u4f9b\u5b50\u7c7b\u6210\u5458\u51fd\u6570\u7684\u8bbf\u95ee\uff0c\u4e0d\u80fd\u88ab\u5b50\u7c7b\u5bf9\u8c61\u8bbf\u95ee\u3002 \u8003\u8651\u5982\u4e0b\u4ee3\u7801 #include <iostream> using namespace std ; class B { public : void f () { cout << \"in B::f()...\" << endl ; } }; class D1 : public B {}; class D2 : private B { public : void g () { cout << \"in D2::g(), calling f()...\" << endl ; f (); } }; int main () { cout << \"in main()...\" << endl ; D1 obj1 ; cout << \"calling obj1.f()...\" << endl ; obj1 . f (); D2 obj2 ; cout << \"calling obj2.g()...\" << endl ; obj2 . g (); return 0 ; } \u8f93\u51fa in main()... calling obj1.f()... in B::f()... calling obj2.g()... in D2::g(), calling f()... in B::f()... \u5982\u679c\u79c1\u6709\u7ee7\u627f\u7684\u5b50\u7c7b D2 \u8c03\u7528\u7236\u7c7b\u7684\u5171\u6709\u51fd\u6570\uff0c\u5219\u4f1a\u62a5\u9519\uff1a error: \u2018B\u2019 is not an accessible base of \u2018D2 \u8fd9\u91cc\u57fa\u7c7b\u63a5\u53e3\u4e0d\u8bb8\u5b50\u7c7b\u5bf9\u8c61\u8c03\u7528\u3002","title":"\u5b50\u7c7b\u4e2d\u7684\u57fa\u7c7b\u6210\u5458"},{"location":"languages/cpp/basic/#_30","text":"\u57fa\u7c7b\u5df2\u5b9a\u4e49\u7684\u6210\u5458\u51fd\u6570\uff0c\u5728\u5b50\u7c7b\u4e2d\u53ef\u4ee5\u91cd\u65b0\u5b9a\u4e49\uff0c\u8fd9\u88ab\u79f0\u4e3a\u201c\u51fd\u6570\u91cd\u5199\u201d\uff08override\uff09 \u91cd\u5199\u53d1\u751f\u65f6\uff0c\u57fa\u7c7b\u4e2d\u8be5\u6210\u5458\u51fd\u6570\u7684\u5176\u4ed6\u91cd\u8f7d\u51fd\u6570\u90fd\u5c06\u88ab\u5c4f\u853d\u6389\uff0c\u4e0d\u80fd\u63d0\u4f9b\u7ed9\u5b50\u7c7b\u5bf9\u8c61\u4f7f\u7528\u3002 \u53ef\u4ee5\u5728\u5b50\u7c7b\u4e2d\u901a\u8fc7 using \u7c7b\u540d::\u6210\u5458\u51fd\u6570\u540d; \u5728\u5b50\u7c7b\u4e2d\u201c=\u6062\u590d\u201d\u6307\u5b9a\u7684\u57fa\u7c7b\u6210\u5458\u51fd\u6570\uff08\u53bb\u6389\u5c4f\u853d\uff09\uff0c\u4f7f\u4e4b\u91cd\u65b0\u53ef\u7528\u3002 \u8003\u8651\u5982\u4e0b\u4ee3\u7801 #include <iostream> using namespace std ; class T {}; class B { public : void f () { cout << \"B::f() \\n \" ; } void f ( int i ) { cout << \"B::f(\" << i << \") \\n \" ; } void f ( double d ) { cout << \"B::f(\" << d << \") \\n \" ; } void f ( T ) { cout << \"B::f(T) \\n \" ; } }; class D1 : public B { public : void f ( int i ) { cout << \"D1::f(\" << i << \") \\n \" ; } }; int main () { D1 d ; d . f ( 10 ); d . f ( 4.9 ); // d.f(); // d.f(T()) }; \u6ce8\u610f d.f(4.9); \u8fd9\u4e00\u53e5\u7f16\u8bd1\u4f1a\u51fa\u8b66\u544a\uff0c\u7f16\u8bd1\u5668\u6267\u884c\u5f3a\u5236\u7c7b\u578b\u8f6c\u6362\u4f7f\u7528\u6574\u578b\u53c2\u6570\u7684\u51fd\u6570\u7248\u672c\u3002 \u800c\u88ab\u6ce8\u91ca\u7684\u4e24\u4e2a\u8bed\u53e5\u5219\u4f1a\u51fa\u73b0\u7f16\u8bd1\u9519\u8bef\uff0c\u56e0\u4e3a\u91cd\u5199\u5bfc\u81f4\u5176\u4ed6\u91cd\u8f7d\u51fd\u6570\u88ab\u5c4f\u853d\u6389 \u8f93\u51fa D1::f(10) D1::f(4) \u4f7f\u7528 using \u6062\u590d\u57fa\u7c7b\u51fd\u6570 #include <iostream> using namespace std ; class T {}; class B { public : void f () { cout << \"B::f() \\n \" ; } void f ( int i ) { cout << \"B::f(\" << i << \") \\n \" ; } void f ( double d ) { cout << \"B::f(\" << d << \") \\n \" ; } void f ( T ) { cout << \"B::f(T) \\n \" ; } }; class D1 : public B { public : using B :: f ; void f ( int i ) { cout << \"D1::f(\" << i << \") \\n \" ; } }; int main () { D1 d ; d . f ( 10 ); d . f ( 4.9 ); d . f (); d . f ( T ()); return 0 ; }; \u8f93\u51fa D1::f(10) B::f(4.9) B::f() B::f(T)","title":"\u5b50\u7c7b\u91cd\u5199\u57fa\u7c7b\u7684\u6210\u5458\u51fd\u6570"},{"location":"languages/cpp/basic/#_31","text":"","title":"\u865a\u51fd\u6570"},{"location":"languages/cpp/basic/#_32","text":"\u5b50\u7c7b\u5bf9\u8c61\u8f6c\u6362\u6210\u57fa\u7c7b\u5bf9\u8c61\uff0c\u79f0\u4e3a\u5411\u4e0a\u6620\u5c04\u3002\u800c\u57fa\u7c7b\u5bf9\u8c61\u8f6c\u6362\u4e3a\u5b50\u7c7b\u5bf9\u8c61\uff0c\u6210\u4e3a\u5411\u4e0b\u6620\u5c04\u3002 \u5411\u4e0a\u6620\u5c04\u53ef\u4ee5\u7531\u7f16\u8bd1\u5668\u81ea\u52a8\u5b8c\u6210\uff0c\u662f\u4e00\u79cd\u9690\u5f0f\u7684\u81ea\u52a8\u7c7b\u578b\u8f6c\u6362\u3002 \u6240\u6709\u63a5\u53d7\u57fa\u7c7b\u5bf9\u8c61\u7684\u5730\u65b9\uff08\u5982\u51fd\u6570\u53c2\u6570\uff09\uff0c\u90fd\u53ef\u4ee5\u4f7f\u7528\u5b50\u7c7b\u5bf9\u8c61\uff0c\u7f16\u8bd1\u5668\u4f1a\u81ea\u52a8\u5c06\u5b50\u7c7b\u5bf9\u8c61\u8f6c\u6362\u4e3a\u57fa\u7c7b\u5bf9\u8c61\u4ee5\u4fbf\u4f7f\u7528\u3002 \u5728\u5982\u4e0b\u4ee3\u7801\u4e2d\uff0c\u5b50\u7c7b\u91cd\u5199\u4e86\u57fa\u7c7b\u7684 print \u51fd\u6570\uff0c\u5c06\u5b50\u7c7b\u5bf9\u8c61\u4f20\u7ed9\u4ee5\u57fa\u7c7b\u4f5c\u4e3a\u5f62\u53c2\u7684\u51fd\u6570\uff0c\u5b50\u7c7b\u88ab\u9690\u5f0f\u8f6c\u6362\u4e3a\u57fa\u7c7b\uff0c\u6545\u51fd\u6570\u5185\u8c03\u7528\u7684\u662f\u57fa\u7c7b\u7684 print \u51fd\u6570\u3002 #include <iostream> using namespace std ; class Base { public : void print () { cout << \"Base::print()\" << endl ; } }; class Derive : public Base { public : void print () { cout << \"Derive::print()\" << endl ; } }; void fun ( Base obj ) { obj . print (); } int main () { Derive d ; d . print (); fun ( d ); return 0 ; } \u8f93\u51fa Derive::print() Base::print()","title":"\u5411\u4e0a\u6620\u5c04\u548c\u5411\u4e0b\u6620\u5c04"},{"location":"languages/cpp/basic/#_33","text":"\u5bf9\u4e8e\u88ab\u5b50\u7c7b\u91cd\u5199\u7684\u6210\u5458\u51fd\u6570\uff0c\u82e5\u5b83\u5728\u57fa\u7c7b\u4e2d\u88ab\u58f0\u660e\u4e3a\u865a\u51fd\u6570\uff08\u5982\u4e0b\u6240\u793a\uff09\uff0c\u5219\u901a\u8fc7\u79ef\u7d2f\u6307\u9488\u6216\u5f15\u7528\u8c03\u7528\u8be5\u51fd\u6570\u6210\u5458\u65f6\uff0c\u7f16\u8bd1\u5668\u5c06\u6839\u636e\u6240\u6307\uff08\u6216\u5f15\u7528\uff09\u5bf9\u8c61\u7684\u5b9e\u9645\u7c7b\u578b\u51b3\u5b9a\u662f\u8c03\u7528\u79ef\u7d2f\u4e2d\u7684\u51fd\u6570\uff0c\u8fd8\u662f\u8c03\u7528\u5b50\u7c7b\u91cd\u5199\u7684\u51fd\u6570\u3002 class Base { public : virtual \u8fd4\u56de\u7c7b\u578b \u51fd\u6570\u540d ( \u5f62\u53c2 ); ... }; \u82e5\u67d0\u6210\u5458\u51fd\u6570\u5728\u57fa\u7c7b\u4e2d\u88ab\u58f0\u660e\u4e3a\u865a\u51fd\u6570\uff0c\u5f53\u5b50\u7c7b\u91cd\u5199\u5b83\u65f6\uff0c\u65e0\u8bba\u662f\u5426\u58f0\u660e\u4e3a\u865a\u51fd\u6570\uff0c\u8be5\u6210\u5458\u51fd\u6570\u4ecd\u7136\u662f\u865a\u51fd\u6570\u3002 \u5c06\u4e0a\u4e00\u8282\u7684\u4f8b\u5b50\u4e2d\u57fa\u7c7b\u7684 print \u51fd\u6570\u5b9a\u4e49\u4e3a\u865a\u51fd\u6570\uff0c\u800c\u51fd\u6570 fun \u7684\u5f62\u53c2\u6539\u4e3a\u57fa\u7c7b\u7684\u5f15\u7528\u7c7b\u578b\uff0c\u5219\u8c03\u7528\u7684\u5c31\u662f\u865a\u51fd\u6570\u5728\u5b50\u7c7b\u4e2d\u7684\u5b9e\u73b0\u3002 #include <iostream> using namespace std ; class Base { public : virtual void print () { cout << \"Base::print()\" << endl ; } }; class Derive : public Base { public : void print () { cout << \"Derive::print()\" << endl ; } }; void fun ( Base & obj ) { obj . print (); } int main () { Derive d ; d . print (); fun ( d ); return 0 ; } \u8f93\u51fa Derive::print() Derive::print()","title":"\u865a\u51fd\u6570"},{"location":"languages/cpp/basic/#_34","text":"\u57fa\u7c7b\u7684\u6790\u6784\u51fd\u6570\u603b\u662f\u8981\u88ab\u58f0\u660e\u6210 virtual \u7684\uff0c\u8fd9\u6837\u624d\u80fd\u4fdd\u8bc1\u5b50\u7c7b\u5b9a\u4e49\u7684\u6790\u6784\u51fd\u6570\u603b\u80fd\u88ab\u6267\u884c\u3002 \u4e8b\u5b9e\u4e0a\uff0c\u6700\u597d\u7684\u505a\u6cd5\u662f\uff1a\u4efb\u4f55\u7c7b\u7684\u6790\u6784\u51fd\u6570\u90fd\u5e94\u8be5\u88ab\u58f0\u660e\u6210 virtual \u7684\uff0c\u56e0\u4e3a\u8c01\u53c8\u80fd\u4fdd\u8bc1\u8fd9\u4e2a\u7c7b\u4e0d\u4f1a\u88ab\u5176\u4ed6\u7684\u7c7b\u7ee7\u627f\u5462\uff1f #include <iostream> using namespace std ; class B { public : virtual void show () { cout << \"B.show() \\n \" ; } virtual ~ B () { cout << \"~B() \\n \" ; } }; class D : public B { public : void show () { cout << \"D.show() \\n \" ; } ~ D () { cout << \"~D() \\n \" ; } }; void test ( B * ptr ) { ptr -> show (); } int main () { B * ptr = new D ; test ( ptr ); delete ptr ; return 0 ; } \u8f93\u51fa D.show() ~D() ~B() \u4ece\u8f93\u51fa\u53ef\u89c1\u6790\u6784\u51fd\u6570\u7684\u8c03\u7528\u987a\u5e8f\u662f \u5148\u8c03\u7528\u5b50\u7c7b\u7684\u6790\u6784\u51fd\u6570\uff0c\u518d\u8c03\u7528\u57fa\u7c7b\u7684\u6790\u6784\u51fd\u6570 \u3002 \u5982\u679c\u5220\u9664\u57fa\u7c7b\u6790\u6784\u51fd\u6570\u524d\u7684 virtual \u5173\u952e\u5b57\uff0c\u5219\u8f93\u51fa\u4e3a D.show() ~B() \u6b64\u65f6\u5982\u679c\u5b50\u7c7b\u4e2d\u72ec\u6709\u7684\u6570\u636e\u6210\u5458\uff0c\u5219\u4ed6\u4eec\u4e0d\u4f1a\u88ab\u91ca\u653e\uff0c\u8fdb\u800c\u5bfc\u81f4\u5185\u5b58\u6cc4\u9732\u3002","title":"\u865a\u6790\u6784\u51fd\u6570"},{"location":"languages/cpp/basic/#final-c-11","text":"\u4f7f\u7528 final \u7ba1\u554a\u67b6\u5b50\u4fee\u9970\u7684\u865a\u51fd\u6570\uff0c\u5b50\u7c7b\u4e0d\u53ef\u5bf9\u5b83\u8fdb\u884c\u91cd\u5199 \u2014\u2014 \u6539\u53d8\u51fd\u6570\u7684\u5b9a\u4e49\u3002 \u5728\u6d3e\u751f\u8fc7\u7a0b\u4e2d\uff0c final \u53ef\u4ee5\u518d\u7ee7\u627f\u5173\u7cfb\u94fe\u7684 \u4e2d\u9014 \u8fdb\u884c\u8bbe\u5b9a\uff0c\u7981\u6b62\u540e\u7eed\u5b50\u7c7b\u5bf9\u6307\u5b9a\u865a\u51fd\u6570\u91cd\u5199\u3002 \u4e0b\u5c5e\u4ee3\u7801\u4e2d\uff0c class C \u7684\u5b9e\u73b0\u662f\u65e0\u6cd5\u901a\u8fc7\u7f16\u8bd1\u7684\u3002 class A { public : virtual void fun () = 0 ; }; class B : public A { public : void fun () final ; }; class C : public B { public : void fun (); }; class A \u4e2d\u7684 virtual void fun() = 0; \u5c06 fun() \u5b9a\u4e49\u4e3a\u4e00\u4e2a \u7eaf\u865a\u51fd\u6570 \u3002 A \u7531\u6b64\u6210\u4e3a\u4e00\u4e2a \u62bd\u8c61\u7c7b \u3002 C++\u4e2d\u62bd\u8c61\u7c7b\u4e0d\u80fd\u7528\u4e8e\u5b9a\u4e49\u5bf9\u8c61\uff0c\u8fd9\u6837\u7684\u7c7b\u4e00\u822c\u7528\u4e8e \u5b9a\u4e49\u63a5\u53e3 \u3002","title":"\u7981\u6b62\u91cd\u5199\u7684\u865a\u51fd\u6570final (c++ 11\u5f15\u5165)"},{"location":"languages/cpp/basic/#_35","text":"","title":"\u81ea\u52a8\u7c7b\u578b\u8f6c\u6362"},{"location":"languages/cpp/basic/#-_2","text":"#include <iostream> using namespace std ; class Dst { public : Dst () { cout << \"Dst::Dst()\" << endl ; } }; class Src { public : Src () { cout << \"Src::operator Dst() called\" << endl ; } operator Dst () const { cout << \"Src::operator Dst() called\" << endl ; return Dst (); } };","title":"\u65b9\u6cd5\u4e00 - \u5728\u6e90\u7c7b\u4e2d\u5b9a\u4e49\u201c\u76ee\u6807\u7c7b\u578b\u8f6c\u6362\u8fd0\u7b97\u7b26\u201d"},{"location":"languages/cpp/basic/#-_3","text":"#include <iostream> using namespace std ; class Src ; class Dst { public : Dst () { cout << \"Dst::Dst()\" << endl ; } Dst ( const Src & s ) { cout << \"Dst::Dst(const Src&)\" << endl ; } }; class Src { public : Src () { cout << \"Src::Src()\" << endl ; } }; \u6ce8\uff1a class Src; \u8fd9\u4e00\u884c\u662f\u4e00\u4e2a\u524d\u7f6e\u7684\u7c7b\u578b\u58f0\u660e\uff0c\u56e0\u4e3a\u5728 Dst \u7684\u5b9a\u4e49\u4e2d\u8981\u7528\u5230 Src \u7c7b\u3002","title":"\u65b9\u6cd5\u4e8c - \u5728\u76ee\u6807\u7c7b\u4e2d\u5b9a\u4e49\u201c\u6e90\u7c7b\u5bf9\u8c61\u505a\u53c2\u6570\u7684\u6784\u9020\u51fd\u6570\u201d"},{"location":"languages/cpp/basic/#_36","text":"\u6d4b\u8bd5\u4ee3\u7801\u5982\u4e0b\uff08\u9690\u5f0f\u8f6c\u6362\uff09 void Func ( Dst d ) {} int main () { Src s ; Dst d1 ( s ); // \u8fd9\u662f\u76f4\u63a5\u6784\u9020\uff0c\u4e0d\u662f\u7c7b\u578b\u8f6c\u6362 Dst d2 = s ; // \u81ea\u52a8\u7c7b\u578b\u8f6c\u6362\uff0c\u4e0d\u662f\u62f7\u8d1d\u6784\u9020\u51fd\u6570 Func ( s ); // \u81ea\u52a8\u7c7b\u578b\u8f6c\u6362 return 0 \uff1b } \u6ce8\u610f\uff1a\u4e24\u79cd\u81ea\u5b9a\u4e49\u7c7b\u578b\u8f6c\u6362\u7684\u65b9\u6cd5\u4e0d\u80fd\u540c\u65f6\u4f7f\u7528\uff0c\u53ea\u6709\u5728\u4e0a\u8ff0\u65b9\u6cd5\u4e00\u548c\u65b9\u6cd5\u4e8c\u4f7f\u7528\u4e14\u4f7f\u7528\u4e00\u4e2a\u7684\u524d\u63d0\u4e0b\u624d\u80fd\u7f16\u8bd1\u901a\u8fc7\u3002","title":"\u81ea\u52a8\u7c7b\u578b\u8f6c\u6362\u4e3e\u4f8b"},{"location":"languages/cpp/basic/#_37","text":"","title":"\u7981\u6b62\u81ea\u52a8\u7c7b\u578b\u8f6c\u6362"},{"location":"languages/cpp/basic/#-explicit","text":"#include <iostream> using namespace std ; class Src ; class Dst { public : Dst () { cout << \"Dst::Dst()\" << endl ; } explicit // <1> \u4e0d\u51c6\u7528\u4e8e\u81ea\u52a8\u7c7b\u578b\u8f6c\u6362 Dst ( const Src & s ) { cout << \"Dst::Dst(const Src&)\" << endl ; } }; class Src { public : Src () { cout << \"Src::Src()\" << endl ; } explicit // <2> \u4e0d\u51c6\u7528\u4e8e\u81ea\u52a8\u7c7b\u578b\u8f6c\u6362 operator Dst () const { cout << \"Src::operator Dst() called\" << endl ; return Dst (); } }; <1> - \u8be5\u51fd\u6570\u53ea\u7528\u4e8e\u6784\u9020\u51fd\u6570\uff0c\u4e0d\u7528\u4e8e\u81ea\u52a8\u7c7b\u578b\u8f6c\u6362\uff08\u4e0d\u80fd\u81ea\u52a8\u8c03\u7528\uff09 <2> - \u8be5\u51fd\u6570\u53ea\u7528\u4e8e\u7c7b\u578b\u8f6c\u6362\uff0c\u4e0d\u7528\u4e8e\u81ea\u52a8\u7c7b\u578b\u8f6c\u6362\uff08\u4e0d\u80fd\u81ea\u52a8\u8c03\u7528\uff09 \u4e3a\u6b64\uff0c\u5982\u60f3\u8ba9\u4e0b\u65b9\u4ee3\u7801\u901a\u8fc7\uff0c\u4e0a\u65b9\u4ee3\u7801\u4e2d\u4e24\u5904 explicit \u5fc5\u987b\u4fdd\u7559\u4e14\u4ec5\u4fdd\u7559\u4e00\u5904\u3002 void Func ( Dst d ) {} int main () { Src s ; Dst d1 ( s ); Dst d2 = s ; Func ( s ); return 0 ; }","title":"\u65b9\u6cd5\u4e00 - explicit\u5173\u952e\u5b57"},{"location":"languages/cpp/basic/#-delete-c-11","text":"\u4f7f\u7528 =delete \u4fee\u9970\u7684\u6210\u5458\u51fd\u6570\uff0c\u4e0d\u5141\u8bb8\u88ab\u8c03\u7528\u3002 #include <iostream> using namespace std ; class T { public : T ( int ) {} T ( char ) = delete ; // \u53ef\u6d88\u9664\u81ea\u52a8\u7c7b\u578b\u8f6c\u6362\u5e26\u6765\u7684\u9690\u60a3\uff0c\u5982\u6ca1\u6709` = delete`\u4fee\u9970\u7b26\uff0c\u5219\u4e3b\u51fd\u6570\u4e2d\u7684\u8bed\u53e5\u90fd\u80fd\u7f16\u8bd1\u901a\u8fc7\u3002 }; void Fun ( T t ) {} int main () { Fun ( 1 ); // Fun('X'); \u81ea\u52a8\u7c7b\u578b\u8f6c\u6362\u5931\u8d25\uff0c\u7f16\u8bd1\u4e0d\u901a\u8fc7 T ci ( 1 ); // T cc('X'); \u81ea\u52a8\u7c7b\u578b\u8f6c\u6362\u5931\u8d25\uff0c\u7f16\u8bd1\u4e0d\u901a\u8fc7 return 0 ; } =delete \u4fee\u9970\u4e00\u4e2a\u51fd\u6570 \u548c \u4e0d\u5199\u8fd9\u4e2a\u51fd\u6570 \u7684\u533a\u522b:","title":"\u65b9\u6cd5\u4e8c - =delete\u9650\u5b9a (C++ 11 \u5f15\u5165)"},{"location":"languages/cpp/basic/#_38","text":"dynamic_cast<Dst_type>(Src_var) - \u7528\u4e8e\u5728\u7c7b\u7684\u96c6\u6210\u4f53\u7cfb\u4e2d\u505a\u8f6c\u6362 Src_var \u5fc5\u987b\u662f\u5f15\u7528\u6216\u6307\u9488\u7c7b\u578b\uff0c Dst_Type \u7c7b\u4e2d\u542b\u6709\u865a\u51fd\u6570\uff0c\u5426\u5219\u4f1a\u6709\u7f16\u8bd1\u9519\u8bef \u82e5\u76ee\u6807\u7c7b\u4e0e\u539f\u7c7b\u4e4b\u95f4\u6ca1\u6709\u53ca\u9648\u9aa8\u5e72\u897f\uff0c\u8f6c\u6362\u5931\u8d25\uff0c\u8fd4\u56de\u7a7a\u6307\u9488\uff08\u6ce8\uff1a\u5931\u8d25\u4e0d\u5bfc\u81f4\u8fd0\u884c\u5d29\u6e83\uff09 static_cast<Dst_Type>(Src_var) \u57fa\u7c7b\u5bf9\u8c61\u4e0d\u80fd\u8f6c\u6362\u6210\u5b50\u7c7b\u5bf9\u8c61\uff0c\u4f46\u57fa\u7c7b\u6307\u9488\u53ef\u4ee5\u8f6c\u6362\u6210\u5b50\u7c7b\u6307\u9488 \u5b50\u7c7b\u5bf9\u8c61\uff08\u6307\u9488\uff09\u53ef\u4ee5\u8f6c\u6362\u6210\u57fa\u7c7b\u5bf9\u8c61\uff08\u6307\u9488\uff09 \u6ca1\u6709\u7ee7\u627f\u5173\u7cfb\u7684\u7c7b\u4e4b\u95f4\uff0c\u5fc5\u987b\u5177\u6709\u8f6c\u6362\u9014\u5f84\u624d\u80fd\u8fdb\u884c\u8f6c\u6362\uff08\u81ea\u5b9a\u4e49\u6216\u8005\u8bed\u8a00\u8bed\u6cd5\u539f\u751f\u652f\u6301\uff09 \u4ee5\u5982\u4e0b\u4ee3\u7801\u4e3a\u4f8b #include <iostream> using namespace std ; class B { public : virtual void f () {} }; class D : public B {}; class E {}; int main () { D d1 ; B b1 ; // d1 = static_cast<D>(b1); /// Error: \u4ece\u57fa\u7c7b\u65e0\u6cd5\u8f6c\u6362\u56de\u5b50\u7c7b b1 = static_cast < B > ( d1 ); /// OK: \u53ef\u4ee5\u4ece\u5b50\u7c7b\u8f6c\u6362\u5230\u57fa\u7c7b // b1 - dynamic_cast<B>(d1); /// ERROR: \u88ab\u8f6c\u6362\u7684\u5fc5\u987b\u662f\u5f15\u7528\u6216\u6307\u9488 B * pb1 = new B (); D * pd1 = static_cast < D *> ( pb1 ); if ( pd1 ) { cout << \"static_cast, B* --> D*: OK\" << endl ; } pd1 = dynamic_cast < D *> ( pb1 ); if ( pd1 ) { cout << \"dynamic_cast, B* --> D*: OK\" << endl ; } D * pd2 = new D (); B * pb2 = static_cast < B *> ( pd2 ); if ( pb2 ) { cout << \"static_cast, D* --> B*: OK\" << endl ; } pb2 = dynamic_cast < B *> ( pd2 ); if ( pb2 ) { cout << \"dynamic_cast, D* --> B*: OK\" << endl ; } E * pe = dynamic_cast < E *> ( pb1 ); if ( ! pe ) { cout << \"dynamic_cast, B* --> E*: FAILED\" << endl ; } // pe = static_cast<E*>(pb1); /// ERROR: \u6ca1\u6709\u7ee7\u627f\u5173\u7cfb\u4e0d\u80fd\u8f6c\u6362 // E e = static_cast<E>(b1); /// ERROR\uff1a\u6ca1\u6709\u63d0\u4f9b\u8f6c\u6362\u9014\u5f84 return 0 ; } \u8f93\u51fa static_cast, B* --> D*: OK static_cast, D* --> B*: OK dynamic_cast, D* --> B*: OK dynamic_cast, B* --> E*: FAILED","title":"\u5f3a\u5236\u7c7b\u578b\u8f6c\u6362\uff08\u663e\u5f0f\u8f6c\u6362\uff09"},{"location":"languages/cpp/basic/#_39","text":"\u6709\u4e9b\u7b97\u6cd5\u5b9e\u73b0\u4e0e\u7c7b\u578b\u65e0\u5173\uff0c\u6240\u4ee5\u53ef\u4ee5\u5c06\u51fd\u6570\u7684\u53c2\u6570\u7c7b\u578b\u4e5f\u5b9a\u4e49\u4e3a\u4e00\u79cd\u7279\u6b8a\u7684\u201c\u53c2\u6570\u201d\uff0c\u8fd9\u6837\u5c31\u5f97\u5230\u4e86\u201c\u51fd\u6570\u6a21\u677f\u201d\u3002 \u5b9a\u4e49\u51fd\u6570\u6a21\u677f\u7684\u65b9\u6cd5 template < typename T > \u8fd4\u56de\u7c7b\u578b \u51fd\u6570\u540d ( \u51fd\u6570\u53c2\u6570 ) \uff1b \u4f8b\u5982\uff0c\u4efb\u610f\u4e24\u4e2a\u53d8\u91cf\u76f8\u52a0\u7684\u201c\u51fd\u6570\u6a21\u677f\u201d template < typename T > T sum ( T a , T b ) { return a + b ; } \u51fd\u6570\u6a21\u677f\u5728\u8c03\u7528\u65f6\uff0c\u56e0\u4e3a\u7f16\u8bd1\u5668\u80fd\u81ea\u52a8\u63a8\u5bfc\u51fa\u5b9e\u9645\u53c2\u6570\u7684\u7c7b\u578b\uff0c\u6240\u4ee5\uff0c\u5f62\u5f0f\u4e0a\u8c03\u7528\u4e00\u4e2a\u51fd\u6570\u6a21\u677f\u4e0e\u666e\u901a\u51fd\u6570\u6ca1\u6709\u533a\u522b\uff0c\u5982 int main () { int a = 3 , b = 4 ; cout << sum ( a , b ); float c = 1.3 , d = 1.9 ; cout << sum ( c , d ); } \u51fd\u6570\u6a21\u677f\u53c2\u6570\u4e5f\u53ef\u4ee5\u8d4b\u9ed8\u8ba4\u503c\uff08\u7f3a\u7701\u503c\uff09\uff0c\u5982 #include <iostream> using namespace std ; template < typename T0 = float , typename T1 , typename T2 = float , typename T3 , typename T4 > T0 func ( T1 v1 , T2 v2 = 0 , T3 v3 , T4 v4 ) {...} func ( 1 , 2 , 3 , 4 ); func ( 'a' , 'b' , \"cde\" , 5 );","title":"\u51fd\u6570\u6a21\u677f"},{"location":"languages/cpp/basic/#_40","text":"\u5728\u5b9a\u4e49\u7c7b\u65f6\u4e5f\u53ef\u4ee5\u5c06\u4e00\u4e9b\u7c7b\u578b\u4fe1\u606f\u62bd\u53d6\u51fa\u6765\uff0c\u7528\u6a21\u677f\u53c2\u6570\u6765\u66ff\u6362\uff0c\u4ece\u800c\u4f7f\u7c7b\u66f4\u5177\u6709\u901a\u7528\u6027\u3002\u8fd9\u79cd\u7c7b\u88ab\u79f0\u4e3a\u201c\u7c7b\u6a21\u677f\u201d\u3002 template < typename T > class A { public : void print () { cout << data << endl ; } private : T data ; }; \u7c7b\u6a21\u677f \u2192 \u7c7b \u2192 \u5bf9\u8c61 \u7c7b\u6a21\u677f\u7684\u201c\u6a21\u677f\u53c2\u6570\u201d \u7c7b\u578b\u53c2\u6570\uff1a\u4f7f\u7528 typename \u6216 class \u6807\u8bb0 \u975e\u7c7b\u578b\u53c2\u6570\uff1a\u6574\u6570\uff0c\u679a\u4e3e\uff0c\u6307\u9488\uff08\u6307\u5411\u5bf9\u8c61\u6216\u51fd\u6570\uff09\uff0c\u5f15\u7528\uff08\u5f15\u7528\u5bf9\u8c61\u6216\u5f15\u7528\u51fd\u6570\uff09\u3002\u5176\u4e2d\u6574\u6570\u7c7b\u578b\u662f\u6bd4\u8f83\u5e38\u7528\u7684\uff0c\u5982 template < typename T , unsigned size > class Array { T elems [ size ]; ... }; Array < char , 10 > array ; \u6a21\u677f\u53c2\u6570\u662f\u53e6\u4e00\u4e2a\u7c7b\u6a21\u677f\uff0c\u5982\u4e0b\u6240\u793a\uff1a template < typename T , template < typename TT0 , typename TT1 > class A > struct Foo { A < T , T > bar ; };","title":"\u7c7b\u6a21\u677f"},{"location":"languages/cpp/basic/#_41","text":"\u666e\u901a\u7c7b\u4e2d\u5b9a\u4e49\u6210\u5458\u51fd\u6570\u6a21\u677f class NormalClass { public : int value ; template < typename T > void set ( T const & v ) { value = int ( v ); } template < typename T > T get (); }; template < typename T > T NormalClass :: get () { return valuel ; } \u7c7b\u6a21\u677f\u4e2d\u5b9a\u4e49\u6210\u5458\u51fd\u6570\u6a21\u677f template < typename T0 > class A { public : T0 value ; template < typename T1 > void set ( T1 const & v ) { value = T0 ( v ); } template < typename T1 > T1 get (); }; template < typename T0 > template < typename T1 > T1 A :: get () { return T1 ( value ); } \u5bf9\u4e8e\u7c7b\u6a21\u677f\u5916\u9762\u5b9a\u4e49\u7684\u6210\u5458\u51fd\u6570\u6a21\u677f\uff0c\u4f1a\u62a5\u7f16\u8bd1\u9519\u8bef % g++ main.cpp -std=c++11 -o main main.cpp:16:4: error: \u2018template<class T0> class A\u2019 used without template parameters T1 A::get() { ^ main.cpp:16:4: error: too many template-parameter-lists","title":"\u6210\u5458\u51fd\u6570\u6a21\u677f"},{"location":"languages/cpp/basic/#_42","text":"\u6a21\u677f\u53c2\u6570\u7684\u5177\u4f53\u5316/\u7279\u6b8a\u5316 \u6709\u65f6\uff0c\u6709\u4e9b\u7c7b\u578b\u5e76\u4e0d\u9002\u7528\uff0c\u5219\u9700\u8981\u5bf9\u6a21\u677f\u8fdb\u884c\u7279\u6b8a\u5316\u5904\u7406\uff0c\u8fd9\u79f0\u4e3a\u201c\u6a21\u677f\u7279\u5316\u201d\u3002 \u5bf9\u4e8e\u51fd\u6570\u6a21\u677f\uff0c\u5982\u679c\u6709\u591a\u4e2a\u6a21\u677f\u53c2\u6570\uff0c\u5219\u7279\u5316\u65f6\u5fc5\u987b\u63d0\u4f9b\u6240\u6709\u53c2\u6570\u7684\u7279\u4f8b\u7c7b\u578b\uff0c \u4e0d\u80fd\u90e8\u5206\u7279\u5316 \u3002 \u5982 char* Sum(char* char*); \u5728\u51fd\u6570\u540d\u540e\u7528<>\u62ec\u53f7\u6269\u8d77\u5177\u4f53\u7c7b\u578b template <> char * Sum < char *> ( char * a , char * b ) {...} \u7531\u7f16\u8bd1\u5668\u63a8\u5bfc\u51fa\u5177\u4f53\u7c7b\u578b\uff0c\u51fd\u6570\u540d\u4e3a\u666e\u901a\u5f62\u5f0f template <> char * Sum ( char * a , char * b ) {...}","title":"\u6a21\u677f\u7279\u5316"},{"location":"languages/cpp/basic/#_43","text":"\u5bf9\u4e8e\u7c7b\u6a21\u677f\uff0c\u5141\u8bb8\u90e8\u5206\u7279\u5316\uff0c\u5373\u90e8\u5206\u9650\u5236\u6a21\u677f\u7684\u901a\u7528\u6027\uff0c\u5982\uff1a // \u901a\u7528\u6a21\u677f\u7c7b template < class T1 , class T2 > class A {...}; // \u90e8\u5206\u7279\u5316\u7684\u6a21\u677f\u7c7b\uff1a\u7b2c\u4e8c\u4e2a\u7c7b\u578b\u53c2\u6570\u6307\u5b9a\u4e3a int template < class T1 > class A < T1m int > {...}; \u82e5\u6307\u5b9a\u6240\u6709\u7c7b\u578b\uff0c\u5219<>\u5185\u5c06\u4e3a\u7a7a tempalte <> class A < int , int > {...}; \u51fd\u6570\u6a21\u677f\u7279\u5316\u793a\u4f8b #include <bits/stdc++.h> using namespace std ; template < typename T > T Sum ( T a , T b ) { return a + b ; } template <> char * Sum ( char * a , char * b ) { char * p = new char [ strlen ( a ), strlen ( b ) + 1 ]; strcpy ( p , a ); strcpy ( p + strlen ( a ), b ); return p ; } int main () { cout << Sum ( 3 , 4 ) << ' ' << Sum ( 5.1 , 13.8 ) << endl ; char str1 [] = \"Hello, \" , str2 [] = \"world\" ; cout << Sum ( str1 , str2 ) << endl ; return 0 ; } \u8f93\u51fa 7 18.9 Hello, world \u7c7b\u6a21\u677f\u7279\u5316\u793a\u4f8b #include <bits/stdc++.h> using namespace std ; template < typename T > class Sum { public : Sum ( T op1 , T op2 ) : a ( op1 ), b ( op2 ) {} T DoIT () { return a + b ; } private : T a , b ; }; template <> class Sum < char *> { public : Sum ( char * s1 , char * s2 ) : str1 ( s1 ), str2 ( s2 ) {} char * DoIT () { char * tmp = new char [ strlen ( str1 ) + strlen ( str2 ) + 1 ]; strcpy ( tmp , str1 ); strcat ( tmp + strlen ( str1 ), str2 ); return tmp ; } private : char * str1 , * str2 ; }; int main () { Sum < int > obj1 ( 3 , 4 ); cout << obj1 . DoIT () << endl ; char s1 [] = \"Hello\" , s2 [] = \"THU\" ; Sum < char *> obj2 ( s1 , s2 ); cout << obj2 . DoIT () << endl ; return 0 ; } \u8f93\u51fa\uff1a 7 HelloTHU","title":"\u6a21\u677f\u7684\u90e8\u5206\u7279\u5316\uff08\u504f\u7279\u5316\uff09"},{"location":"languages/cpp/effective_cpp/","text":"Effective C++","title":"Effective C++"},{"location":"languages/cpp/effective_cpp/#effective-c","text":"","title":"Effective C++"},{"location":"machine_learning/","text":"","title":"\u673a\u5668\u5b66\u4e60"},{"location":"open_source/browser/chromium/","text":"Chromium Home: https://www.chromium.org/ Github: https://github.com/chromium/chromium","title":"Chromium"},{"location":"open_source/browser/chromium/#chromium","text":"Home: https://www.chromium.org/ Github: https://github.com/chromium/chromium","title":"Chromium"},{"location":"open_source/database/leveldb/","text":"LevelDB Updated: 2020.6.4 Github Authors: Sanjay Ghemawat ( sanjay@google.com ) and Jeff Dean ( jeff@google.com ) \u80cc\u666f\u548c\u7814\u53d1\u52a8\u673a \u4e3b\u4f53\u6846\u67b6 \u8bbe\u8ba1\u4eae\u70b9","title":"LevelDB"},{"location":"open_source/database/leveldb/#leveldb","text":"Updated: 2020.6.4 Github Authors: Sanjay Ghemawat ( sanjay@google.com ) and Jeff Dean ( jeff@google.com )","title":"LevelDB"},{"location":"open_source/database/leveldb/#_1","text":"","title":"\u80cc\u666f\u548c\u7814\u53d1\u52a8\u673a"},{"location":"open_source/database/leveldb/#_2","text":"","title":"\u4e3b\u4f53\u6846\u67b6"},{"location":"open_source/database/leveldb/#_3","text":"","title":"\u8bbe\u8ba1\u4eae\u70b9"},{"location":"open_source/streaming/flink/","text":"Flink Home: https://flink.apache.org/ Github: https://github.com/apache/flink","title":"Flink"},{"location":"open_source/streaming/flink/#flink","text":"Home: https://flink.apache.org/ Github: https://github.com/apache/flink","title":"Flink"},{"location":"open_source/streaming/spark/","text":"Spark Home: https://spark.apache.org/ Github: https://github.com/apache/spark","title":"Spark"},{"location":"open_source/streaming/spark/#spark","text":"Home: https://spark.apache.org/ Github: https://github.com/apache/spark","title":"Spark"},{"location":"open_source/streaming/storm/","text":"Strom Home: https://storm.apache.org/ Github: https://github.com/apache/storm","title":"Storm"},{"location":"open_source/streaming/storm/#strom","text":"Home: https://storm.apache.org/ Github: https://github.com/apache/storm","title":"Strom"},{"location":"operating_system/","text":"","title":"\u64cd\u4f5c\u7cfb\u7edf"},{"location":"survey/cdn/","text":"\u5185\u5bb9\u5206\u53d1\u7f51\u7edc Content Delivery Network \u66f4\u65b0\u65e5\u671f\uff1a2020.5.30 \u6982\u8ff0 CDN\uff08Content Delivery Network\uff0c\u5185\u5bb9\u5206\u53d1\u7f51\u7edc\uff09\u662f\u6784\u5efa\u5728\u73b0\u6709\u4e92\u8054\u7f51\u57fa\u7840\u4e4b\u4e0a\u7684\u4e00\u5c42\u667a\u80fd\u865a\u62df\u7f51\u7edc\uff0c\u901a\u8fc7\u5728\u7f51\u7edc\u9694\u51fa\u90e8\u7f72\u8282\u70b9\u670d\u52a1\u5668\uff0c\u5b9e\u73b0\u5c06\u6e90\u7ad9\u5185\u5bb9\u5206\u53d1\u81f3\u6240\u6709CDN\u8282\u70b9\uff0c\u4f7f\u7528\u6237\u53ef\u4ee5\u5c31\u8fd1\u83b7\u5f97\u6240\u9700\u5185\u5bb9\u3002CDN\u670d\u52a1\u7f29\u77ed\u4e86\u7528\u6237\u67e5\u770b\u5185\u5bb9\u7684\u8bbf\u95ee\u5ef6\u8fdf\uff0c\u63d0\u9ad8\u4e86\u7528\u6237\u8bbf\u95ee\u7f51\u7ad9\u7684\u54cd\u5e94\u901f\u5ea6\u548c\u7f51\u7ad9\u7684\u53ef\u7528\u6027\uff0c\u89e3\u51b3\u4e86\u7f51\u7edc\u5e26\u5bbd\u5c0f\u3001\u7528\u6237\u8bbf\u95ee\u91cf\u5927\u3001\u7f51\u70b9\u5206\u5e03\u4e0d\u5747\u7b49\u95ee\u9898\u3002 \u52a0\u901f\u539f\u7406 \u5f53\u7528\u6237\u8bbf\u95ee\u4f7f\u7528CDN\u670d\u52a1\u7684\u7f51\u7ad9\u65f6\uff0c\u672c\u5730DNS\u670d\u52a1\u5668\u901a\u8fc7CNAME\u65b9\u5f0f\u5c06\u6700\u7ec8\u57df\u540d\u8bf7\u6c42\u91cd\u5b9a\u5411\u5230CDN\u670d\u52a1\u3002CDN\u901a\u8fc7\u4e00\u7ec4\u9884\u5148\u5b9a\u4e49\u597d\u7684\u7b56\u7565\uff08\u6839\u636e\u5185\u5bb9\u7c7b\u578b\u3001\u5730\u7406\u533a\u57df\u3001\u7f51\u7edc\u8d1f\u8f7d\u60c5\u51b5\u7b49\uff09\uff0c\u5c06\u5f53\u65f6\u80fd\u591f\u6700\u5feb\u54cd\u5e94\u7528\u6237\u7684CDN\u8282\u70b9IP\u5730\u5740\u63d0\u4f9b\u7ed9\u7528\u6237\uff0c\u662f\u7528\u6237\u53ef\u4ee5\u4ee5\u6700\u5feb\u7684\u901f\u5ea6\u83b7\u5f97\u7f51\u7ad9\u5185\u5bb9\u3002\u4f7f\u7528CDN\u540e\u7684HTTP\u8bf7\u6c42\u5904\u7406\u6d41\u7a0b\u5982\u4e0b\uff1a CDN\u8282\u70b9\u6709\u7f13\u5b58\u573a\u666f \u56fe1. HTTP\u8bf7\u6c42\u5904\u7406\u6d41\u7a0b\uff08\u8282\u70b9\u6709\u7f13\u5b58\u573a\u666f\uff09 CDN\u8282\u70b9\u65e0\u7f13\u5b58\u573a\u666f\uff08\u589e\u52a0\u56de\u6e90\u6b65\u9aa4\uff09 \u56fe1. HTTP\u8bf7\u6c42\u5904\u7406\u6d41\u7a0b\uff08\u8282\u70b9\u6709\u7f13\u5b58\u573a\u666f\uff09 \u53c2\u8003\u6587\u732e [1] \u534e\u4e3a\u4e91 \u4ec0\u4e48\u662fCDN https://support.huaweicloud.com/productdesc-cdn/zh-cn_topic_0064907747.html [2] lin_zone CDN\u6280\u672f\u539f\u7406\u6982\u8981 https://cloud.tencent.com/developer/article/1185727","title":"CDN"},{"location":"survey/cdn/#_1","text":"Content Delivery Network \u66f4\u65b0\u65e5\u671f\uff1a2020.5.30","title":"\u5185\u5bb9\u5206\u53d1\u7f51\u7edc"},{"location":"survey/cdn/#_2","text":"CDN\uff08Content Delivery Network\uff0c\u5185\u5bb9\u5206\u53d1\u7f51\u7edc\uff09\u662f\u6784\u5efa\u5728\u73b0\u6709\u4e92\u8054\u7f51\u57fa\u7840\u4e4b\u4e0a\u7684\u4e00\u5c42\u667a\u80fd\u865a\u62df\u7f51\u7edc\uff0c\u901a\u8fc7\u5728\u7f51\u7edc\u9694\u51fa\u90e8\u7f72\u8282\u70b9\u670d\u52a1\u5668\uff0c\u5b9e\u73b0\u5c06\u6e90\u7ad9\u5185\u5bb9\u5206\u53d1\u81f3\u6240\u6709CDN\u8282\u70b9\uff0c\u4f7f\u7528\u6237\u53ef\u4ee5\u5c31\u8fd1\u83b7\u5f97\u6240\u9700\u5185\u5bb9\u3002CDN\u670d\u52a1\u7f29\u77ed\u4e86\u7528\u6237\u67e5\u770b\u5185\u5bb9\u7684\u8bbf\u95ee\u5ef6\u8fdf\uff0c\u63d0\u9ad8\u4e86\u7528\u6237\u8bbf\u95ee\u7f51\u7ad9\u7684\u54cd\u5e94\u901f\u5ea6\u548c\u7f51\u7ad9\u7684\u53ef\u7528\u6027\uff0c\u89e3\u51b3\u4e86\u7f51\u7edc\u5e26\u5bbd\u5c0f\u3001\u7528\u6237\u8bbf\u95ee\u91cf\u5927\u3001\u7f51\u70b9\u5206\u5e03\u4e0d\u5747\u7b49\u95ee\u9898\u3002","title":"\u6982\u8ff0"},{"location":"survey/cdn/#_3","text":"\u5f53\u7528\u6237\u8bbf\u95ee\u4f7f\u7528CDN\u670d\u52a1\u7684\u7f51\u7ad9\u65f6\uff0c\u672c\u5730DNS\u670d\u52a1\u5668\u901a\u8fc7CNAME\u65b9\u5f0f\u5c06\u6700\u7ec8\u57df\u540d\u8bf7\u6c42\u91cd\u5b9a\u5411\u5230CDN\u670d\u52a1\u3002CDN\u901a\u8fc7\u4e00\u7ec4\u9884\u5148\u5b9a\u4e49\u597d\u7684\u7b56\u7565\uff08\u6839\u636e\u5185\u5bb9\u7c7b\u578b\u3001\u5730\u7406\u533a\u57df\u3001\u7f51\u7edc\u8d1f\u8f7d\u60c5\u51b5\u7b49\uff09\uff0c\u5c06\u5f53\u65f6\u80fd\u591f\u6700\u5feb\u54cd\u5e94\u7528\u6237\u7684CDN\u8282\u70b9IP\u5730\u5740\u63d0\u4f9b\u7ed9\u7528\u6237\uff0c\u662f\u7528\u6237\u53ef\u4ee5\u4ee5\u6700\u5feb\u7684\u901f\u5ea6\u83b7\u5f97\u7f51\u7ad9\u5185\u5bb9\u3002\u4f7f\u7528CDN\u540e\u7684HTTP\u8bf7\u6c42\u5904\u7406\u6d41\u7a0b\u5982\u4e0b\uff1a CDN\u8282\u70b9\u6709\u7f13\u5b58\u573a\u666f \u56fe1. HTTP\u8bf7\u6c42\u5904\u7406\u6d41\u7a0b\uff08\u8282\u70b9\u6709\u7f13\u5b58\u573a\u666f\uff09 CDN\u8282\u70b9\u65e0\u7f13\u5b58\u573a\u666f\uff08\u589e\u52a0\u56de\u6e90\u6b65\u9aa4\uff09 \u56fe1. HTTP\u8bf7\u6c42\u5904\u7406\u6d41\u7a0b\uff08\u8282\u70b9\u6709\u7f13\u5b58\u573a\u666f\uff09","title":"\u52a0\u901f\u539f\u7406"},{"location":"survey/cdn/#_4","text":"[1] \u534e\u4e3a\u4e91 \u4ec0\u4e48\u662fCDN https://support.huaweicloud.com/productdesc-cdn/zh-cn_topic_0064907747.html [2] lin_zone CDN\u6280\u672f\u539f\u7406\u6982\u8981 https://cloud.tencent.com/developer/article/1185727","title":"\u53c2\u8003\u6587\u732e"},{"location":"survey/ecs/","text":"\u5f39\u6027\u4e91\u670d\u52a1\u5668 Elastic Cloud Server","title":"ECS"},{"location":"survey/ecs/#_1","text":"Elastic Cloud Server","title":"\u5f39\u6027\u4e91\u670d\u52a1\u5668"},{"location":"survey/oss/","text":"\u5bf9\u8c61\u5b58\u50a8\u670d\u52a1 Object Storage Service","title":"OSS"},{"location":"survey/oss/#_1","text":"Object Storage Service","title":"\u5bf9\u8c61\u5b58\u50a8\u670d\u52a1"},{"location":"thinking_in_industry/","text":"","title":"\u884c\u4e1a\u601d\u8003"}]}