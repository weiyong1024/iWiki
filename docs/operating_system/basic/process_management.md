# 进程管理

## 进程

### 进程概念

进程是执行的程序，随着进程的执行，它改变状态。进程状态是由进程当前活动定义的。每个进程可以出于如下状态：**新的**、**就绪**、**运行**、**等待**、**终止**。在操作系统内，每个进程通过它的 **进程控制块（PCB）** 来表示。

### 进程调度

进程，当不执行时，位于某个等待队列。操作系统有两种主要队列：**IO请求队列**、**就绪队列** 。就绪队列包括所有等待执行并等待CPU的进程。每个进程都用PCB来表示。

操作系统应从各个调度队列中选择进程。**长期调度**（用于作业）选择进程以便竞争CPU。通常，长期调度充分考虑资源分配，尤其内存管理。**短期调度** 从就绪队列中选择进程。

### 进程运行

操作系统必须提供一种机制，以便父进程创建子进程。父进程在继续之前可以等待其子进程终止，也可以与子进程并发执行。允许并发有多个原因：信息共享、计算加速、模块化、方便。

### 进程间通信

操作系统内的执行进程可以是独立的，也可以是协作的。协作进程需要进程间具有相互通信的机制。通信主要有两种形式： **共享内存** 和 **消息系统** 。

* **共享内存**：进程共享一些变量，进程通过使用这些共享变量来交换信息。对于共享内存系统，提供通信的责任主要在应用程序员，操作系统只需要提供共享内存。
* **消息系统**：操作系统负责提供通信机制。

两种方法相互不排斥，可以在统一操作系统内同时实现。

### IPC系统例子

POSIX共享内存、Mach的消息传递、Windows的ALPC（高级本地程序调用）工具。

### 客户机/服务器通信

**套接字** 、 **远程过程调用（PRC）** 、 **管道** 

* **套接字**：套接字定义为通信的端点。一对应用程序之间的连接由一对套接字组成，通信的两端各有一个套接字。
* **RPC**：是另一种形式的分布式通信，当一个进程/线程调用一个远程应用的过程时，就有了RPC。
* **管道**：提供了一个相对简单的进程间相互通信，普通管道允许父进程和子进程之间的通信，命名管道允许不相关进程的通信。


## 多线程编程

### 概述

线程是进程内的控制流。多线程进程在同一地址空间内包括多个不同的控制流。多线程的优点包括：用户响应的改进、进程内资源的共享、经济和可扩展性的因素（如更有效的使用多个处理核）。

### 多核编程

多核系统的引入使得 **并发** 表示线程能够 **并行** 执行，因为系统可以给每个核分配一个单独线程。

多核机制引入的编程挑战：

* 任务识别
* 平衡
* 数据分割
* 数据依赖
* 测试与调试

通常，有两种类型的并行：**数据并行** 和 **任务并行**。

* **数据并行**：将数据分布在相同的计算核上，并在每个核上执行相同操作；
* **任务并行**：将任务（线程）而不是数据分配到多个计算核，每个线程都执行一个独特的操作。

### 多线程模型

**用户线程** 对用户来说是可见的，对内核则是未知的。操作系统支持和管理 **内核级线程** 。通常，用户线程与内核线程相比，创建和管理要更快，因为它不需要内核干预。

三种不同类型的模型关联用户线程和内核线程 

* **多对一模型**：将多个用户线程映射到一个内核线程
* **一对一模型**：将每个用户线程映射到一个对应的内核线程
* **多对多模型**：将多个用户线程在同样（或更少）数量的内核线程之间切换

大多数现代操作系统，如Windows、Mac OS X、Linux和Solaris等，都对线程提供内核支持。

### 线程库

线程库为应用程序员提供了创建和管理线程的API。常用的主要线程库有三个：**POSIX Pthreads**、**Windows线程** 和 **Java线程**。

### 隐式多线程

除了采用线程库API来显式创建线程，还可以使用隐式线程，这种线程的创建和管理交由编译器和运行时库来完成。隐式线程方法包括：**线程池**、**OpenMP** 和 **Grand Central Dispatch** 等。

### 多线程问题

程序员在编写多线程程序的时候要理解`fork()`和`exec()`系统调用的语义。其他问题包括 **信号处理**、**线程撤销**、**线程本地存储** 和 **调度激活** 等

### 操作系统例子

#### Windows线程

每个Windows应用程序按单独进程来运行，每个进程可以包括一个或多个线程。Windows使用一对一映射，即每个用户线程映射到一个相关的内核线程。

线程一般包括如下部件：

* **线程ID** - 用于唯一标识线程。
* **寄存器组** - 用于表示处理器状态。
* **堆栈** - **用户堆栈**，以供线程在用户模式下运行；**内核堆栈**，以供线程在内核模式下运行。
* **私有存储区域** - 用于各种运行时库和动态链接库（DLL）。

寄存器组、堆栈和私有存储区域，通常称为 **线程上下文**（context）

线程的主要数据结构：

* **ETHREAD**：执行线程快。包括所属进程指针、线程控制开始的程序的地址以及对应的KTHREAD的指针等。
* **KTHREAD**：内核线程快。包括线程的调度和同步信息。另外，KTHREAD也包括内核堆栈（以供线程在内核模式下运行）和TEB的指针。
* **TEB**：线程环境块

#### Linux线程

* 系统调用`fork()`：进程复制的传统功能
* 系统调用`clone()`：创建线程

Linux在讨论程序的控制流时，常采用任务（task）一词，而非进程（process）或线程（thread）。


## 进程调度

### 基本概念

CPU调度的任务是，从就绪队列中选择一个等待进程，并为其分配CPU。调度程序分配CPU到选中的进程。

### 调度准则

* CPU使用率
* 吞吐量
* 周转时间
* 等待时间
* 响应时间

### 调度算法

#### 先到先服务

First-Come First-Served, FCFS，最简单的调度算法，但它会让段进城等待很长的进程。

#### 最短作业优先调度

Shortest-Job-First, SJF，在最短平均等待时间意义上是最佳的。

然而，SJF调度实现的难点在于预测下一个CPU执行的长度。

#### 优先级调度

Priority-Scheduling，SJF算法是通用优先级调度算法（简单分配CPU到具有最优优先级的进程）的一个特例。

优先级和SJF的调度可能产生饥饿，老化技术阻止饥饿。

#### 轮转调度

Round-Robin, RR，更适合于分时（交互）系统。RR调度为就绪队列的首个进程，分配 $q$ 个时间单位，这里 $q$ 是时间片。在 $q$ 个时间单位之后，如果该进程还没有释放CPU，那么它被强占并添加到就绪队列尾部。

该算法的主要问题是选择时间片。如果时间片太大，那么RR算法就变成了FCFS算法；如果时间片太小，那么有上下文切换引起的调度开销就过大。

FCFS算法是非抢占的，而RR算法是抢占的。SJF和优先级算法可以是抢占的也可以是非抢占的。

#### 多级队列调度

Multilevel queue scheduling，允许多个不同算法用于不同类型的进程。最常用模型包括：使用RR调度的 **前台交互队列** 与使用FCFS调度的 **后台批处理队列** 。

#### 多级反馈队列调度

Multilevel feedback queue scheduling，多及反馈队列允许进程在队列之间迁移。

### 线程调度

在支持线程的操作系统上，内核级线程（而不是进程）才是操作系统所调度的。用户及线程是由线程库来管理的，而内核并不知道它们。用户线程为了运行在CPU上，最终应映射到相关的内核级线程，但这种映射可能不是直接的，可能采用 **轻量级进程（LWP）** 。

### 多处理器调度

许多现代操作系统支持多处理器，并允许每个处理器独立调度。通常，每个处理器维护各自的、私有的、可运行的进程（或线程）队列。与多处理器调度相关的问题包括处理器亲和性、负载平衡和多核处理等。

### 实时CPU调度

实时计算机系统要求在截止期限之前的得到结果；在截止期限之后得到的结果是无用的。硬实时系统应保证，实时任务在截止期限内得到服务。软实时系统的限制较少，分配给实时任务的调度优先级高于其他服务。

实时调度算法包括 **单调速率** 和 **最早截止优先** 调度。单调速率调度通常为需要更多CPU的任务，分配更高优先级。最早截止优先队列根据即将到来的截止期限来分配优先级；截止期限越早，优先级越高。比例分享调度将处理器时间划分为股份，并为每个进程分配一个数量的份额，从而保证每个进程具有按比例的CPU时间份额。

POSIX和Pthreads API为实时调度线程，也提供各种特征。

### 操作系统例子

支持内核级线程的操作系统应调度执行线程（而不是进程）。Solaris和Windows就是这样的系统。这两个系统都通过基于抢占的优先级调度算法来调度线程，包括支持实时线程。Linux进程调度程序使用基于优先级的算法，也提供实时支持。这三个操作系统的调度算法通常偏向支持交互式进程（而非CPU密集型继承）。

### 算法评估

各种各样的调度算法要求有选择算法的方法。分析方法使用数学分析法以确定算法性能。仿真方法对代表性的进程，采用调度算法仿真，并计算性能，进而确定优劣。然而，仿真最多只能提供真实系统性能的近似值。评估调度算法的唯一可靠技术是：在实际系统上实现算法，并在“现实世界”环境中监视性能。


## 同步

### 背景

### 临界区问题

### Peterson解决方案

### 硬件同步

### 互斥锁

### 信号量

### 经典同步问题

#### 有限缓冲问题

#### 读者-作者问题

#### 哲学家就餐问题

### 管程

### 同步例子

### 替代方法


## 死锁

### 系统模型

### 死锁特征

### 死锁处理方法

### 死锁预防

### 死锁避免

### 死锁检测

### 死锁恢复
